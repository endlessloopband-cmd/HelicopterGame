<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHOPPER COMMAND - LEGENDARY EDITION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            background: #000;
            border: 4px solid #0ff;
            box-shadow: 0 0 30px #0ff, 0 0 60px #f0f, inset 0 0 30px rgba(0,255,255,0.1);
            animation: borderPulse 2s infinite;
        }
        @keyframes borderPulse {
            0%, 100% { border-color: #0ff; box-shadow: 0 0 30px #0ff, 0 0 60px #f0f; }
            50% { border-color: #f0f; box-shadow: 0 0 30px #f0f, 0 0 60px #0ff; }
        }
        #crt {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            z-index: 100;
        }
        canvas { display: block; image-rendering: pixelated; }
        #ui {
            position: absolute;
            top: 10px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            text-shadow: 0 0 10px currentColor;
            z-index: 50;
        }
        .score-label { color: #0ff; text-shadow: 0 0 10px #0ff, 0 0 20px #0ff; }
        .lives-display { color: #f0f; text-shadow: 0 0 10px #f0f; }
        .level-display { color: #ff0; text-shadow: 0 0 10px #ff0; }
        #comboIndicator {
            position: absolute;
            top: 50px; right: 15px;
            font-size: 24px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #powerupIndicator {
            position: absolute;
            top: 50px; left: 15px;
            font-size: 10px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            z-index: 50;
        }
        #weaponIndicator {
            position: absolute;
            top: 70px; left: 15px;
            font-size: 8px;
            color: #ff0;
            text-shadow: 0 0 8px #ff0;
            z-index: 50;
        }
        #godlikeOverlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 90;
            opacity: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255,100,0,0.3) 100%);
            transition: opacity 0.3s;
        }
        #bossHealth {
            position: absolute;
            top: 35px; left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 16px;
            background: #111;
            border: 2px solid #f00;
            box-shadow: 0 0 15px #f00;
            z-index: 50;
            display: none;
        }
        #bossHealthBar {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0, #f00);
            background-size: 200% 100%;
            animation: healthShimmer 1s linear infinite;
            width: 100%;
        }
        @keyframes healthShimmer {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }
        #bossName {
            position: absolute;
            top: 55px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
            z-index: 50;
            display: none;
            animation: bossNamePulse 0.5s infinite;
        }
        @keyframes bossNamePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 20, 0.95);
            color: #fff;
            z-index: 200;
        }
        .overlay h1 {
            font-size: 36px;
            background: linear-gradient(90deg, #0ff, #f0f, #ff0, #0ff);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbowText 3s linear infinite;
            margin-bottom: 10px;
            text-shadow: none;
            filter: drop-shadow(0 0 20px #0ff);
        }
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }
        .subtitle {
            font-size: 14px;
            color: #f0f;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #f0f;
            animation: subtitleGlow 1s infinite alternate;
        }
        @keyframes subtitleGlow {
            0% { text-shadow: 0 0 10px #f0f; }
            100% { text-shadow: 0 0 30px #f0f, 0 0 50px #f0f; }
        }
        .menu-option {
            margin: 8px;
            padding: 15px 30px;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px #0ff;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
        .menu-option:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff, 0 0 50px #0ff;
            text-shadow: none;
            transform: scale(1.1);
        }
        .difficulty-btn.easy { border-color: #0f0; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .difficulty-btn.easy:hover { background: #0f0; box-shadow: 0 0 30px #0f0; }
        .difficulty-btn.normal { border-color: #ff0; color: #ff0; text-shadow: 0 0 10px #ff0; }
        .difficulty-btn.normal:hover { background: #ff0; box-shadow: 0 0 30px #ff0; }
        .difficulty-btn.hard { border-color: #f00; color: #f00; text-shadow: 0 0 10px #f00; }
        .difficulty-btn.hard:hover { background: #f00; box-shadow: 0 0 30px #f00; }
        .difficulty-btn.legendary { border-color: #f0f; color: #f0f; text-shadow: 0 0 10px #f0f; animation: legendaryPulse 0.5s infinite; }
        .difficulty-btn.legendary:hover { background: #f0f; box-shadow: 0 0 50px #f0f; }
        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px #f0f; }
            50% { box-shadow: 0 0 30px #f0f, 0 0 50px #0ff; }
        }
        .mode-section { margin-top: 20px; }
        .mode-btn { font-size: 10px; padding: 10px 20px; border-color: #888; color: #888; }
        .mode-btn:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }
        #finalScore { font-size: 28px; color: #0ff; margin: 15px 0; text-shadow: 0 0 20px #0ff; }
        .highscore-list { font-size: 10px; color: #f0f; margin: 10px 0; text-align: left; }
        .controls-info { font-size: 8px; color: #666; margin-top: 25px; }
        #pauseScreen h1 { filter: drop-shadow(0 0 20px #0ff); }
        /* Upgrade screen */
        #upgradeScreen { display: none; }
        .upgrade-option {
            margin: 5px;
            padding: 10px 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .perk-icon { font-size: 20px; }
        /* Mobile controls */
        #mobileControls { display: none; position: absolute; bottom: 10px; left: 10px; right: 10px; z-index: 150; }
        .mobile-btn {
            width: 60px; height: 60px;
            background: rgba(0,255,255,0.2);
            border: 2px solid rgba(0,255,255,0.5);
            border-radius: 15px;
            color: #0ff;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        #joystickArea {
            position: absolute;
            left: 10px; bottom: 10px;
            width: 120px; height: 120px;
            background: rgba(0,255,255,0.1);
            border-radius: 60px;
            border: 2px solid rgba(0,255,255,0.3);
        }
        #joystick {
            position: absolute;
            width: 50px; height: 50px;
            background: rgba(0,255,255,0.5);
            border-radius: 25px;
            left: 35px; top: 35px;
        }
        #fireBtn { position: absolute; right: 20px; bottom: 30px; width: 80px; height: 80px; background: rgba(255,0,100,0.3); border-color: #f0f; }
        #bombBtn { position: absolute; right: 110px; bottom: 50px; background: rgba(255,165,0,0.3); border-color: #fa0; }
        #laserBtn { position: absolute; right: 110px; bottom: 120px; background: rgba(255,0,0,0.3); border-color: #f00; font-size: 8px; }
        @media (max-width: 850px) {
            #mobileControls { display: block; }
            #ui { font-size: 10px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="crt"></div>
        <div id="godlikeOverlay"></div>
        <div id="ui">
            <div><span class="score-label">SCORE</span><br><span id="score">00000000</span></div>
            <div><span class="level-display">STAGE</span><br><span id="level">01</span></div>
            <div><span class="lives-display">LIVES</span><br><span id="lives"></span></div>
        </div>
        <div id="comboIndicator">x1</div>
        <div id="powerupIndicator"></div>
        <div id="weaponIndicator">WEAPON: NORMAL</div>
        <div id="bossHealth"><div id="bossHealthBar"></div></div>
        <div id="bossName">BOSS</div>

        <div id="startScreen" class="overlay">
            <h1>CHOPPER COMMAND</h1>
            <p class="subtitle">â˜… LEGENDARY EDITION â˜…</p>
            <p style="font-size:10px;color:#666;margin-bottom:15px;">SELECT DIFFICULTY</p>
            <button class="menu-option difficulty-btn easy" onclick="startGame('easy')">EASY</button>
            <button class="menu-option difficulty-btn normal" onclick="startGame('normal')">NORMAL</button>
            <button class="menu-option difficulty-btn hard" onclick="startGame('hard')">HARD</button>
            <button class="menu-option difficulty-btn legendary" onclick="startGame('legendary')">LEGENDARY</button>
            <div class="mode-section">
                <button class="menu-option mode-btn" onclick="startGame('endless')">ENDLESS MODE</button>
                <button class="menu-option mode-btn" onclick="startGame('bossrush')">BOSS RUSH</button>
            </div>
            <p class="controls-info">WASD/ARROWS: Move | SPACE: Fire | B: Bomb | L: Laser | R: Rockets<br>ESC: Pause | M: Music | 1-4: Weapons</p>
        </div>

        <div id="pauseScreen" class="overlay" style="display:none;">
            <h1>PAUSED</h1>
            <button class="menu-option" onclick="resumeGame()">RESUME</button>
            <button class="menu-option" onclick="quitToMenu()">QUIT</button>
        </div>

        <div id="upgradeScreen" class="overlay">
            <h1 style="font-size:24px;">LEVEL UP!</h1>
            <p style="color:#0ff;margin:20px;">Choose your upgrade:</p>
            <div id="upgradeOptions"></div>
        </div>

        <div id="gameOverScreen" class="overlay" style="display:none;">
            <h1>GAME OVER</h1>
            <div id="finalScore">00000000</div>
            <div class="highscore-list" id="highscoreList"></div>
            <button class="menu-option" onclick="showMenu()">MENU</button>
        </div>

        <div id="mobileControls">
            <div id="joystickArea"><div id="joystick"></div></div>
            <div id="fireBtn" class="mobile-btn">FIRE</div>
            <div id="bombBtn" class="mobile-btn">BOMB</div>
            <div id="laserBtn" class="mobile-btn">LASER</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ============ LEGENDARY AUDIO ENGINE ============
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        let musicPlaying = false;
        let musicNodes = { bass: null, lead: null, drums: null, intensity: 0 };
        let voiceCooldown = 0;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioCtx();
        }

        // Voice samples (8-bit style)
        function playVoice(text) {
            if (!audioCtx || voiceCooldown > 0) return;
            voiceCooldown = 120;

            const frequencies = {
                'COMBO': [440, 550, 660],
                'MEGA KILL': [330, 440, 550, 660],
                'UNSTOPPABLE': [220, 330, 440, 550, 660, 770],
                'GODLIKE': [110, 220, 330, 440, 550, 660, 770, 880],
                'BOSS INCOMING': [220, 165, 220, 165]
            };

            const freqs = frequencies[text] || [440];
            freqs.forEach((f, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(f, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                }, i * 80);
            });
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(880, now);
                    osc.frequency.exponentialRampToValueAtTime(110, now + 0.06);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
                    osc.start(now); osc.stop(now + 0.06);
                    break;
                case 'laser':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                    osc.frequency.linearRampToValueAtTime(200, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                case 'rocket':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'plasma':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.setValueAtTime(300, now + 0.05);
                    osc.frequency.setValueAtTime(150, now + 0.1);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                case 'explosion':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                    break;
                case 'megaExplosion':
                    // Multiple layered explosion
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const o = audioCtx.createOscillator();
                            const g = audioCtx.createGain();
                            o.connect(g); g.connect(audioCtx.destination);
                            o.type = 'sawtooth';
                            o.frequency.setValueAtTime(100 - i*20, audioCtx.currentTime);
                            o.frequency.exponentialRampToValueAtTime(15, audioCtx.currentTime + 0.6);
                            g.gain.setValueAtTime(0.4, audioCtx.currentTime);
                            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                            o.start(); o.stop(audioCtx.currentTime + 0.6);
                        }, i * 100);
                    }
                    return;
                case 'hit':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.08);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    osc.start(now); osc.stop(now + 0.08);
                    break;
                case 'powerup':
                    osc.type = 'sine';
                    [440, 550, 660, 880].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.05));
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                    osc.start(now); osc.stop(now + 0.25);
                    break;
                case 'combo':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(660, now);
                    osc.frequency.setValueAtTime(880, now + 0.05);
                    osc.frequency.setValueAtTime(1100, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                case 'bomb':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(60, now);
                    osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
                case 'boss':
                    for (let i = 0; i < 6; i++) {
                        osc.frequency.setValueAtTime(110, now + i*0.15);
                        osc.frequency.setValueAtTime(220, now + i*0.15 + 0.07);
                    }
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                    osc.start(now); osc.stop(now + 1);
                    break;
                case 'slowmo':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'thunder':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.setValueAtTime(60, now + 0.1);
                    osc.frequency.setValueAtTime(40, now + 0.3);
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'levelUp':
                    osc.type = 'square';
                    [440, 550, 660, 880, 1100].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.08));
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'gameOver':
                    osc.type = 'square';
                    [440, 330, 220, 110, 55].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.15));
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
            }
        }

        // Dynamic layered music
        let musicBeat = 0;
        const bassPattern = [1,0,0,1,0,0,1,0, 1,0,0,1,0,1,0,0];
        const hihatPattern = [1,0,1,0,1,0,1,0, 1,0,1,0,1,1,1,0];
        const melodyNotes = [262, 294, 330, 392, 440, 494, 523, 587];
        const melodyPattern = [0,0,2,2,4,4,2,0, 5,5,4,4,2,2,0,0];

        function playMusicBeat() {
            if (!audioCtx || !musicPlaying) return;
            const now = audioCtx.currentTime;
            const intensity = musicNodes.intensity;

            // Bass drum
            if (bassPattern[musicBeat % 16]) {
                const kick = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kick.connect(kickGain);
                kickGain.connect(audioCtx.destination);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, now);
                kick.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                kickGain.gain.setValueAtTime(0.15 + intensity * 0.1, now);
                kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                kick.start(now);
                kick.stop(now + 0.1);
            }

            // Hi-hat
            if (hihatPattern[musicBeat % 16] && intensity > 0.3) {
                const hat = audioCtx.createOscillator();
                const hatGain = audioCtx.createGain();
                hat.connect(hatGain);
                hatGain.connect(audioCtx.destination);
                hat.type = 'square';
                hat.frequency.setValueAtTime(800 + Math.random() * 200, now);
                hatGain.gain.setValueAtTime(0.03 + intensity * 0.02, now);
                hatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                hat.start(now);
                hat.stop(now + 0.03);
            }

            // Melody
            if (musicBeat % 2 === 0 && intensity > 0.5) {
                const mel = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();
                mel.connect(melGain);
                melGain.connect(audioCtx.destination);
                mel.type = 'square';
                mel.frequency.setValueAtTime(melodyNotes[melodyPattern[musicBeat % 16]], now);
                melGain.gain.setValueAtTime(0.05 + intensity * 0.03, now);
                melGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                mel.start(now);
                mel.stop(now + 0.12);
            }

            // Arpeggio on high intensity
            if (intensity > 0.7 && musicBeat % 4 === 0) {
                [0, 100, 200].forEach((delay, i) => {
                    setTimeout(() => {
                        const arp = audioCtx.createOscillator();
                        const arpGain = audioCtx.createGain();
                        arp.connect(arpGain);
                        arpGain.connect(audioCtx.destination);
                        arp.type = 'sine';
                        arp.frequency.setValueAtTime(523 * (1 + i * 0.25), audioCtx.currentTime);
                        arpGain.gain.setValueAtTime(0.04, audioCtx.currentTime);
                        arpGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                        arp.start();
                        arp.stop(audioCtx.currentTime + 0.08);
                    }, delay);
                });
            }

            musicBeat++;
        }

        let musicInterval = null;
        function toggleMusic() {
            musicPlaying = !musicPlaying;
            if (musicPlaying) {
                musicInterval = setInterval(playMusicBeat, 125); // 120 BPM
            } else {
                clearInterval(musicInterval);
            }
        }

        // ============ SPRITES ============
        const sprites = { helicopter: new Image(), explosion: new Image() };
        let spritesLoaded = 0;
        sprites.helicopter.onload = () => spritesLoaded++;
        sprites.explosion.onload = () => spritesLoaded++;
        sprites.helicopter.src = 'sprites/helicopter.png';
        sprites.explosion.src = 'sprites/explosion.png';

        // ============ GAME CONFIG ============
        const difficulties = {
            easy: { lives: 5, enemySpawnRate: 2500, enemySpeed: 0.7, playerSpeed: 6, scoreMultiplier: 0.5 },
            normal: { lives: 3, enemySpawnRate: 2000, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 1 },
            hard: { lives: 2, enemySpawnRate: 1500, enemySpeed: 1.3, playerSpeed: 5, scoreMultiplier: 1.5 },
            legendary: { lives: 1, enemySpawnRate: 1200, enemySpeed: 1.5, playerSpeed: 5.5, scoreMultiplier: 3 },
            endless: { lives: 3, enemySpawnRate: 2000, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 2, endless: true },
            bossrush: { lives: 5, enemySpawnRate: 99999, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 2, bossRush: true }
        };

        // ============ GAME STATE ============
        let gameRunning = false;
        let paused = false;
        let difficulty = 'normal';
        let gameMode = 'normal';
        let score = 0;
        let lives = 3;
        let level = 1;
        let enemySpawnRate = 2000;
        let lastEnemySpawn = 0;
        let frame = 0;
        let screenShake = 0;
        let bombs = 3;
        let killStreak = 0;
        let killStreakTimer = 0;

        // Slow motion
        let slowMotion = 0;
        let slowMotionFactor = 1;

        // Weather
        let weather = { rain: [], lightning: 0, thunderTimer: 0 };

        // Combo system
        let combo = 0;
        let comboTimer = 0;
        let comboMultiplier = 1;

        // Weapons
        let currentWeapon = 'normal';
        let laserCharge = 100;
        let laserActive = false;
        let rocketAmmo = 5;
        let plasmaCharge = 0;

        // Perks/Upgrades
        let perks = {
            fireRate: 0,
            damage: 0,
            speed: 0,
            magnet: 0,
            doubleScore: false
        };

        // Boss
        let boss = null;
        let bossWarning = 0;
        let bossType = 0;

        // Power-ups
        let powerups = [];
        let activePowerups = { rapid: 0, spread: 0, shield: 0 };

        // High scores
        let highScores = JSON.parse(localStorage.getItem('chopperLegendaryScores') || '[]');

        const player = {
            x: 100, y: 300,
            width: 64, height: 32,
            speed: 5,
            bullets: [],
            rockets: [],
            plasma: [],
            lastShot: 0,
            shootCooldown: 180,
            animFrame: 0,
            invincible: 0,
            tilt: 0,
            fireLevel: 1
        };

        let enemies = [];
        let explosions = [];
        let particles = [];
        let floatingTexts = [];
        let shockwaves = [];
        let debris = [];

        // Background
        let stars = [];
        let clouds = [];
        let mountains = [];
        let trees = [];
        let neonGrid = [];

        function initBackground() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.6,
                    size: Math.random() < 0.1 ? 3 : Math.random() < 0.3 ? 2 : 1,
                    speed: Math.random() * 0.5 + 0.1,
                    twinkle: Math.random() * 100,
                    color: ['#fff', '#0ff', '#f0f', '#ff0'][Math.floor(Math.random() * 4)]
                });
            }
            clouds = [];
            for (let i = 0; i < 8; i++) {
                clouds.push({
                    x: Math.random() * canvas.width * 1.5,
                    y: Math.random() * 200 + 30,
                    width: Math.random() * 150 + 80,
                    speed: Math.random() * 0.4 + 0.2
                });
            }
            mountains = [];
            for (let i = 0; i < 20; i++) {
                mountains.push({
                    x: i * 100,
                    height: Math.random() * 150 + 80,
                    width: Math.random() * 120 + 80
                });
            }
            trees = [];
            for (let i = 0; i < 40; i++) {
                trees.push({
                    x: Math.random() * canvas.width * 2,
                    height: Math.random() * 40 + 25
                });
            }
            // Neon grid lines
            neonGrid = [];
            for (let i = 0; i < 20; i++) {
                neonGrid.push({ y: canvas.height - 80 + i * 15, offset: 0 });
            }
            // Rain
            weather.rain = [];
            for (let i = 0; i < 100; i++) {
                weather.rain.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 10 + 15,
                    length: Math.random() * 15 + 10
                });
            }
        }
        initBackground();

        // ============ INPUT ============
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
            if (e.code === 'Escape' && gameRunning) togglePause();
            if (e.code === 'KeyM') toggleMusic();
            if (e.code === 'KeyB' && gameRunning && !paused) useBomb();
            if (e.code === 'KeyL' && gameRunning && !paused) activateLaser();
            if (e.code === 'KeyR' && gameRunning && !paused) fireRocket();
            if (e.code === 'Digit1') currentWeapon = 'normal';
            if (e.code === 'Digit2') currentWeapon = 'spread';
            if (e.code === 'Digit3') currentWeapon = 'laser';
            if (e.code === 'Digit4') currentWeapon = 'rocket';
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mobile controls
        let touchJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        let touchFire = false;

        const joystickArea = document.getElementById('joystickArea');
        const joystick = document.getElementById('joystick');
        const fireBtn = document.getElementById('fireBtn');
        const bombBtn = document.getElementById('bombBtn');
        const laserBtn = document.getElementById('laserBtn');

        joystickArea?.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = joystickArea.getBoundingClientRect();
            touchJoystick.active = true;
            touchJoystick.startX = rect.left + rect.width/2;
            touchJoystick.startY = rect.top + rect.height/2;
        });

        document.addEventListener('touchmove', (e) => {
            if (!touchJoystick.active) return;
            const touch = e.touches[0];
            touchJoystick.dx = (touch.clientX - touchJoystick.startX) / 40;
            touchJoystick.dy = (touch.clientY - touchJoystick.startY) / 40;
            const dist = Math.sqrt(touchJoystick.dx**2 + touchJoystick.dy**2);
            if (dist > 1) {
                touchJoystick.dx /= dist;
                touchJoystick.dy /= dist;
            }
            joystick.style.transform = `translate(${touchJoystick.dx*30}px, ${touchJoystick.dy*30}px)`;
        });

        document.addEventListener('touchend', () => {
            touchJoystick.active = false;
            touchJoystick.dx = 0;
            touchJoystick.dy = 0;
            joystick.style.transform = 'translate(0,0)';
            touchFire = false;
        });

        fireBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); touchFire = true; });
        fireBtn?.addEventListener('touchend', () => touchFire = false);
        bombBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); useBomb(); });
        laserBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); activateLaser(); });

        // ============ GAME FUNCTIONS ============
        function startGame(diff) {
            initAudio();
            if (spritesLoaded < 2) { setTimeout(() => startGame(diff), 100); return; }

            difficulty = diff;
            gameMode = diff;
            const cfg = difficulties[diff];
            lives = cfg.lives;
            player.speed = cfg.playerSpeed;
            enemySpawnRate = cfg.enemySpawnRate;

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('upgradeScreen').style.display = 'none';

            score = 0;
            level = 1;
            bombs = 3;
            combo = 0;
            comboTimer = 0;
            comboMultiplier = 1;
            killStreak = 0;
            slowMotion = 0;
            slowMotionFactor = 1;
            currentWeapon = 'normal';
            laserCharge = 100;
            laserActive = false;
            rocketAmmo = 5;
            plasmaCharge = 0;
            bossType = 0;

            player.x = 100;
            player.y = canvas.height / 2;
            player.bullets = [];
            player.rockets = [];
            player.plasma = [];
            player.invincible = 0;
            player.tilt = 0;
            player.fireLevel = 1;

            perks = { fireRate: 0, damage: 0, speed: 0, magnet: 0, doubleScore: false };

            enemies = [];
            explosions = [];
            particles = [];
            powerups = [];
            floatingTexts = [];
            shockwaves = [];
            debris = [];
            boss = null;
            miniBoss = null;
            mines = [];
            activePowerups = { rapid: 0, spread: 0, shield: 0 };
            weather.lightning = 0;
            weather.thunderTimer = 0;

            musicNodes.intensity = 0.3;
            updateUI();
            gameRunning = true;
            paused = false;
            lastEnemySpawn = Date.now();

            if (!musicPlaying) toggleMusic();

            // Boss rush mode starts with boss
            if (cfg.bossRush) {
                setTimeout(() => spawnBoss(), 1000);
            }

            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseScreen').style.display = paused ? 'flex' : 'none';
            if (!paused) requestAnimationFrame(gameLoop);
        }

        function resumeGame() { togglePause(); }

        function quitToMenu() {
            gameRunning = false;
            paused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            if (musicPlaying) toggleMusic();
        }

        function showMenu() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function gameOver() {
            gameRunning = false;
            playSound('gameOver');
            if (musicPlaying) toggleMusic();

            const cfg = difficulties[difficulty];
            const finalScore = Math.floor(score * cfg.scoreMultiplier);

            highScores.push({ score: finalScore, level, difficulty, mode: gameMode });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('chopperLegendaryScores', JSON.stringify(highScores));

            document.getElementById('finalScore').textContent = String(finalScore).padStart(8, '0');
            document.getElementById('bossHealth').style.display = 'none';
            document.getElementById('bossName').style.display = 'none';
            document.getElementById('godlikeOverlay').style.opacity = '0';

            let listHTML = '<b style="color:#0ff">â˜… HIGH SCORES â˜…</b><br>';
            highScores.slice(0, 5).forEach((hs, i) => {
                const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '  ';
                listHTML += `${medal} ${String(hs.score).padStart(8, '0')} L${hs.level}<br>`;
            });
            document.getElementById('highscoreList').innerHTML = listHTML;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function showUpgradeScreen() {
            paused = true;
            const screen = document.getElementById('upgradeScreen');
            const options = document.getElementById('upgradeOptions');

            const availablePerks = [
                { id: 'fireRate', icon: 'ðŸ”¥', name: 'RAPID FIRE', desc: '+20% Fire Rate', effect: () => perks.fireRate++ },
                { id: 'damage', icon: 'ðŸ’¥', name: 'POWER UP', desc: '+25% Damage', effect: () => perks.damage++ },
                { id: 'speed', icon: 'âš¡', name: 'SPEED BOOST', desc: '+15% Move Speed', effect: () => { perks.speed++; player.speed *= 1.15; } },
                { id: 'magnet', icon: 'ðŸ§²', name: 'MAGNET', desc: 'Attract Power-ups', effect: () => perks.magnet++ },
                { id: 'rockets', icon: 'ðŸš€', name: 'ROCKETS +3', desc: '+3 Homing Rockets', effect: () => rocketAmmo += 3 },
                { id: 'bombs', icon: 'ðŸ’£', name: 'BOMBS +2', desc: '+2 Mega Bombs', effect: () => bombs += 2 },
                { id: 'life', icon: 'â¤ï¸', name: 'EXTRA LIFE', desc: '+1 Life', effect: () => lives++ }
            ];

            // Random 3 perks
            const shuffled = availablePerks.sort(() => Math.random() - 0.5).slice(0, 3);

            options.innerHTML = '';
            shuffled.forEach(perk => {
                const btn = document.createElement('button');
                btn.className = 'menu-option upgrade-option';
                btn.innerHTML = `<span class="perk-icon">${perk.icon}</span><div><b>${perk.name}</b><br><small style="color:#888">${perk.desc}</small></div>`;
                btn.onclick = () => {
                    perk.effect();
                    screen.style.display = 'none';
                    paused = false;
                    updateUI();
                    requestAnimationFrame(gameLoop);
                };
                options.appendChild(btn);
            });

            screen.style.display = 'flex';
        }

        function updateUI() {
            const cfg = difficulties[difficulty];
            const displayScore = Math.floor(score * cfg.scoreMultiplier);
            document.getElementById('score').textContent = String(displayScore).padStart(8, '0');
            document.getElementById('level').textContent = String(level).padStart(2, '0');
            document.getElementById('lives').textContent = 'â™¥'.repeat(Math.max(0, lives)) + ' ðŸ’£' + bombs;

            const comboEl = document.getElementById('comboIndicator');
            if (comboMultiplier > 1) {
                comboEl.textContent = 'x' + comboMultiplier + (combo >= 20 ? ' GODLIKE!' : combo >= 10 ? ' UNSTOPPABLE!' : combo >= 5 ? ' MEGA!' : '');
                comboEl.style.opacity = '1';
                comboEl.style.fontSize = Math.min(24 + combo, 40) + 'px';
            } else {
                comboEl.style.opacity = '0';
            }

            let pwrText = '';
            if (activePowerups.rapid > 0) pwrText += 'âš¡RAPID ';
            if (activePowerups.spread > 0) pwrText += 'ðŸ”±SPREAD ';
            if (activePowerups.shield > 0) pwrText += 'ðŸ›¡ï¸SHIELD ';
            document.getElementById('powerupIndicator').textContent = pwrText;

            const weapons = {
                normal: { num: 1, name: 'NORMAL' },
                spread: { num: 2, name: 'SPREAD' },
                laser: { num: 3, name: `LASER [${Math.floor(laserCharge)}%]` },
                rocket: { num: 4, name: `ROCKETS [${rocketAmmo}]` }
            };
            const w = weapons[currentWeapon];
            document.getElementById('weaponIndicator').textContent = `[${w.num}] ${w.name}`;

            // Godlike overlay
            document.getElementById('godlikeOverlay').style.opacity = combo >= 20 ? '0.8' : combo >= 10 ? '0.4' : '0';

            // Music intensity
            musicNodes.intensity = Math.min(1, 0.3 + combo * 0.03 + (boss ? 0.3 : 0));
        }

        function activateLaser() {
            if (laserCharge >= 20 && !laserActive) {
                laserActive = true;
                playSound('laser');
            }
        }

        function fireRocket() {
            if (rocketAmmo > 0 && !paused) {
                rocketAmmo--;
                playSound('rocket');

                // Find nearest enemy
                let target = null;
                let minDist = Infinity;
                [...enemies, boss].filter(e => e).forEach(e => {
                    const dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist < minDist) { minDist = dist; target = e; }
                });

                player.rockets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    width: 20, height: 8,
                    speed: 8,
                    target,
                    angle: 0,
                    trail: []
                });
                updateUI();
            }
        }

        function useBomb() {
            if (bombs <= 0 || !gameRunning || paused) return;
            bombs--;
            playSound('megaExplosion');
            screenShake = 40;

            // Create mega shockwave
            shockwaves.push({ x: player.x + player.width/2, y: player.y + player.height/2, radius: 0, maxRadius: 600, speed: 15, color: '#f80' });

            // Kill all enemies
            enemies.forEach(e => {
                createExplosion(e.x + e.width/2, e.y + e.height/2, true);
                score += e.points;
                spawnDebris(e.x + e.width/2, e.y + e.height/2, 5);
            });
            enemies = [];

            // Heavy boss damage
            if (boss) {
                boss.health -= 30;
                createExplosion(boss.x + boss.width/2, boss.y + boss.height/2, true);
            }

            // Mini-boss damage
            if (miniBoss) {
                miniBoss.health -= 20;
                createExplosion(miniBoss.x + miniBoss.width/2, miniBoss.y + miniBoss.height/2, true);
                if (miniBoss.health <= 0) {
                    score += 2000 * level;
                    floatingTexts.push({ x: miniBoss.x, y: miniBoss.y, text: 'MINI-BOSS DOWN!', color: '#f80', life: 80, size: 14 });
                    miniBoss = null;
                }
            }

            // Clear all mines
            mines.forEach(m => {
                createExplosion(m.x, m.y, false);
            });
            mines = [];

            // Nuclear flash
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 60,
                    color: ['#fff', '#ff0', '#f80'][Math.floor(Math.random() * 3)],
                    size: Math.random() * 10 + 5
                });
            }

            updateUI();
        }

        function spawnPowerup(x, y) {
            const types = ['rapid', 'spread', 'shield', 'bomb', 'life', 'rocket', 'laser'];
            const colors = { rapid: '#ff0', spread: '#00f', shield: '#0f0', bomb: '#f00', life: '#f0f', rocket: '#fa0', laser: '#f00' };
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push({ x, y, type, color: colors[type], width: 24, height: 24, vy: 0, pulse: 0 });
        }

        function collectPowerup(p) {
            playSound('powerup');
            floatingTexts.push({ x: p.x, y: p.y, text: p.type.toUpperCase() + '!', color: p.color, life: 60, size: 14 });

            switch(p.type) {
                case 'rapid': activePowerups.rapid = 600; player.shootCooldown = 60; break;
                case 'spread': activePowerups.spread = 600; break;
                case 'shield': activePowerups.shield = 600; break;
                case 'bomb': bombs = Math.min(bombs + 1, 9); break;
                case 'life': lives = Math.min(lives + 1, 9); break;
                case 'rocket': rocketAmmo = Math.min(rocketAmmo + 3, 20); break;
                case 'laser': laserCharge = Math.min(laserCharge + 50, 100); break;
            }
            updateUI();
        }

        function triggerSlowMotion() {
            if (slowMotion <= 0) {
                slowMotion = 90;
                slowMotionFactor = 0.3;
                playSound('slowmo');
                playVoice('MEGA KILL');
            }
        }

        function spawnDebris(x, y, count) {
            for (let i = 0; i < count; i++) {
                debris.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    rotation: Math.random() * 360,
                    rotSpeed: (Math.random() - 0.5) * 20,
                    size: Math.random() * 12 + 4,
                    life: 120,
                    color: ['#555', '#666', '#777', '#444'][Math.floor(Math.random() * 4)]
                });
            }
        }

        // ============ ENEMY SPAWNING ============
        // Mines array
        let mines = [];

        // Mini-boss system
        let miniBoss = null;
        const miniBossTypes = [
            { name: 'STRIKE LEADER', health: 50, width: 80, height: 35, color: '#a44', escort: 3 },
            { name: 'HEAVY BOMBER', health: 80, width: 120, height: 55, color: '#4a4', bombRate: 40 },
            { name: 'STEALTH HUNTER', health: 40, width: 70, height: 30, color: '#448', cloakDuration: 120 }
        ];

        // Formation patterns
        const formations = {
            v: [{x:0,y:0}, {x:-35,y:35}, {x:35,y:35}, {x:-70,y:70}, {x:70,y:70}],
            wall: [{x:0,y:-50}, {x:0,y:-25}, {x:0,y:0}, {x:0,y:25}, {x:0,y:50}],
            circle: [{x:0,y:-40}, {x:35,y:-20}, {x:35,y:20}, {x:0,y:40}, {x:-35,y:20}, {x:-35,y:-20}],
            snake: [{x:0,y:0}, {x:40,y:15}, {x:80,y:0}, {x:120,y:-15}, {x:160,y:0}]
        };

        function spawnFormation(formationType, enemyType) {
            const pattern = formations[formationType];
            const baseX = canvas.width + 100;
            const baseY = 150 + Math.random() * (canvas.height - 400);
            const cfg = difficulties[difficulty];

            pattern.forEach((pos, i) => {
                setTimeout(() => {
                    const enemy = createEnemy(enemyType || 'fighter', baseX + pos.x, baseY + pos.y);
                    enemy.formation = formationType;
                    enemy.formationIndex = i;
                    enemy.formationBaseY = baseY;
                    enemies.push(enemy);
                }, i * 100);
            });
        }

        function createEnemy(type, x, y) {
            const cfg = difficulties[difficulty];
            const isGround = type === 'turret';

            // Extended enemy properties
            const props = {
                fighter: { width: 55, height: 24, speed: 3, health: 1, points: 100, shootCooldown: 1500, glowColor: '#4af' },
                bomber: { width: 100, height: 40, speed: 1.5, health: 4, points: 500, shootCooldown: 800, glowColor: '#4a4' },
                jet: { width: 60, height: 20, speed: 6, health: 1, points: 200, shootCooldown: 2000, glowColor: '#f44' },
                helicopter: { width: 75, height: 28, speed: 2.5, health: 2, points: 300, shootCooldown: 1000, glowColor: '#f84' },
                turret: { width: 40, height: 35, speed: 0.8, health: 2, points: 150, shootCooldown: 600, glowColor: '#ff0' },
                drone: { width: 30, height: 30, speed: 4, health: 1, points: 250, shootCooldown: 1200, glowColor: '#f0f' },
                // NEW ENEMIES
                kamikaze: { width: 35, height: 25, speed: 7, health: 1, points: 150, shootCooldown: 9999, glowColor: '#f00' },
                blinker: { width: 28, height: 28, speed: 2, health: 2, points: 300, shootCooldown: 800, glowColor: '#0ff' },
                shielder: { width: 65, height: 40, speed: 1.5, health: 3, points: 400, shootCooldown: 1200, glowColor: '#00f', shieldHP: 5 },
                miner: { width: 50, height: 30, speed: 2, health: 2, points: 250, shootCooldown: 9999, glowColor: '#0f0' },
                scout: { width: 25, height: 18, speed: 7, health: 1, points: 350, shootCooldown: 1500, glowColor: '#ff0' }
            };

            const p = props[type] || props.fighter;

            return {
                x: x !== undefined ? x : canvas.width + 50,
                y: y !== undefined ? y : (isGround ? canvas.height - 100 : Math.random() * (canvas.height - 300) + 100),
                width: p.width,
                height: p.height,
                speed: p.speed * cfg.enemySpeed,
                type,
                bullets: [],
                lastShot: Date.now(),
                shootCooldown: p.shootCooldown,
                health: p.health,
                maxHealth: p.health,
                points: p.points,
                amplitude: Math.random() * 50 + 20,
                frequency: Math.random() * 0.04 + 0.01,
                startY: y !== undefined ? y : 0,
                glowColor: p.glowColor,
                // Special properties
                shieldHP: p.shieldHP || 0,
                shieldMaxHP: p.shieldHP || 0,
                teleportTimer: type === 'blinker' ? 150 + Math.random() * 60 : 0,
                teleportWarning: 0,
                mineTimer: type === 'miner' ? 90 : 0,
                cloaked: false,
                cloakTimer: 0,
                dodgeCooldown: 0,
                afterImages: []
            };
        }

        function spawnEnemy() {
            if (boss || miniBoss) return;

            const cfg = difficulties[difficulty];

            // Check for mini-boss spawn (levels 3, 7, 13, etc - primes)
            if ([3, 7, 11, 13, 17, 19, 23].includes(level) && !miniBoss && enemies.length === 0 && Math.random() < 0.3) {
                spawnMiniBoss();
                return;
            }

            // Chance to spawn formation
            if (level >= 3 && Math.random() < 0.15) {
                const formTypes = Object.keys(formations);
                const formType = formTypes[Math.floor(Math.random() * formTypes.length)];
                spawnFormation(formType, 'fighter');
                return;
            }

            // Regular enemy types + new enemies based on level
            const baseTypes = ['fighter', 'bomber', 'jet', 'helicopter', 'turret', 'drone'];
            const newTypes = ['kamikaze', 'blinker', 'shielder', 'miner', 'scout'];

            let available = baseTypes.slice(0, Math.min(baseTypes.length, 2 + Math.floor(level / 2)));

            // Add new enemy types progressively
            if (level >= 2) available.push('kamikaze');
            if (level >= 4) available.push('blinker');
            if (level >= 6) available.push('shielder');
            if (level >= 8) available.push('miner');
            if (level >= 10) available.push('scout');

            const type = available[Math.floor(Math.random() * available.length)];
            const enemy = createEnemy(type);
            enemy.startY = enemy.y;
            enemies.push(enemy);
        }

        function spawnMiniBoss() {
            const mbType = miniBossTypes[Math.floor(Math.random() * miniBossTypes.length)];
            playSound('boss');
            floatingTexts.push({
                x: canvas.width / 2, y: 150,
                text: 'âš  ' + mbType.name + ' âš ', color: '#f80', life: 120, size: 16
            });

            miniBoss = {
                x: canvas.width + 50,
                y: canvas.height / 2 - mbType.height / 2,
                width: mbType.width,
                height: mbType.height,
                speed: 2,
                health: mbType.health + level * 5,
                maxHealth: mbType.health + level * 5,
                name: mbType.name,
                type: mbType.name,
                color: mbType.color,
                bullets: [],
                lastShot: 0,
                shootCooldown: 40,
                escort: mbType.escort || 0,
                bombRate: mbType.bombRate || 0,
                cloakDuration: mbType.cloakDuration || 0,
                cloaked: false,
                cloakTimer: 0,
                escortSpawned: false
            };

            // Spawn escort for Strike Leader
            if (miniBoss.escort > 0) {
                for (let i = 0; i < miniBoss.escort; i++) {
                    setTimeout(() => {
                        if (miniBoss) {
                            const escort = createEnemy('fighter', canvas.width + 80, miniBoss.y + (i - 1) * 50);
                            escort.isEscort = true;
                            enemies.push(escort);
                        }
                    }, 500 + i * 300);
                }
            }
        }

        function spawnMine(x, y) {
            mines.push({
                x, y,
                radius: 12,
                timer: 300, // 5 seconds
                pulse: 0,
                armed: false
            });
        }

        const bossTypes = [
            { name: 'MEGA BOMBER', color: '#2a4a2a', width: 220, height: 160, healthMult: 1, specialAttack: 'carpet_bomb' },
            { name: 'CYBER FORTRESS', color: '#2a2a4a', width: 250, height: 180, healthMult: 1.5, specialAttack: 'laser_sweep' },
            { name: 'DEATH MACHINE', color: '#4a2a2a', width: 200, height: 200, healthMult: 2, specialAttack: 'transform' }
        ];

        // Boss music settings per phase
        let bossMusicBPM = 120;
        let bossMusicPhase = 1;
        let bossMusicInterval = null;

        function startBossMusic(phase) {
            bossMusicPhase = phase;
            bossMusicBPM = phase === 1 ? 120 : phase === 2 ? 140 : 160;
            if (bossMusicInterval) clearInterval(bossMusicInterval);
            bossMusicInterval = setInterval(playBossMusicBeat, 60000 / bossMusicBPM / 4);
        }

        function stopBossMusic() {
            if (bossMusicInterval) {
                clearInterval(bossMusicInterval);
                bossMusicInterval = null;
            }
        }

        let bossMusicBeat = 0;
        function playBossMusicBeat() {
            if (!audioCtx || !boss) return;
            const now = audioCtx.currentTime;
            const phase = bossMusicPhase;

            // Kick drum on beats 0, 4, 8, 12
            if (bossMusicBeat % 4 === 0) {
                const kick = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kick.connect(kickGain);
                kickGain.connect(audioCtx.destination);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, now);
                kick.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                kickGain.gain.setValueAtTime(0.25, now);
                kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                kick.start(now);
                kick.stop(now + 0.1);
            }

            // Bass on every beat (phase 1+)
            if (bossMusicBeat % 2 === 0) {
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(audioCtx.destination);
                bass.type = 'sawtooth';
                const bassNotes = [55, 55, 65, 55, 55, 55, 73, 65];
                bass.frequency.setValueAtTime(bassNotes[Math.floor(bossMusicBeat/2) % 8], now);
                bassGain.gain.setValueAtTime(0.12, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                bass.start(now);
                bass.stop(now + 0.15);
            }

            // Hi-hat (phase 2+)
            if (phase >= 2 && bossMusicBeat % 2 === 1) {
                const hat = audioCtx.createOscillator();
                const hatGain = audioCtx.createGain();
                hat.connect(hatGain);
                hatGain.connect(audioCtx.destination);
                hat.type = 'square';
                hat.frequency.setValueAtTime(1000 + Math.random() * 500, now);
                hatGain.gain.setValueAtTime(0.04, now);
                hatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                hat.start(now);
                hat.stop(now + 0.02);
            }

            // Melody (phase 2+)
            if (phase >= 2 && bossMusicBeat % 4 === 0) {
                const mel = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();
                mel.connect(melGain);
                melGain.connect(audioCtx.destination);
                mel.type = 'square';
                const melodyNotes = [330, 392, 440, 392, 330, 294, 330, 392];
                mel.frequency.setValueAtTime(melodyNotes[Math.floor(bossMusicBeat/4) % 8], now);
                melGain.gain.setValueAtTime(0.06, now);
                melGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                mel.start(now);
                mel.stop(now + 0.1);
            }

            // Arpeggio (phase 3)
            if (phase === 3) {
                const arpNotes = [220, 277, 330, 440];
                const arp = audioCtx.createOscillator();
                const arpGain = audioCtx.createGain();
                arp.connect(arpGain);
                arpGain.connect(audioCtx.destination);
                arp.type = 'sine';
                arp.frequency.setValueAtTime(arpNotes[bossMusicBeat % 4], now);
                arpGain.gain.setValueAtTime(0.08, now);
                arpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                arp.start(now);
                arp.stop(now + 0.05);
            }

            // Tension notes (phase 3)
            if (phase === 3 && bossMusicBeat % 8 === 0) {
                const tension = audioCtx.createOscillator();
                const tensionGain = audioCtx.createGain();
                tension.connect(tensionGain);
                tensionGain.connect(audioCtx.destination);
                tension.type = 'sawtooth';
                tension.frequency.setValueAtTime(110, now);
                tension.frequency.linearRampToValueAtTime(220, now + 0.3);
                tensionGain.gain.setValueAtTime(0.1, now);
                tensionGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                tension.start(now);
                tension.stop(now + 0.3);
            }

            bossMusicBeat++;
        }

        function playPhaseTransition() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            // Drop effect - dramatic pause then hit
            [0, 200, 400].forEach((delay, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(110 * (i + 1), audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                }, delay);
            });
        }

        function spawnBoss() {
            playSound('boss');
            playVoice('BOSS INCOMING');
            bossWarning = 150;
            weather.lightning = 60;

            const bt = bossTypes[bossType % 3];
            const baseHealth = (100 + level * 30) * bt.healthMult;

            boss = {
                x: canvas.width + 100,
                y: canvas.height / 2 - bt.height/2,
                width: bt.width,
                height: bt.height,
                speed: 1,
                health: baseHealth,
                maxHealth: baseHealth,
                bullets: [],
                lastShot: Date.now(),
                // Enhanced turrets with individual health
                turrets: [
                    { x: 30, y: 30, lastShot: 0, health: 25, maxHealth: 25, alive: true },
                    { x: 30, y: bt.height - 30, lastShot: 0, health: 25, maxHealth: 25, alive: true },
                    { x: bt.width - 40, y: bt.height/2, lastShot: 0, health: 25, maxHealth: 25, alive: true }
                ],
                // Engines - weak points
                engines: [
                    { x: bt.width - 20, y: 20, health: 20, maxHealth: 20, destroyed: false },
                    { x: bt.width - 20, y: bt.height - 40, health: 20, maxHealth: 20, destroyed: false }
                ],
                // Core - exposed when 2+ turrets destroyed
                core: { x: bt.width/2 - 25, y: bt.height/2 - 25, width: 50, height: 50, exposed: false },
                // Phase system (1, 2, 3)
                currentPhase: 1,
                phase: 0, // attack pattern phase
                phaseTimer: 0,
                lastPhaseChange: 0,
                type: bossType % 3,
                name: bt.name,
                color: bt.color,
                specialAttack: bt.specialAttack,
                enraged: false,
                specialAttackTimer: 0,
                transformState: 0 // for Death Machine
            };

            bossType++;
            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').style.display = 'block';
            document.getElementById('bossName').textContent = `â˜… ${bt.name} Mk.${Math.ceil(level/5)} â˜…`;

            // Start phase 1 music
            startBossMusic(1);
        }

        function updateBossPhase() {
            if (!boss) return;
            const healthPercent = boss.health / boss.maxHealth;
            let newPhase = boss.currentPhase;

            if (healthPercent > 0.66) newPhase = 1;
            else if (healthPercent > 0.33) newPhase = 2;
            else newPhase = 3;

            if (newPhase !== boss.currentPhase) {
                boss.currentPhase = newPhase;
                boss.lastPhaseChange = frame;
                playPhaseTransition();
                startBossMusic(newPhase);
                screenShake = 20;

                // Phase transition effects
                const phaseName = newPhase === 2 ? 'PHASE 2: AGGRESSION!' : 'PHASE 3: BERSERK!';
                floatingTexts.push({
                    x: boss.x + boss.width/2, y: boss.y - 50,
                    text: phaseName, color: newPhase === 3 ? '#f00' : '#ff0', life: 120, size: 18
                });

                // Drop loot on phase change
                if (newPhase === 2) {
                    dropBossLoot(boss.x + boss.width/2, boss.y + boss.height/2, 'life');
                } else if (newPhase === 3) {
                    dropBossLoot(boss.x + boss.width/2, boss.y + boss.height/2, 'bomb');
                    boss.enraged = true;
                }

                playVoice(newPhase === 2 ? 'UNSTOPPABLE' : 'GODLIKE');
            }

            // Check if core should be exposed
            const aliveTurrets = boss.turrets.filter(t => t.alive).length;
            boss.core.exposed = aliveTurrets <= 1;
        }

        function dropBossLoot(x, y, type) {
            const colors = { life: '#f0f', bomb: '#f80', rocket: '#fa0', rapid: '#ff0', spread: '#00f', shield: '#0f0' };
            powerups.push({
                x, y,
                type: type || ['rapid', 'spread', 'shield', 'rocket'][Math.floor(Math.random() * 4)],
                color: colors[type] || '#ff0',
                width: 28, height: 28, vy: -3, pulse: 0,
                fromBoss: true
            });

            // Sparkle effect
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 40,
                    color: '#ff0',
                    size: 4
                });
            }
        }

        function hitBossComponent(bullet) {
            if (!boss) return false;
            const b = boss;
            const bx = bullet.x, by = bullet.y;
            const damage = bullet.damage || 1;
            let hit = false;

            // Check turrets
            for (let t of b.turrets) {
                if (!t.alive) continue;
                const tx = b.x + t.x, ty = b.y + t.y;
                if (Math.hypot(bx - tx, by - ty) < 20) {
                    t.health -= damage;
                    hit = true;
                    if (t.health <= 0) {
                        t.alive = false;
                        createExplosion(tx, ty, true);
                        floatingTexts.push({ x: tx, y: ty - 20, text: 'TURRET DOWN!', color: '#0ff', life: 60, size: 12 });
                        score += 500;
                        playSound('megaExplosion');
                        if (Math.random() < 0.4) dropBossLoot(tx, ty);
                    }
                    break;
                }
            }

            // Check engines (2x damage)
            if (!hit) {
                for (let e of b.engines) {
                    if (e.destroyed) continue;
                    const ex = b.x + e.x, ey = b.y + e.y;
                    if (Math.abs(bx - ex) < 25 && Math.abs(by - ey) < 25) {
                        e.health -= damage * 2;
                        b.health -= damage; // Also damages main health
                        hit = true;
                        if (e.health <= 0) {
                            e.destroyed = true;
                            createExplosion(ex, ey, true);
                            b.speed *= 0.7; // Slow down boss
                            floatingTexts.push({ x: ex, y: ey - 20, text: 'ENGINE HIT!', color: '#f80', life: 60, size: 12 });
                            score += 300;
                            dropBossLoot(ex, ey, 'rocket');
                        }
                        break;
                    }
                }
            }

            // Check core (3x damage when exposed)
            if (!hit && b.core.exposed) {
                const cx = b.x + b.core.x + b.core.width/2;
                const cy = b.y + b.core.y + b.core.height/2;
                if (Math.abs(bx - cx) < b.core.width/2 + 10 && Math.abs(by - cy) < b.core.height/2 + 10) {
                    b.health -= damage * 3;
                    hit = true;
                    floatingTexts.push({ x: cx, y: cy - 30, text: 'CRITICAL!', color: '#f00', life: 30, size: 14 });
                }
            }

            // Normal hit on body
            if (!hit) {
                if (bx > b.x && bx < b.x + b.width && by > b.y && by < b.y + b.height) {
                    b.health -= damage;
                    hit = true;
                }
            }

            return hit;
        }

        function bossSpecialAttack() {
            if (!boss || boss.currentPhase < 3) return;
            const b = boss;

            if (b.specialAttack === 'carpet_bomb') {
                // Mega Bomber: rain of bombs from above
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        if (!boss) return;
                        const bx = 100 + Math.random() * (canvas.width - 200);
                        b.bullets.push({
                            x: bx, y: -20,
                            width: 16, height: 16,
                            speed: 4 + Math.random() * 2,
                            angle: Math.PI / 2,
                            isBomb: true
                        });
                    }, i * 150);
                }
            } else if (b.specialAttack === 'laser_sweep') {
                // Cyber Fortress: horizontal laser sweep
                b.laserSweep = { active: true, y: b.y + 30, direction: 1, timer: 60 };
            } else if (b.specialAttack === 'transform') {
                // Death Machine: transformation
                b.transformState = (b.transformState + 1) % 3;
                floatingTexts.push({
                    x: b.x + b.width/2, y: b.y - 30,
                    text: 'TRANSFORM!', color: '#f0f', life: 60, size: 16
                });
                screenShake = 15;
                // Change attack pattern
                if (b.transformState === 1) {
                    // Rapid fire mode
                    b.turrets.forEach(t => { if (t.alive) t.fireRate = 0.5; });
                } else if (b.transformState === 2) {
                    // Spiral attack
                    for (let i = 0; i < 16; i++) {
                        setTimeout(() => {
                            if (!boss) return;
                            const angle = (i / 16) * Math.PI * 2;
                            b.bullets.push({
                                x: b.x + b.width/2, y: b.y + b.height/2,
                                width: 10, height: 10, speed: 4, angle
                            });
                        }, i * 50);
                    }
                }
            }
        }

        // ============ DRAWING ============
        function drawNeonGlow(x, y, w, h, color, intensity = 1) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * intensity;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 2, y - 2, w + 4, h + 4);
            ctx.shadowBlur = 0;
        }

        function drawPixelPlane(x, y, w, h, type, damaged = false, glowColor = '#fff', enemy = null) {
            const colors = {
                fighter: { body: '#4a7dc4', dark: '#2d5a9e', cockpit: '#adf', accent: '#f44' },
                bomber: { body: '#5a7e23', dark: '#3a5e12', cockpit: '#adf', accent: '#fa0' },
                jet: { body: '#9b1010', dark: '#6b0000', cockpit: '#adf', accent: '#f60' },
                helicopter: { body: '#c55', dark: '#933', cockpit: '#adf', accent: '#ff0' },
                turret: { body: '#666', dark: '#444', cockpit: '#f00', accent: '#ff0' },
                drone: { body: '#808', dark: '#606', cockpit: '#f0f', accent: '#0ff' },
                // NEW ENEMY COLORS
                kamikaze: { body: '#c22', dark: '#811', cockpit: '#f88', accent: '#ff0' },
                blinker: { body: '#2cc', dark: '#1aa', cockpit: '#8ff', accent: '#fff' },
                shielder: { body: '#22c', dark: '#119', cockpit: '#88f', accent: '#0ff' },
                miner: { body: '#2a2', dark: '#181', cockpit: '#8f8', accent: '#ff0' },
                scout: { body: '#cc2', dark: '#991', cockpit: '#ff8', accent: '#fff' }
            };
            const c = colors[type] || colors.fighter;

            ctx.save();
            if (damaged && frame % 4 < 2) ctx.globalAlpha = 0.5;

            // Neon glow
            if (combo >= 10) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 10;
            }

            if (type === 'turret') {
                ctx.fillStyle = c.dark;
                ctx.fillRect(x, y + h*0.5, w, h*0.5);
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.25, y, w*0.5, h*0.6);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.35, y - h*0.3, w*0.3, h*0.4);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.4, y + h*0.15, w*0.2, h*0.15);
            } else if (type === 'helicopter') {
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.12, y + h*0.28, w*0.65, h*0.44);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.72, y + h*0.32, w*0.28, h*0.36);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.02, y + h*0.32, w*0.14, h*0.36);
                // Rotor animation
                ctx.fillStyle = '#888';
                if (frame % 3 === 0) {
                    ctx.fillRect(x - w*0.1, y + h*0.08, w*0.9, h*0.12);
                } else {
                    ctx.fillRect(x + w*0.1, y + h*0.08, w*0.5, h*0.12);
                }
            } else if (type === 'drone') {
                // Circular drone
                ctx.fillStyle = c.body;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = c.cockpit;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.2, 0, Math.PI * 2);
                ctx.fill();
                // Spinning blades
                ctx.fillStyle = '#888';
                const angle = frame * 0.3;
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.translate(x + w/2, y + h/2);
                    ctx.rotate(angle + i * Math.PI/2);
                    ctx.fillRect(-w*0.1, -h*0.5, w*0.2, h*0.3);
                    ctx.restore();
                }
            } else {
                // Standard planes
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.2, y + h*0.28, w*0.55, h*0.44);
                ctx.fillRect(x, y + h*0.32, w*0.25, h*0.36);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.7, y + h*0.18, w*0.3, h*0.64);
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.25, y - h*0.05, w*0.35, h*1.1);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.1, y + h*0.38, w*0.18, h*0.24);
                ctx.fillStyle = c.accent;
                if (frame % 6 < 3) {
                    ctx.fillRect(x + w*0.92, y + h*0.38, w*0.15, h*0.24);
                }
            }

            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            const b = boss;
            const bt = bossTypes[b.type];

            ctx.save();

            // Phase-based visual effects
            if (b.currentPhase === 3) {
                // Berserk glow - intense pulsing
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 40 + Math.sin(frame * 0.3) * 20;
            } else if (b.currentPhase === 2) {
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 20 + Math.sin(frame * 0.15) * 10;
            }

            // Main body with neon outline
            ctx.fillStyle = bt.color;
            ctx.fillRect(b.x + 20, b.y + 30, b.width - 40, b.height - 60);

            // Phase-colored outline
            const phaseColors = ['#0ff', '#ff0', '#f00'];
            ctx.strokeStyle = phaseColors[b.currentPhase - 1];
            ctx.lineWidth = b.currentPhase === 3 ? 4 : 2;
            ctx.strokeRect(b.x + 20, b.y + 30, b.width - 40, b.height - 60);

            // Wings
            ctx.fillStyle = b.type === 1 ? '#1a1a3a' : b.type === 2 ? '#3a1a1a' : '#1a3a1a';
            ctx.fillRect(b.x + 50, b.y, b.width - 100, b.height);

            // Cockpit
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 10;
            ctx.fillRect(b.x + 15, b.y + b.height/2 - 20, 35, 40);
            ctx.shadowBlur = 0;

            // Draw engines (weak points)
            b.engines.forEach((eng, i) => {
                const ex = b.x + eng.x;
                const ey = b.y + eng.y;

                if (eng.destroyed) {
                    // Destroyed engine - smoke and fire
                    ctx.fillStyle = '#222';
                    ctx.fillRect(ex - 15, ey, 30, 20);
                    if (frame % 4 === 0) {
                        particles.push({
                            x: ex, y: ey + 10,
                            vx: 2 + Math.random(), vy: -1 - Math.random(),
                            life: 30, color: '#333', size: 8
                        });
                    }
                } else {
                    // Active engine with weak point indicator
                    ctx.fillStyle = '#444';
                    ctx.fillRect(ex - 15, ey, 30, 20);

                    // Pulsing weak point indicator
                    const pulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 150, 0, ${pulse})`;
                    ctx.shadowColor = '#f80';
                    ctx.shadowBlur = 10;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(ex - 18, ey - 3, 36, 26);
                    ctx.shadowBlur = 0;

                    // Flame
                    const flameLen = 15 + Math.random() * 25;
                    const gradient = ctx.createLinearGradient(ex + 15, ey, ex + 15 + flameLen, ey);
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(0.3, '#ff0');
                    gradient.addColorStop(0.6, '#f80');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(ex + 15, ey + 3, flameLen, 14);

                    // Engine health bar
                    const healthPct = eng.health / eng.maxHealth;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(ex - 15, ey - 8, 30, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(ex - 15, ey - 8, 30 * healthPct, 4);
                }
            });

            // Draw core (when exposed)
            if (b.core.exposed) {
                const cx = b.x + b.core.x;
                const cy = b.y + b.core.y;

                // Pulsing critical weak point
                const corePulse = Math.sin(frame * 0.2) * 0.4 + 0.6;
                ctx.fillStyle = `rgba(255, 0, 0, ${corePulse * 0.5})`;
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;
                ctx.fillRect(cx, cy, b.core.width, b.core.height);

                // Core border
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.strokeRect(cx, cy, b.core.width, b.core.height);

                // "WEAK POINT" indicator
                ctx.fillStyle = '#f00';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('WEAK', cx + b.core.width/2, cy - 5);
                ctx.shadowBlur = 0;
            }

            // Draw turrets (with individual health)
            b.turrets.forEach(t => {
                const tx = b.x + t.x;
                const ty = b.y + t.y;

                if (!t.alive) {
                    // Destroyed turret - wreckage
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 12, 0, Math.PI * 2);
                    ctx.fill();
                    // Smoke
                    if (frame % 8 === 0) {
                        particles.push({
                            x: tx, y: ty, vx: Math.random() - 0.5, vy: -2,
                            life: 25, color: '#444', size: 6
                        });
                    }
                } else {
                    // Active turret
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 18, 0, Math.PI * 2);
                    ctx.fill();

                    // Turret glow based on phase
                    const turretColor = b.currentPhase === 3 ? '#f00' : b.currentPhase === 2 ? '#f80' : '#f0f';
                    ctx.fillStyle = turretColor;
                    ctx.shadowColor = turretColor;
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(tx, ty, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Turret health bar
                    const healthPct = t.health / t.maxHealth;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(tx - 15, ty - 25, 30, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(tx - 15, ty - 25, 30 * healthPct, 4);
                }
            });

            // Phase 2+ damage smoke
            if (b.currentPhase >= 2) {
                if (frame % 4 === 0) {
                    particles.push({
                        x: b.x + Math.random() * b.width,
                        y: b.y + Math.random() * b.height,
                        vx: -2 + Math.random(), vy: -3 - Math.random() * 2,
                        life: 50, color: '#333', size: 12 + Math.random() * 8
                    });
                }
            }

            // Phase 3 fire effects
            if (b.currentPhase === 3) {
                if (frame % 2 === 0) {
                    particles.push({
                        x: b.x + 30 + Math.random() * (b.width - 60),
                        y: b.y + Math.random() * b.height,
                        vx: Math.random() - 0.5, vy: -3,
                        life: 25,
                        color: ['#f00', '#f80', '#ff0'][Math.floor(Math.random() * 3)],
                        size: 10 + Math.random() * 8
                    });
                }
            }

            // Laser sweep (Cyber Fortress special)
            if (b.laserSweep && b.laserSweep.active) {
                ctx.strokeStyle = '#f00';
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(b.x + 30, b.laserSweep.y);
                ctx.lineTo(0, b.laserSweep.y);
                ctx.stroke();

                // Warning line
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.lineWidth = 20;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.restore();

            // Update phase indicator in health bar
            const phaseText = `PHASE ${b.currentPhase}`;
            document.getElementById('bossName').textContent = `â˜… ${b.name} - ${phaseText} â˜…`;

            // Health bar update with phase colors
            const healthPercent = b.health / b.maxHealth * 100;
            const hpBar = document.getElementById('bossHealthBar');
            hpBar.style.width = healthPercent + '%';
            hpBar.style.background = b.currentPhase === 3 ? 'linear-gradient(90deg, #f00, #ff0, #f00)' :
                                     b.currentPhase === 2 ? 'linear-gradient(90deg, #f80, #ff0, #f80)' :
                                     'linear-gradient(90deg, #0f0, #ff0, #0f0)';
        }

        function createExplosion(x, y, large = false) {
            explosions.push({ x, y, frame: 0, maxFrames: 12, size: large ? 128 : 64 });
            playSound(large ? 'megaExplosion' : 'explosion');
            if (large) {
                screenShake = Math.max(screenShake, 15);
                shockwaves.push({ x, y, radius: 0, maxRadius: 150, speed: 8, color: '#f80' });
            }

            const count = large ? 35 : 15;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * (large ? 18 : 12),
                    vy: (Math.random() - 0.5) * (large ? 18 : 12),
                    life: 50 + Math.random() * 40,
                    color: ['#ff0', '#f80', '#f00', '#fff', '#f0f'][Math.floor(Math.random() * 5)],
                    size: Math.random() * 8 + 3
                });
            }
        }

        function addCombo() {
            combo++;
            comboTimer = 180;
            killStreak++;
            killStreakTimer = 60;

            // Slow motion trigger
            if (killStreak >= 5) {
                triggerSlowMotion();
                killStreak = 0;
            }

            if (combo >= 20) {
                comboMultiplier = 8;
                if (combo === 20) { playVoice('GODLIKE'); }
            } else if (combo >= 10) {
                comboMultiplier = 4;
                if (combo === 10) { playVoice('UNSTOPPABLE'); }
            } else if (combo >= 5) {
                comboMultiplier = 2;
                if (combo === 5) { playVoice('COMBO'); playSound('combo'); }
            } else {
                comboMultiplier = 1;
            }

            if (combo % 5 === 0 && combo > 0) {
                floatingTexts.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2 - 50,
                    text: combo >= 20 ? 'â˜… GODLIKE! â˜…' : combo >= 10 ? 'UNSTOPPABLE!' : 'x' + comboMultiplier + ' COMBO!',
                    color: combo >= 20 ? '#ff0' : '#f0f',
                    life: 80,
                    size: combo >= 20 ? 28 : 20
                });
            }
            updateUI();
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x &&
                   a.y < b.y + b.height && a.y + a.height > b.y;
        }

        // ============ UPDATE ============
        function update() {
            frame++;
            if (voiceCooldown > 0) voiceCooldown--;

            // Slow motion handling
            if (slowMotion > 0) {
                slowMotion--;
                slowMotionFactor = 0.3 + (1 - slowMotion/90) * 0.7;
            } else {
                slowMotionFactor = 1;
            }

            // Kill streak timer
            if (killStreakTimer > 0) {
                killStreakTimer--;
                if (killStreakTimer === 0) killStreak = 0;
            }

            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                    comboMultiplier = 1;
                    updateUI();
                }
            }

            // Power-up timers
            Object.keys(activePowerups).forEach(k => {
                if (activePowerups[k] > 0) {
                    activePowerups[k]--;
                    if (activePowerups[k] === 0) {
                        if (k === 'rapid') player.shootCooldown = 180;
                        updateUI();
                    }
                }
            });

            // Screen shake decay
            if (screenShake > 0) screenShake *= 0.9;

            // Laser charge regen
            if (!laserActive && laserCharge < 100) {
                laserCharge += 0.1;
            }

            // Weather
            if (weather.lightning > 0) weather.lightning--;
            if (weather.thunderTimer > 0) {
                weather.thunderTimer--;
                if (weather.thunderTimer === 0) playSound('thunder');
            }

            // Random lightning in hard modes
            if ((difficulty === 'hard' || difficulty === 'legendary') && Math.random() < 0.002) {
                weather.lightning = 10;
                weather.thunderTimer = 20;
            }

            // Player animation
            if (frame % 3 === 0) player.animFrame = (player.animFrame + 1) % 8;

            // Movement
            let dx = 0, dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
            if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
            if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

            if (touchJoystick.active) {
                dx = touchJoystick.dx;
                dy = touchJoystick.dy;
            }

            const speedMod = slowMotionFactor;
            player.x += dx * player.speed * speedMod;
            player.y += dy * player.speed * speedMod;
            player.tilt = dy * 6;

            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(70, Math.min(canvas.height - player.height - 100, player.y));

            if (player.invincible > 0) player.invincible--;

            // Shooting
            const shooting = keys['Space'] || touchFire;
            const cooldownMod = 1 - perks.fireRate * 0.15;
            if (shooting && Date.now() - player.lastShot > player.shootCooldown * cooldownMod) {
                const bulletY = player.y + player.height / 2 - 3;
                const damage = 1 + perks.damage * 0.25;

                if (currentWeapon === 'laser') {
                    // Laser weapon - activate laser beam
                    if (laserCharge >= 10 && !laserActive) {
                        laserActive = true;
                        playSound('laser');
                    }
                    player.lastShot = Date.now();
                } else if (currentWeapon === 'rocket') {
                    // Rocket weapon - fire homing rockets
                    if (rocketAmmo > 0) {
                        fireRocket();
                        player.lastShot = Date.now();
                    }
                } else if (activePowerups.spread > 0 || currentWeapon === 'spread') {
                    // Spread weapon
                    for (let i = -2; i <= 2; i++) {
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY + i * 12,
                            width: 18, height: 5, speed: 14, vy: i * 1.5, damage
                        });
                    }
                    player.lastShot = Date.now();
                    playSound('shoot');
                } else {
                    // Normal weapon
                    player.bullets.push({
                        x: player.x + player.width, y: bulletY,
                        width: 20, height: 6, speed: 14, vy: 0, damage
                    });
                    // Double shot at high combo
                    if (combo >= 15) {
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY - 15,
                            width: 20, height: 6, speed: 14, vy: -1, damage
                        });
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY + 15,
                            width: 20, height: 6, speed: 14, vy: 1, damage
                        });
                    }
                    player.lastShot = Date.now();
                    playSound('shoot');
                }
            }

            // Laser weapon
            if (laserActive) {
                laserCharge -= 1.5;
                if (laserCharge <= 0) {
                    laserActive = false;
                    laserCharge = 0;
                }
                updateUI();

                // Laser damage to enemies
                const laserY = player.y + player.height / 2;
                const laserDamage = 0.5 + perks.damage * 0.1;
                enemies.forEach(e => {
                    if (e.x > player.x && Math.abs((e.y + e.height/2) - laserY) < 30) {
                        e.health -= laserDamage;
                    }
                });
                if (boss && boss.x > player.x && Math.abs((boss.y + boss.height/2) - laserY) < 50) {
                    boss.health -= laserDamage * 0.5;
                }
            }

            // Update bullets
            player.bullets = player.bullets.filter(b => {
                b.x += b.speed * speedMod;
                b.y += (b.vy || 0) * speedMod;

                // Check mine collision
                for (let i = mines.length - 1; i >= 0; i--) {
                    const m = mines[i];
                    if (Math.hypot(b.x - m.x, b.y - m.y) < m.radius + 5) {
                        createExplosion(m.x, m.y, true);
                        mines.splice(i, 1);
                        score += 50;
                        return false;
                    }
                }

                return b.x < canvas.width + 20 && b.y > -20 && b.y < canvas.height + 20;
            });

            // Update rockets (homing)
            player.rockets = player.rockets.filter(r => {
                // Trail
                r.trail.push({ x: r.x, y: r.y, life: 20 });
                r.trail = r.trail.filter(t => { t.life--; return t.life > 0; });

                // Homing
                if (r.target && (r.target.health > 0 || r.target === boss)) {
                    const tx = r.target.x + r.target.width/2;
                    const ty = r.target.y + r.target.height/2;
                    const angle = Math.atan2(ty - r.y, tx - r.x);
                    r.angle += (angle - r.angle) * 0.1;
                }

                r.x += Math.cos(r.angle) * r.speed * speedMod;
                r.y += Math.sin(r.angle) * r.speed * speedMod;

                // Hit enemies
                for (let e of enemies) {
                    if (checkCollision(r, e)) {
                        e.health -= 3;
                        createExplosion(r.x, r.y, false);
                        return false;
                    }
                }
                // Hit boss
                if (boss && checkCollision(r, boss)) {
                    boss.health -= 5;
                    createExplosion(r.x, r.y, false);
                    return false;
                }
                // Hit mini-boss
                if (miniBoss && !miniBoss.cloaked && checkCollision(r, miniBoss)) {
                    miniBoss.health -= 5;
                    createExplosion(r.x, r.y, false);
                    return false;
                }
                // Hit mines
                for (let i = mines.length - 1; i >= 0; i--) {
                    const m = mines[i];
                    if (Math.hypot(r.x - m.x, r.y - m.y) < m.radius + 10) {
                        createExplosion(m.x, m.y, true);
                        mines.splice(i, 1);
                        score += 50;
                        return false;
                    }
                }

                return r.x > -20 && r.x < canvas.width + 50 && r.y > -50 && r.y < canvas.height + 50;
            });

            // Boss warning
            if (bossWarning > 0) bossWarning--;

            // Check for boss level
            const cfg = difficulties[difficulty];
            if (!cfg.bossRush && level % 5 === 0 && !boss && enemies.length === 0 && bossWarning === 0) {
                spawnBoss();
            }

            // Spawn enemies
            if (!boss && Date.now() - lastEnemySpawn > enemySpawnRate) {
                spawnEnemy();
                lastEnemySpawn = Date.now();
            }

            // Update boss
            if (boss) {
                const b = boss;

                // Update boss phase system
                updateBossPhase();

                // Move to position
                if (b.x > canvas.width - b.width - 60) {
                    b.x -= b.speed * 2 * speedMod;
                } else {
                    b.phaseTimer++;
                    if (b.phaseTimer > 250) {
                        b.phase = (b.phase + 1) % 3;
                        b.phaseTimer = 0;
                    }

                    // Movement patterns based on boss type AND current phase
                    const phaseSpeedMult = b.currentPhase === 3 ? 1.5 : b.currentPhase === 2 ? 1.2 : 1;
                    const moveSpeed = b.speed * 2 * phaseSpeedMult * speedMod;

                    if (b.type === 0) { // Mega Bomber - sine wave, faster in later phases
                        b.y += Math.sin(frame * (0.02 * phaseSpeedMult)) * moveSpeed;
                    } else if (b.type === 1) { // Cyber Fortress - tracking, more aggressive
                        const trackSpeed = b.currentPhase === 3 ? 0.04 : b.currentPhase === 2 ? 0.03 : 0.02;
                        b.y += (player.y - b.y - b.height/2 + player.height/2) * trackSpeed * speedMod;
                    } else { // Death Machine - aggressive patterns
                        if (b.currentPhase === 3) {
                            // Erratic movement in phase 3
                            b.y += Math.sin(frame * 0.05) * moveSpeed * 2;
                            b.y += Math.cos(frame * 0.03) * moveSpeed;
                        } else if (b.currentPhase === 2) {
                            b.y += (player.y - b.y - b.height/2) * 0.035 * speedMod;
                        } else {
                            b.y += Math.sin(frame * 0.03) * moveSpeed;
                        }
                    }

                    b.y = Math.max(40, Math.min(canvas.height - b.height - 90, b.y));

                    // Turret shooting (only alive turrets)
                    const baseInterval = b.currentPhase === 3 ? 20 : b.currentPhase === 2 ? 35 : 50;
                    b.turrets.forEach(t => {
                        if (!t.alive) return;
                        const interval = t.fireRate ? baseInterval * t.fireRate : baseInterval;
                        if (frame - t.lastShot > interval) {
                            const angle = Math.atan2(player.y + player.height/2 - (b.y + t.y), player.x - (b.x + t.x));
                            const bulletSpeed = b.currentPhase === 3 ? 8 : b.currentPhase === 2 ? 6 : 5;
                            b.bullets.push({
                                x: b.x + t.x, y: b.y + t.y,
                                width: 12, height: 12, speed: bulletSpeed, angle
                            });

                            // Extra bullets in phase 2+
                            if (b.currentPhase >= 2) {
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 10, height: 10, speed: bulletSpeed - 1, angle: angle + 0.15 });
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 10, height: 10, speed: bulletSpeed - 1, angle: angle - 0.15 });
                            }
                            // Even more in phase 3
                            if (b.currentPhase === 3 && b.type === 2) {
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 8, height: 8, speed: bulletSpeed, angle: angle + 0.3 });
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 8, height: 8, speed: bulletSpeed, angle: angle - 0.3 });
                            }
                            t.lastShot = frame;
                        }
                    });

                    // Special attacks (phase 3 only)
                    b.specialAttackTimer++;
                    if (b.currentPhase === 3 && b.specialAttackTimer > 180) {
                        bossSpecialAttack();
                        b.specialAttackTimer = 0;
                    }

                    // Laser sweep update (Cyber Fortress)
                    if (b.laserSweep && b.laserSweep.active) {
                        b.laserSweep.y += b.laserSweep.direction * 3;
                        b.laserSweep.timer--;

                        // Damage player if in laser path
                        if (player.invincible === 0 && activePowerups.shield === 0 &&
                            Math.abs(player.y + player.height/2 - b.laserSweep.y) < 15 &&
                            player.x < b.x + 30) {
                            lives--;
                            player.invincible = 90;
                            createExplosion(player.x + player.width/2, player.y + player.height/2);
                            updateUI();
                            if (lives <= 0) gameOver();
                        }

                        // Reverse or end
                        if (b.laserSweep.y < b.y + 30 || b.laserSweep.y > b.y + b.height - 30) {
                            b.laserSweep.direction *= -1;
                        }
                        if (b.laserSweep.timer <= 0) {
                            b.laserSweep.active = false;
                        }
                    }
                }

                // Update boss bullets
                b.bullets = b.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * speedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * speedMod;

                    // Bomb bullets explode on ground
                    if (bullet.isBomb && bullet.y > canvas.height - 100) {
                        createExplosion(bullet.x, bullet.y, true);
                        // Area damage to player
                        if (Math.abs(player.x - bullet.x) < 80 && player.invincible === 0 && activePowerups.shield === 0) {
                            lives--;
                            player.invincible = 90;
                            updateUI();
                            if (lives <= 0) gameOver();
                        }
                        return false;
                    }

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }

                    return bullet.x > -30 && bullet.x < canvas.width + 30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                });

                // Player bullets hitting boss components
                player.bullets = player.bullets.filter(bullet => {
                    if (hitBossComponent(bullet)) {
                        playSound('hit');
                        createExplosion(bullet.x, bullet.y, false);
                        updateBossPhase();

                        if (b.health <= 0) {
                            // EPIC BOSS DEFEAT
                            stopBossMusic();
                            const bossScore = 10000 * level;
                            score += bossScore;

                            // Multiple explosions
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    if (!boss) return;
                                    createExplosion(
                                        b.x + Math.random() * b.width,
                                        b.y + Math.random() * b.height,
                                        true
                                    );
                                }, i * 120);
                            }

                            screenShake = 60;
                            shockwaves.push({ x: b.x + b.width/2, y: b.y + b.height/2, radius: 0, maxRadius: 500, speed: 12, color: '#ff0' });
                            spawnDebris(b.x + b.width/2, b.y + b.height/2, 30);
                            playSound('megaExplosion');
                            triggerSlowMotion();
                            playVoice('GODLIKE');

                            floatingTexts.push({
                                x: b.x + b.width/2, y: b.y + b.height/2,
                                text: 'â˜… BOSS DESTROYED! +' + bossScore + ' â˜…',
                                color: '#ff0', life: 180, size: 28
                            });

                            setTimeout(() => {
                                boss = null;
                                document.getElementById('bossHealth').style.display = 'none';
                                document.getElementById('bossName').style.display = 'none';

                                level++;
                                enemySpawnRate = Math.max(500, enemySpawnRate - 120);
                                playSound('levelUp');
                                updateUI();

                                // Show upgrade screen every 5 levels
                                if (level % 5 === 1 && level > 1) {
                                    showUpgradeScreen();
                                }

                                // Boss rush mode: spawn next boss
                                if (cfg.bossRush) {
                                    setTimeout(() => spawnBoss(), 2000);
                                }
                            }, 1500);
                        }
                        return false;
                    }
                    return true;
                });
            }

            // Update mines
            mines = mines.filter(mine => {
                mine.timer--;
                mine.pulse = (mine.pulse + 0.1) % (Math.PI * 2);
                mine.armed = mine.timer < 270; // Armed after 0.5 sec

                // Check player collision
                if (mine.armed && player.invincible === 0 && activePowerups.shield === 0) {
                    const dist = Math.hypot(player.x + player.width/2 - mine.x, player.y + player.height/2 - mine.y);
                    if (dist < mine.radius + 20) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(mine.x, mine.y, true);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                }

                // Expire
                if (mine.timer <= 0) {
                    createExplosion(mine.x, mine.y, false);
                    return false;
                }

                return true;
            });

            // Update mini-boss
            if (miniBoss) {
                const mb = miniBoss;

                // Move into position
                if (mb.x > canvas.width - mb.width - 80) {
                    mb.x -= mb.speed * 2 * speedMod;
                } else {
                    // Movement
                    mb.y += Math.sin(frame * 0.03) * 2 * speedMod;
                    mb.y = Math.max(80, Math.min(canvas.height - mb.height - 100, mb.y));

                    // Stealth Hunter cloaking
                    if (mb.cloakDuration > 0) {
                        mb.cloakTimer++;
                        if (mb.cloakTimer > 120 && !mb.cloaked) {
                            mb.cloaked = true;
                            mb.cloakTimer = 0;
                        } else if (mb.cloaked && mb.cloakTimer > mb.cloakDuration) {
                            mb.cloaked = false;
                            mb.cloakTimer = 0;
                        }
                    }

                    // Shooting
                    if (frame - mb.lastShot > mb.shootCooldown && !mb.cloaked) {
                        const angle = Math.atan2(player.y + player.height/2 - (mb.y + mb.height/2), player.x - mb.x);

                        if (mb.bombRate > 0 && frame % mb.bombRate === 0) {
                            // Heavy Bomber drops bombs
                            mb.bullets.push({
                                x: mb.x + mb.width/2, y: mb.y + mb.height,
                                width: 14, height: 14, speed: 3, angle: Math.PI/2, isBomb: true
                            });
                        } else {
                            mb.bullets.push({
                                x: mb.x, y: mb.y + mb.height/2,
                                width: 10, height: 10, speed: 7, angle
                            });
                        }
                        mb.lastShot = frame;
                    }
                }

                // Update mini-boss bullets
                mb.bullets = mb.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * speedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * speedMod;

                    if (bullet.isBomb && bullet.y > canvas.height - 100) {
                        createExplosion(bullet.x, bullet.y, true);
                        if (Math.abs(player.x - bullet.x) < 60 && player.invincible === 0 && activePowerups.shield === 0) {
                            lives--; player.invincible = 90; updateUI();
                            if (lives <= 0) gameOver();
                        }
                        return false;
                    }

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--; player.invincible = 90;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                    return bullet.x > -30 && bullet.y < canvas.height + 30;
                });

                // Player bullets hitting mini-boss
                player.bullets = player.bullets.filter(bullet => {
                    if (!mb.cloaked && checkCollision(bullet, mb)) {
                        mb.health -= bullet.damage || 1;
                        playSound('hit');
                        createExplosion(bullet.x, bullet.y, false);

                        if (mb.health <= 0) {
                            const mbScore = 2000 * level;
                            score += mbScore;
                            screenShake = 25;
                            createExplosion(mb.x + mb.width/2, mb.y + mb.height/2, true);
                            spawnDebris(mb.x + mb.width/2, mb.y + mb.height/2, 10);
                            playSound('megaExplosion');
                            floatingTexts.push({
                                x: mb.x + mb.width/2, y: mb.y,
                                text: 'â˜… MINI-BOSS DOWN! +' + mbScore + ' â˜…',
                                color: '#f80', life: 100, size: 16
                            });
                            spawnPowerup(mb.x + mb.width/2, mb.y + mb.height/2);
                            miniBoss = null;
                            updateUI();
                        }
                        return false;
                    }
                    return true;
                });
            }

            // Update enemies
            enemies = enemies.filter(enemy => {
                // Base movement
                if (enemy.type === 'turret') {
                    enemy.x -= 1 * speedMod;
                } else if (enemy.type === 'kamikaze') {
                    // Chase player aggressively
                    const dx = player.x - enemy.x;
                    const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                    const dist = Math.hypot(dx, dy);
                    enemy.x += (dx / dist) * enemy.speed * speedMod * 0.7;
                    enemy.y += (dy / dist) * enemy.speed * speedMod;
                    // Trail effect
                    if (frame % 3 === 0) {
                        particles.push({
                            x: enemy.x + enemy.width, y: enemy.y + enemy.height/2,
                            vx: 2 + Math.random(), vy: (Math.random() - 0.5) * 2,
                            life: 20, color: '#f80', size: 6
                        });
                    }
                } else if (enemy.type === 'blinker') {
                    enemy.x -= enemy.speed * speedMod;
                    enemy.teleportTimer--;
                    // Teleport warning
                    if (enemy.teleportTimer < 30) {
                        enemy.teleportWarning = 30 - enemy.teleportTimer;
                    }
                    // Teleport!
                    if (enemy.teleportTimer <= 0) {
                        // Glitch effect at old position
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
                                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                                life: 20, color: '#0ff', size: 4
                            });
                        }
                        // New position
                        enemy.x = canvas.width - 100 - Math.random() * 200;
                        enemy.y = 100 + Math.random() * (canvas.height - 300);
                        enemy.teleportTimer = 150 + Math.random() * 60;
                        enemy.teleportWarning = 0;
                        // Shoot after teleport
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 8, height: 8, speed: 8, angle });
                    }
                } else if (enemy.type === 'scout') {
                    enemy.x -= enemy.speed * speedMod;
                    // Dodge bullets!
                    if (enemy.dodgeCooldown <= 0) {
                        for (let b of player.bullets) {
                            const dist = Math.hypot(b.x - enemy.x, b.y - (enemy.y + enemy.height/2));
                            if (dist < 80 && b.x < enemy.x) {
                                // Dodge up or down
                                enemy.y += (enemy.y > canvas.height/2 ? -60 : 60);
                                enemy.dodgeCooldown = 30;
                                // After image
                                enemy.afterImages.push({ x: enemy.x, y: enemy.y + (enemy.y > canvas.height/2 ? 60 : -60), alpha: 0.7 });
                                break;
                            }
                        }
                    } else {
                        enemy.dodgeCooldown--;
                    }
                    // Update after images
                    enemy.afterImages = enemy.afterImages.filter(ai => { ai.alpha -= 0.1; return ai.alpha > 0; });
                } else if (enemy.type === 'miner') {
                    enemy.x -= enemy.speed * speedMod;
                    enemy.mineTimer--;
                    if (enemy.mineTimer <= 0 && enemy.x < canvas.width - 50) {
                        spawnMine(enemy.x + enemy.width, enemy.y + enemy.height/2);
                        enemy.mineTimer = 90;
                    }
                } else if (enemy.type === 'shielder') {
                    enemy.x -= enemy.speed * speedMod;
                    enemy.y += Math.sin(frame * 0.02) * 1.5 * speedMod;
                } else {
                    enemy.x -= enemy.speed * speedMod;
                }

                // Standard movement patterns for basic enemies
                if (enemy.type === 'fighter') {
                    enemy.y = enemy.startY + Math.sin(frame * enemy.frequency) * enemy.amplitude;
                } else if (enemy.type === 'helicopter' || enemy.type === 'drone') {
                    enemy.y += (player.y - enemy.y) * 0.015 * speedMod;
                } else if (enemy.type === 'jet') {
                    enemy.y += Math.cos(frame * 0.05) * 3 * speedMod;
                }

                // Keep in bounds
                enemy.y = Math.max(70, Math.min(canvas.height - enemy.height - 90, enemy.y));

                // Enemy shooting (not for kamikaze, miner, scout)
                if (!['kamikaze', 'miner', 'scout'].includes(enemy.type)) {
                    if (Date.now() - enemy.lastShot > enemy.shootCooldown && enemy.x < canvas.width - 80) {
                        if (enemy.type === 'turret') {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemy.bullets.push({ x: enemy.x + enemy.width/2, y: enemy.y, width: 8, height: 8, speed: 7, angle });
                        } else if (enemy.type === 'bomber') {
                            for (let i = -1; i <= 1; i++) {
                                enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 10, height: 6, speed: 6, angle: Math.PI + i * 0.3 });
                            }
                        } else if (enemy.type === 'shielder') {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 12, height: 8, speed: 5, angle });
                        } else {
                            enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 10, height: 4, speed: 8, angle: Math.PI });
                        }
                        enemy.lastShot = Date.now();
                    }
                }

                // Update enemy bullets
                enemy.bullets = enemy.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * speedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * speedMod;

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                    return bullet.x > -30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                });

                // Collision with player (kamikaze explodes!)
                if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(enemy, player)) {
                    lives--;
                    player.invincible = 90;
                    const isKamikaze = enemy.type === 'kamikaze';
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, isKamikaze);
                    if (isKamikaze) {
                        screenShake = 20;
                        // Chain reaction - damage nearby enemies
                        enemies.forEach(e => {
                            if (e !== enemy && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 80) {
                                e.health -= 2;
                            }
                        });
                    }
                    updateUI();
                    if (lives <= 0) gameOver();
                    return false;
                }

                // Hit by player bullet
                for (let i = player.bullets.length - 1; i >= 0; i--) {
                    const bullet = player.bullets[i];

                    // Shielder: check if bullet hits from front (blocked by shield)
                    if (enemy.type === 'shielder' && enemy.shieldHP > 0) {
                        if (bullet.x > enemy.x - 10 && bullet.x < enemy.x + 20 && checkCollision(bullet, enemy)) {
                            // Hit shield
                            enemy.shieldHP -= bullet.damage || 1;
                            player.bullets.splice(i, 1);
                            playSound('hit');
                            // Shield spark effect
                            for (let j = 0; j < 5; j++) {
                                particles.push({
                                    x: enemy.x, y: enemy.y + enemy.height/2,
                                    vx: -3 - Math.random() * 3, vy: (Math.random() - 0.5) * 6,
                                    life: 15, color: '#0af', size: 4
                                });
                            }
                            if (enemy.shieldHP <= 0) {
                                floatingTexts.push({ x: enemy.x, y: enemy.y - 10, text: 'SHIELD DOWN!', color: '#0ff', life: 40, size: 10 });
                            }
                            continue;
                        }
                    }

                    if (checkCollision(bullet, enemy)) {
                        player.bullets.splice(i, 1);
                        enemy.health -= bullet.damage || 1;

                        if (enemy.health <= 0) {
                            const pts = enemy.points * comboMultiplier * (perks.doubleScore ? 2 : 1);
                            score += pts;
                            addCombo();
                            updateUI();
                            const isKamikaze = enemy.type === 'kamikaze';
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, true);
                            spawnDebris(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 3);

                            // Kamikaze chain reaction
                            if (isKamikaze) {
                                screenShake = 15;
                                enemies.forEach(e => {
                                    if (e !== enemy && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 80) {
                                        e.health -= 2;
                                        createExplosion(e.x + e.width/2, e.y + e.height/2, false);
                                    }
                                });
                            }

                            floatingTexts.push({
                                x: enemy.x + enemy.width/2, y: enemy.y,
                                text: '+' + pts, color: comboMultiplier > 1 ? '#f0f' : '#ff0',
                                life: 45, size: 12 + Math.min(combo, 10)
                            });

                            if (Math.random() < 0.18 + perks.magnet * 0.05) {
                                spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }

                            // Level up (non-boss levels)
                            if (score >= level * 4000 && level % 5 !== 0) {
                                level++;
                                enemySpawnRate = Math.max(500, enemySpawnRate - 100);
                                playSound('levelUp');
                                floatingTexts.push({
                                    x: canvas.width/2, y: canvas.height/2,
                                    text: 'â˜… LEVEL ' + level + ' â˜…', color: '#0ff', life: 100, size: 22
                                });
                                updateUI();
                            }

                            return false;
                        } else {
                            playSound('hit');
                            createExplosion(bullet.x, enemy.y + enemy.height/2, false);
                        }
                    }
                }

                return enemy.x > -120;
            });

            // Update powerups
            powerups = powerups.filter(p => {
                p.x -= 1.5 * speedMod;
                p.pulse = (p.pulse + 0.1) % (Math.PI * 2);

                // Magnet effect
                if (perks.magnet > 0) {
                    const dist = Math.hypot(player.x - p.x, player.y - p.y);
                    if (dist < 150 * perks.magnet) {
                        p.x += (player.x - p.x) * 0.05;
                        p.y += (player.y - p.y) * 0.05;
                    }
                }

                if (checkCollision(p, player)) {
                    collectPowerup(p);
                    return false;
                }
                return p.x > -40;
            });

            // Update shockwaves
            shockwaves = shockwaves.filter(s => {
                s.radius += s.speed * speedMod;
                return s.radius < s.maxRadius;
            });

            // Update debris
            debris = debris.filter(d => {
                d.x += d.vx * speedMod;
                d.y += d.vy * speedMod;
                d.vy += 0.3 * speedMod;
                d.rotation += d.rotSpeed * speedMod;
                d.life--;
                return d.life > 0 && d.y < canvas.height + 50;
            });

            // Update explosions
            explosions = explosions.filter(e => {
                e.frame += 0.5 * speedMod;
                return e.frame < e.maxFrames;
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx * speedMod;
                p.y += p.vy * speedMod;
                p.vy += 0.15 * speedMod;
                p.life -= speedMod;
                return p.life > 0;
            });

            // Update floating texts
            floatingTexts = floatingTexts.filter(t => {
                t.y -= 1.2 * speedMod;
                t.life -= speedMod;
                return t.life > 0;
            });

            // Background
            const bgSpeed = speedMod;
            stars.forEach(s => {
                s.x -= s.speed * bgSpeed;
                if (s.x < 0) { s.x = canvas.width; s.y = Math.random() * canvas.height * 0.6; }
            });
            clouds.forEach(c => {
                c.x -= c.speed * bgSpeed;
                if (c.x + c.width < 0) c.x = canvas.width + c.width;
            });
            mountains.forEach(m => {
                m.x -= 0.4 * bgSpeed;
                if (m.x + m.width < 0) m.x = canvas.width + 50;
            });
            trees.forEach(t => {
                t.x -= 2.5 * bgSpeed;
                if (t.x < -30) t.x = canvas.width + 30;
            });
            neonGrid.forEach(g => {
                g.offset = (g.offset + 2 * bgSpeed) % 50;
            });

            // Rain
            if (difficulty === 'hard' || difficulty === 'legendary' || boss) {
                weather.rain.forEach(r => {
                    r.x -= 2;
                    r.y += r.speed * speedMod;
                    if (r.y > canvas.height) {
                        r.y = -20;
                        r.x = Math.random() * canvas.width;
                    }
                    if (r.x < 0) r.x = canvas.width;
                });
            }
        }

        // ============ DRAW ============
        function draw() {
            ctx.save();

            // Screen shake
            if (screenShake > 0.5) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
            }

            // Sky gradient - cyberpunk style
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            if (slowMotion > 0) {
                skyGradient.addColorStop(0, '#100020');
                skyGradient.addColorStop(0.5, '#200040');
                skyGradient.addColorStop(1, '#100030');
            } else if (combo >= 20) {
                skyGradient.addColorStop(0, '#200000');
                skyGradient.addColorStop(0.5, '#300010');
                skyGradient.addColorStop(1, '#200005');
            } else {
                skyGradient.addColorStop(0, '#000015');
                skyGradient.addColorStop(0.3, '#000830');
                skyGradient.addColorStop(0.6, '#001045');
                skyGradient.addColorStop(1, '#001530');
            }
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Lightning flash
            if (weather.lightning > 0) {
                ctx.fillStyle = `rgba(200, 200, 255, ${weather.lightning / 60 * 0.5})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Stars with colors
            stars.forEach(s => {
                const twinkle = Math.sin((frame + s.twinkle) * 0.1) > 0;
                ctx.fillStyle = twinkle ? s.color : '#444';
                ctx.shadowColor = s.color;
                ctx.shadowBlur = twinkle ? 5 : 0;
                ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size);
            });
            ctx.shadowBlur = 0;

            // Clouds
            ctx.fillStyle = 'rgba(80, 100, 130, 0.12)';
            clouds.forEach(c => {
                ctx.beginPath();
                ctx.ellipse(c.x, c.y, c.width/2, 30, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Mountains with neon outline
            mountains.forEach(m => {
                ctx.fillStyle = '#080818';
                ctx.beginPath();
                ctx.moveTo(m.x, canvas.height - 80);
                ctx.lineTo(m.x + m.width/2, canvas.height - 80 - m.height);
                ctx.lineTo(m.x + m.width, canvas.height - 80);
                ctx.fill();

                // Neon peak
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(m.x + m.width/2 - 20, canvas.height - 60 - m.height);
                ctx.lineTo(m.x + m.width/2, canvas.height - 80 - m.height);
                ctx.lineTo(m.x + m.width/2 + 20, canvas.height - 60 - m.height);
                ctx.stroke();
            });

            // Ground
            ctx.fillStyle = '#0a1a0a';
            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);

            // Neon grid on ground
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            neonGrid.forEach((g, i) => {
                if (i < 5) {
                    ctx.beginPath();
                    ctx.moveTo(0, g.y);
                    ctx.lineTo(canvas.width, g.y);
                    ctx.stroke();
                }
            });
            // Vertical grid lines
            for (let x = -neonGrid[0].offset; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 80);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Neon ground line
            ctx.strokeStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            ctx.lineTo(canvas.width, canvas.height - 80);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Trees with glow
            ctx.fillStyle = '#0f2f0f';
            trees.forEach(t => {
                ctx.beginPath();
                ctx.moveTo(t.x, canvas.height - 80);
                ctx.lineTo(t.x + 12, canvas.height - 80 - t.height);
                ctx.lineTo(t.x + 24, canvas.height - 80);
                ctx.fill();
            });

            // Rain
            if (difficulty === 'hard' || difficulty === 'legendary' || boss) {
                ctx.strokeStyle = 'rgba(150, 180, 255, 0.4)';
                ctx.lineWidth = 1;
                weather.rain.forEach(r => {
                    ctx.beginPath();
                    ctx.moveTo(r.x, r.y);
                    ctx.lineTo(r.x - 3, r.y + r.length);
                    ctx.stroke();
                });
            }

            // Shockwaves
            shockwaves.forEach(s => {
                const alpha = 1 - s.radius / s.maxRadius;
                ctx.strokeStyle = s.color;
                ctx.globalAlpha = alpha * 0.8;
                ctx.lineWidth = 4;
                ctx.shadowColor = s.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Boss warning
            if (bossWarning > 0) {
                const flash = Math.sin(frame * 0.4) * 0.3 + 0.3;
                ctx.fillStyle = `rgba(255, 0, 50, ${flash})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#f00';
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;
                ctx.font = '28px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('âš  WARNING âš ', canvas.width/2, canvas.height/2 - 20);
                ctx.font = '14px "Press Start 2P"';
                ctx.fillText('BOSS APPROACHING', canvas.width/2, canvas.height/2 + 20);
                ctx.shadowBlur = 0;
            }

            // Debris
            debris.forEach(d => {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.rotation * Math.PI / 180);
                ctx.fillStyle = d.color;
                ctx.globalAlpha = d.life / 120;
                ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Explosions
            explosions.forEach(exp => {
                const fi = Math.floor(exp.frame);
                ctx.drawImage(sprites.explosion, fi * 96, 0, 96, 96, exp.x - exp.size/2, exp.y - exp.size/2, exp.size, exp.size);
            });

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = Math.min(1, p.life / 30);
                ctx.shadowColor = p.color;
                ctx.shadowBlur = p.size;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Powerups with pulse effect
            powerups.forEach(p => {
                const pulse = Math.sin(p.pulse) * 3;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15 + pulse * 2;
                ctx.fillRect(p.x - pulse, p.y - pulse, p.width + pulse*2, p.height + pulse*2);
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.fillRect(p.x + 6, p.y + 6, p.width - 12, p.height - 12);
                ctx.fillStyle = p.color;
                ctx.font = 'bold 12px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(p.type[0].toUpperCase(), p.x + p.width/2, p.y + p.height/2 + 5);
            });

            // Player
            if (player.invincible === 0 || frame % 6 < 3) {
                ctx.save();
                ctx.translate(player.x + player.width/2, player.y + player.height/2);
                ctx.rotate(player.tilt * Math.PI / 180);

                // Fire aura at high combo
                if (combo >= 15) {
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = ['#f00', '#f80', '#ff0'][i % 3];
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(
                            -20 + Math.random() * 10,
                            Math.random() * player.height - player.height/2,
                            10 + Math.random() * 10,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }

                // Shield effect
                if (activePowerups.shield > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(frame * 0.2) * 0.3})`;
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, player.width/2 + 15, player.height/2 + 15, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Neon glow on helicopter
                if (combo >= 10) {
                    ctx.shadowColor = combo >= 20 ? '#f00' : '#f0f';
                    ctx.shadowBlur = 20;
                }

                ctx.drawImage(sprites.helicopter, player.animFrame * 96, 0, 96, 48, -player.width/2, -player.height/2, player.width, player.height);
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // Laser beam
            if (laserActive) {
                const laserY = player.y + player.height / 2;

                // Glow
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;

                // Main beam
                const gradient = ctx.createLinearGradient(player.x + player.width, laserY - 15, player.x + player.width, laserY + 15);
                gradient.addColorStop(0, 'rgba(255,0,0,0)');
                gradient.addColorStop(0.3, 'rgba(255,100,100,0.8)');
                gradient.addColorStop(0.5, '#fff');
                gradient.addColorStop(0.7, 'rgba(255,100,100,0.8)');
                gradient.addColorStop(1, 'rgba(255,0,0,0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(player.x + player.width, laserY - 15, canvas.width, 30);

                // Core
                ctx.fillStyle = '#fff';
                ctx.fillRect(player.x + player.width, laserY - 3, canvas.width, 6);

                ctx.shadowBlur = 0;
            }

            // Player bullets with neon
            player.bullets.forEach(b => {
                const bulletColor = combo >= 20 ? '#f80' : combo >= 10 ? '#f0f' : activePowerups.spread > 0 ? '#0ff' : '#ff0';
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 8;
                ctx.fillRect(b.x, b.y, b.width, b.height);
                ctx.fillStyle = '#fff';
                ctx.fillRect(b.x + b.width - 8, b.y + 1, 8, b.height - 2);
            });
            ctx.shadowBlur = 0;

            // Rockets with trails
            player.rockets.forEach(r => {
                // Trail
                r.trail.forEach((t, i) => {
                    ctx.fillStyle = `rgba(255, 150, 50, ${t.life / 20 * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 4 - i * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Rocket
                ctx.save();
                ctx.translate(r.x, r.y);
                ctx.rotate(r.angle);
                ctx.fillStyle = '#f80';
                ctx.fillRect(-10, -4, 20, 8);
                ctx.fillStyle = '#f00';
                ctx.fillRect(-10, -3, 5, 6);
                ctx.restore();
            });

            // Enemies
            enemies.forEach(enemy => {
                drawPixelPlane(enemy.x, enemy.y, enemy.width, enemy.height, enemy.type, enemy.health < enemy.maxHealth, enemy.glowColor);

                // Health bar for multi-hit enemies
                if (enemy.maxHealth > 1) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
                }

                // Special visual effects for new enemy types
                if (enemy.type === 'kamikaze') {
                    // Flashing red warning glow
                    if (frame % 8 < 4) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                } else if (enemy.type === 'blinker' && enemy.teleportWarning > 0) {
                    // Glitch/teleport warning effect
                    const glitchIntensity = enemy.teleportWarning / 30;
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15 * glitchIntensity;
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (Math.random() - 0.5) * 10 * glitchIntensity;
                        const offsetY = (Math.random() - 0.5) * 10 * glitchIntensity;
                        ctx.strokeRect(enemy.x + offsetX, enemy.y + offsetY, enemy.width, enemy.height);
                    }
                    ctx.shadowBlur = 0;
                } else if (enemy.type === 'shielder' && enemy.shieldHP > 0) {
                    // Energy shield in front
                    const shieldPulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(0, 150, 255, ${shieldPulse})`;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#08f';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(enemy.x + 5, enemy.y + enemy.height/2, enemy.height * 0.6, -Math.PI/2, Math.PI/2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    // Shield HP indicator
                    ctx.fillStyle = '#08f';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText('â›Š' + enemy.shieldHP, enemy.x, enemy.y - 15);
                } else if (enemy.type === 'miner') {
                    // Green glow effect
                    ctx.shadowColor = '#0f0';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(enemy.x - 2, enemy.y - 2, enemy.width + 4, enemy.height + 4);
                    ctx.shadowBlur = 0;
                } else if (enemy.type === 'scout' && enemy.afterImages && enemy.afterImages.length > 0) {
                    // Draw afterimages
                    enemy.afterImages.forEach(img => {
                        ctx.globalAlpha = img.alpha || 0.3;
                        drawPixelPlane(img.x, img.y, enemy.width, enemy.height, 'scout', false, '#ff0');
                    });
                    ctx.globalAlpha = 1;
                }

                // Enemy bullets
                enemy.bullets.forEach(b => {
                    ctx.fillStyle = '#f44';
                    ctx.shadowColor = '#f44';
                    ctx.shadowBlur = 6;
                    ctx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
                });
            });
            ctx.shadowBlur = 0;

            // Boss
            drawBoss();
            if (boss) {
                boss.bullets.forEach(b => {
                    ctx.fillStyle = boss.enraged ? '#f00' : '#f0f';
                    ctx.shadowColor = boss.enraged ? '#f00' : '#f0f';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            // Mines
            mines.forEach(m => {
                const pulse = Math.sin(frame * 0.15 + m.x) * 0.3 + 0.7;
                ctx.save();

                // Mine body
                ctx.fillStyle = '#0a0';
                ctx.shadowColor = '#0f0';
                ctx.shadowBlur = 10 * pulse;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                ctx.fillStyle = `rgba(0, 255, 0, ${pulse * 0.5})`;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Spikes
                ctx.fillStyle = '#0f0';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + frame * 0.02;
                    const sx = m.x + Math.cos(angle) * (m.radius + 5);
                    const sy = m.y + Math.sin(angle) * (m.radius + 5);
                    ctx.beginPath();
                    ctx.arc(sx, sy, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Warning if player is close
                const distToPlayer = Math.hypot(player.x + player.width/2 - m.x, player.y + player.height/2 - m.y);
                if (distToPlayer < 100) {
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = (100 - distToPlayer) / 100;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            });

            // Mini-boss
            if (miniBoss) {
                const mb = miniBoss;
                ctx.save();

                // Cloaking effect
                if (mb.cloaked) {
                    ctx.globalAlpha = 0.15 + Math.sin(frame * 0.2) * 0.1;
                }

                // Main body
                ctx.fillStyle = mb.color;
                ctx.shadowColor = mb.color;
                ctx.shadowBlur = 15;
                ctx.fillRect(mb.x, mb.y, mb.width, mb.height);

                // Outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(mb.x, mb.y, mb.width, mb.height);

                // Cockpit
                ctx.fillStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 8;
                ctx.fillRect(mb.x + 5, mb.y + mb.height/2 - 10, 15, 20);

                // Engine flames
                const flameLen = 20 + Math.random() * 15;
                const gradient = ctx.createLinearGradient(mb.x + mb.width, mb.y + mb.height/2, mb.x + mb.width + flameLen, mb.y + mb.height/2);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, '#ff0');
                gradient.addColorStop(0.6, '#f80');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(mb.x + mb.width, mb.y + mb.height/2 - 8, flameLen, 16);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // Health bar
                ctx.fillStyle = '#300';
                ctx.fillRect(mb.x, mb.y - 15, mb.width, 8);
                const healthPct = mb.health / mb.maxHealth;
                ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                ctx.fillRect(mb.x, mb.y - 15, mb.width * healthPct, 8);

                // Name
                ctx.fillStyle = '#fff';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(mb.name, mb.x + mb.width/2, mb.y - 22);

                // Mini-boss bullets
                mb.bullets.forEach(b => {
                    if (b.isBomb) {
                        // Bomb visual
                        ctx.fillStyle = '#f00';
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#f0f';
                        ctx.shadowColor = '#f0f';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.shadowBlur = 0;

                ctx.restore();
            }

            // Floating texts
            ctx.textAlign = 'center';
            floatingTexts.forEach(t => {
                ctx.fillStyle = t.color;
                ctx.globalAlpha = Math.min(1, t.life / 35);
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 10;
                ctx.font = `${t.size || 12}px "Press Start 2P"`;
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Slow motion overlay
            if (slowMotion > 0) {
                ctx.fillStyle = `rgba(100, 0, 150, ${0.2 * (slowMotion / 90)})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Vignette effect
                const vignette = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, 100,
                    canvas.width/2, canvas.height/2, 500
                );
                vignette.addColorStop(0, 'transparent');
                vignette.addColorStop(1, `rgba(50, 0, 80, ${0.5 * (slowMotion / 90)})`);
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!gameRunning || paused) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Show menu on load
        document.getElementById('startScreen').style.display = 'flex';
    </script>
</body>
</html>
