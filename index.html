<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHOPPER COMMAND - LEGENDARY EDITION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            background: #000;
            border: 4px solid #0ff;
            box-shadow: 0 0 30px #0ff, 0 0 60px #f0f, inset 0 0 30px rgba(0,255,255,0.1);
            animation: borderPulse 2s infinite;
        }
        @keyframes borderPulse {
            0%, 100% { border-color: #0ff; box-shadow: 0 0 30px #0ff, 0 0 60px #f0f; }
            50% { border-color: #f0f; box-shadow: 0 0 30px #f0f, 0 0 60px #0ff; }
        }
        #crt {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            z-index: 100;
        }
        canvas { display: block; image-rendering: pixelated; }
        #ui {
            position: absolute;
            top: 10px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 12px;
            font-family: 'Press Start 2P', monospace;
            text-shadow: 0 0 10px currentColor;
            z-index: 50;
        }
        .score-label { color: #0ff; text-shadow: 0 0 10px #0ff, 0 0 20px #0ff; }
        .lives-display { color: #f0f; text-shadow: 0 0 10px #f0f; transition: all 0.1s; }
        .lives-hit { animation: livesFlash 0.5s ease; }
        @keyframes livesFlash {
            0%, 100% { color: #f0f; text-shadow: 0 0 10px #f0f; transform: scale(1); }
            50% { color: #f00; text-shadow: 0 0 30px #f00, 0 0 50px #f00; transform: scale(1.3); }
        }
        .level-display { color: #ff0; text-shadow: 0 0 10px #ff0; }
        .coins-display { color: #fd0; text-shadow: 0 0 10px #fd0; }
        #ultBar {
            position: absolute;
            bottom: 15px; left: 50%;
            transform: translateX(-50%);
            width: 200px; height: 20px;
            background: #111;
            border: 2px solid #f0f;
            box-shadow: 0 0 10px #f0f;
            z-index: 50;
        }
        #ultFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #f0f, #0ff);
            box-shadow: 0 0 15px #f0f;
            transition: width 0.2s;
        }
        #ultText {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 2px; left: 0;
            font-size: 10px;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        #rageIndicator {
            position: absolute;
            bottom: 45px; left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #f00;
            text-shadow: 0 0 20px #f00, 0 0 40px #f00;
            z-index: 50;
            display: none;
            animation: ragePulse 0.3s infinite;
        }
        @keyframes ragePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        .shop-item {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #222;
            border: 2px solid #0ff;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .shop-item:hover { background: #333; box-shadow: 0 0 15px #0ff; }
        .shop-item.disabled { opacity: 0.4; cursor: not-allowed; border-color: #444; }
        .heli-option {
            display: inline-block;
            width: 120px;
            padding: 10px;
            margin: 5px;
            background: #222;
            border: 2px solid #0ff;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            cursor: pointer;
            vertical-align: top;
        }
        .heli-option:hover { box-shadow: 0 0 15px #0ff; }
        .heli-option.selected { border-color: #0f0; box-shadow: 0 0 20px #0f0; }
        .heli-option .heli-name { color: #0ff; font-size: 10px; }
        .heli-option .heli-stat { color: #888; margin: 3px 0; }
        #comboIndicator {
            position: absolute;
            top: 50px; right: 15px;
            font-size: 24px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #powerupIndicator {
            position: absolute;
            top: 50px; left: 15px;
            font-size: 10px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            z-index: 50;
        }
        #weaponIndicator {
            position: absolute;
            top: 70px; left: 15px;
            font-size: 8px;
            color: #ff0;
            text-shadow: 0 0 8px #ff0;
            z-index: 50;
        }
        #godlikeOverlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 90;
            opacity: 0;
            background: radial-gradient(circle, transparent 30%, rgba(255,100,0,0.3) 100%);
            transition: opacity 0.3s;
        }
        #bossHealth {
            position: absolute;
            top: 35px; left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 16px;
            background: #111;
            border: 2px solid #f00;
            box-shadow: 0 0 15px #f00;
            z-index: 50;
            display: none;
        }
        #bossHealthBar {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0, #f00);
            background-size: 200% 100%;
            animation: healthShimmer 1s linear infinite;
            width: 100%;
        }
        @keyframes healthShimmer {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }
        #bossName {
            position: absolute;
            top: 55px; left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
            z-index: 50;
            display: none;
            animation: bossNamePulse 0.5s infinite;
        }
        @keyframes bossNamePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000012;
            color: #fff;
            z-index: 200;
            overflow-y: auto;
            padding: 20px 0;
        }
        .overlay h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #0ff, #f0f, #ff0, #0ff);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbowText 3s linear infinite;
            margin-bottom: 5px;
            text-shadow: none;
            filter: drop-shadow(0 0 20px #0ff);
        }
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }
        .subtitle {
            font-size: 12px;
            color: #f0f;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #f0f;
            animation: subtitleGlow 1s infinite alternate;
        }
        @keyframes subtitleGlow {
            0% { text-shadow: 0 0 10px #f0f; }
            100% { text-shadow: 0 0 30px #f0f, 0 0 50px #f0f; }
        }
        .menu-option {
            margin: 5px;
            padding: 12px 25px;
            font-size: 11px;
            font-family: 'Press Start 2P', monospace;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 10px #0ff;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
        .menu-option:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff, 0 0 50px #0ff;
            text-shadow: none;
            transform: scale(1.05);
        }
        .difficulty-btn { min-width: 180px; }
        .difficulty-btn.easy { border-color: #0f0; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .difficulty-btn.easy:hover { background: #0f0; box-shadow: 0 0 30px #0f0; }
        .difficulty-btn.normal { border-color: #ff0; color: #ff0; text-shadow: 0 0 10px #ff0; }
        .difficulty-btn.normal:hover { background: #ff0; box-shadow: 0 0 30px #ff0; }
        .difficulty-btn.hard { border-color: #f00; color: #f00; text-shadow: 0 0 10px #f00; }
        .difficulty-btn.hard:hover { background: #f00; box-shadow: 0 0 30px #f00; }
        .difficulty-btn.legendary { border-color: #f0f; color: #f0f; text-shadow: 0 0 10px #f0f; animation: legendaryPulse 0.5s infinite; }
        .difficulty-btn.legendary:hover { background: #f0f; box-shadow: 0 0 50px #f0f; }
        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px #f0f; }
            50% { box-shadow: 0 0 30px #f0f, 0 0 50px #0ff; }
        }
        .mode-section { margin-top: 12px; display: flex; gap: 10px; }
        .mode-btn { font-size: 9px; padding: 10px 18px; border-color: #888; color: #888; }
        .mode-btn:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }
        .extra-section { margin-top: 12px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; max-width: 600px; }
        .extra-btn { font-size: 8px; padding: 8px 12px; border-color: #f0f; color: #f0f; }
        .extra-btn:hover { border-color: #fff; color: #fff; background: rgba(255,0,255,0.2); }
        .controls-info { font-size: 8px !important; color: #555 !important; margin: 0 !important; line-height: 1.6; }
        .difficulty-section { display: flex; flex-direction: column; align-items: center; margin-top: 10px; }
        .bottom-section { margin-top: 15px; display: flex; align-items: center; gap: 15px; }
        .music-btn {
            padding: 8px 15px; font-size: 10px; font-family: 'Press Start 2P', monospace;
            background: #111; color: #0ff; border: 2px solid #0ff; cursor: pointer;
            transition: all 0.2s; text-shadow: 0 0 5px #0ff;
        }
        .music-btn:hover { background: #0ff; color: #000; text-shadow: none; }
        .music-btn.active { border-color: #0f0; color: #0f0; text-shadow: 0 0 5px #0f0; }
        /* Skin screen */
        #skinGrid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; max-width: 500px; margin: 0 auto 20px; }
        .skin-item { background: rgba(0,0,0,0.5); border: 2px solid #444; padding: 10px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .skin-item:hover { border-color: #fff; transform: scale(1.05); }
        .skin-item.selected { border-color: #0ff; box-shadow: 0 0 15px #0ff; }
        .skin-item.locked { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }
        .skin-preview { width: 50px; height: 25px; margin: 5px auto; border-radius: 5px; }
        .skin-name { font-size: 9px; color: #fff; margin-top: 5px; }
        .skin-desc { font-size: 7px; color: #888; }
        /* Achievement screen */
        #achievementGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; max-width: 550px; margin: 0 auto 20px; }
        .achievement { background: rgba(0,0,0,0.5); border: 2px solid #444; padding: 8px; text-align: center; }
        .achievement.unlocked { border-color: #ffd700; background: rgba(255,215,0,0.1); }
        .achievement.locked { opacity: 0.5; }
        .ach-icon { font-size: 24px; }
        .ach-name { font-size: 8px; color: #fff; margin: 3px 0; }
        .ach-desc { font-size: 7px; color: #888; }
        .ach-reward { font-size: 7px; color: #0ff; margin-top: 3px; }
        #finalScore { font-size: 28px; color: #0ff; margin: 15px 0; text-shadow: 0 0 20px #0ff; }
        .highscore-list { font-size: 10px; color: #f0f; margin: 10px 0; text-align: left; }
        .controls-info { font-size: 8px; color: #666; margin-top: 25px; }
        #pauseScreen h1 { filter: drop-shadow(0 0 20px #0ff); }
        /* Upgrade screen */
        #upgradeScreen { display: none; }
        .upgrade-option {
            margin: 5px;
            padding: 10px 20px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .perk-icon { font-size: 20px; }
        /* Mobile controls */
        #mobileControls { display: none; position: absolute; bottom: 10px; left: 10px; right: 10px; z-index: 150; }
        .mobile-btn {
            width: 60px; height: 60px;
            background: rgba(0,255,255,0.2);
            border: 2px solid rgba(0,255,255,0.5);
            border-radius: 15px;
            color: #0ff;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        #joystickArea {
            position: absolute;
            left: 10px; bottom: 10px;
            width: 120px; height: 120px;
            background: rgba(0,255,255,0.1);
            border-radius: 60px;
            border: 2px solid rgba(0,255,255,0.3);
        }
        #joystick {
            position: absolute;
            width: 50px; height: 50px;
            background: rgba(0,255,255,0.5);
            border-radius: 25px;
            left: 35px; top: 35px;
        }
        #fireBtn { position: absolute; right: 20px; bottom: 30px; width: 80px; height: 80px; background: rgba(255,0,100,0.3); border-color: #f0f; }
        #bombBtn { position: absolute; right: 110px; bottom: 50px; background: rgba(255,165,0,0.3); border-color: #fa0; }
        #laserBtn { position: absolute; right: 110px; bottom: 120px; background: rgba(255,0,0,0.3); border-color: #f00; font-size: 8px; }
        @media (max-width: 850px) {
            #mobileControls { display: block; }
            #ui { font-size: 10px; }
        }
        /* Progression System UI */
        #xpBarGame { position: relative; width: 150px; height: 18px; background: rgba(0,0,0,0.7); border: 2px solid #0ff; border-radius: 6px; align-self: center; }
        #xpBarGameFill { height: 100%; background: linear-gradient(90deg, #0ff, #f0f); width: 0%; transition: width 0.3s; border-radius: 4px; }
        #xpBarGameText { position: absolute; width: 100%; text-align: center; font-size: 8px; color: #fff; top: 3px; left: 0; text-shadow: 0 0 5px #000; }
        #progressionScreen { overflow-y: auto; max-height: 100%; }
        .prog-header { display: flex; gap: 20px; justify-content: center; margin: 10px 0; padding: 10px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; }
        .prog-stat { text-align: center; }
        .prog-stat-label { font-size: 8px; color: #888; display: block; }
        .prog-stat-value { font-size: 14px; color: #0ff; }
        .prog-tabs { display: flex; gap: 10px; justify-content: center; margin: 10px 0; }
        .prog-tab { padding: 8px 16px; font-size: 10px; font-family: 'Press Start 2P', monospace; background: transparent; border: 2px solid #444; color: #888; cursor: pointer; }
        .prog-tab.active { border-color: #0ff; color: #0ff; box-shadow: 0 0 10px #0ff; }
        .prog-tab:hover { border-color: #0ff; }
        .cat-tabs { display: flex; gap: 5px; justify-content: center; margin: 10px 0; }
        .cat-tab { padding: 5px 12px; font-size: 8px; font-family: 'Press Start 2P', monospace; background: transparent; border: 1px solid #444; color: #666; cursor: pointer; }
        .cat-tab.active { border-color: #f0f; color: #f0f; }
        .upgrade-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; max-width: 500px; margin: 0 auto; padding: 10px; }
        .perm-upgrade { display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(0,0,0,0.6); border: 2px solid #333; text-align: left; }
        .perm-upgrade.can-buy { border-color: #0f0; cursor: pointer; }
        .perm-upgrade.maxed { border-color: #fd0; }
        .perm-upgrade:hover.can-buy { background: rgba(0,255,0,0.1); }
        .upgrade-icon { font-size: 20px; }
        .upgrade-info { flex: 1; }
        .upgrade-name { font-size: 9px; color: #fff; }
        .upgrade-desc { font-size: 7px; color: #888; margin-top: 2px; }
        .upgrade-lvl { font-size: 7px; color: #0ff; }
        .upgrade-cost { padding: 4px 8px; font-size: 9px; font-family: 'Press Start 2P', monospace; background: #111; border: 1px solid #0ff; color: #0ff; cursor: pointer; }
        .upgrade-cost.disabled { opacity: 0.4; border-color: #444; color: #444; cursor: not-allowed; }
        .upgrade-cost.maxed { background: #fd0; color: #000; border-color: #fd0; }
        .skill-tree { display: flex; justify-content: center; gap: 20px; padding: 10px; }
        .skill-branch { width: 140px; text-align: center; }
        .skill-branch h4 { font-size: 10px; color: #f0f; margin-bottom: 10px; }
        .skill-nodes { display: flex; flex-direction: column; gap: 8px; align-items: center; }
        .skill-node { width: 100px; padding: 8px; background: rgba(0,0,0,0.6); border: 2px solid #333; cursor: pointer; transition: all 0.2s; }
        .skill-node.locked { opacity: 0.3; cursor: not-allowed; }
        .skill-node.can-unlock { border-color: #0f0; animation: skillPulse 1s infinite; }
        .skill-node.unlocked { border-color: #fd0; background: rgba(255,215,0,0.1); }
        .skill-node:hover:not(.locked) { transform: scale(1.05); }
        .skill-icon { font-size: 18px; }
        .skill-name { font-size: 7px; color: #fff; margin-top: 3px; }
        .skill-req { font-size: 6px; color: #888; }
        .prestige-info { text-align: center; padding: 20px; }
        .prestige-stars { font-size: 28px; display: block; margin: 10px 0; }
        .prestige-bonus { font-size: 12px; color: #fd0; margin: 10px 0; }
        .prestige-btn { background: linear-gradient(90deg, #fd0, #f80) !important; color: #000 !important; border-color: #fd0 !important; font-size: 12px !important; padding: 12px 24px !important; margin: 20px 0 !important; }
        .prestige-btn:disabled { background: #333 !important; color: #666 !important; border-color: #444 !important; }
        .prestige-rewards { margin-top: 20px; }
        .prestige-rewards h4 { font-size: 10px; color: #888; margin-bottom: 10px; }
        .prestige-skin { display: inline-block; padding: 5px 10px; margin: 3px; font-size: 8px; border: 1px solid #444; }
        .prestige-skin.unlocked { border-color: #fd0; color: #fd0; }
        @keyframes skillPulse { 0%, 100% { box-shadow: 0 0 5px #0f0; } 50% { box-shadow: 0 0 15px #0f0; } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading { display: inline-block; animation: spin 1s linear infinite; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="crt"></div>
        <div id="godlikeOverlay"></div>
        <div id="ui">
            <div><span class="score-label">SCORE</span><br><span id="score">00000000</span></div>
            <div><span class="level-display">STAGE</span><br><span id="level">01</span></div>
            <div id="xpBarGame"><div id="xpBarGameFill"></div><span id="xpBarGameText">LV.1</span></div>
            <div><span class="lives-display">LIVES</span><br><span id="lives"></span></div>
            <div><span class="coins-display">COINS</span><br><span id="coins">ü™ô 0</span></div>
        </div>
        <div id="ultBar"><div id="ultFill"></div><span id="ultText">ULT</span></div>
        <div id="comboIndicator">x1</div>
        <div id="powerupIndicator"></div>
        <div id="weaponIndicator">WEAPON: NORMAL</div>
        <div id="rageIndicator">üî• RAGE MODE üî•</div>
        <div id="bossHealth"><div id="bossHealthBar"></div></div>
        <div id="bossName">BOSS</div>

        <div id="startScreen" class="overlay">
            <h1>CHOPPER COMMAND</h1>
            <p class="subtitle">‚òÖ LEGENDARY EDITION ‚òÖ</p>
            <div class="difficulty-section">
                <button class="menu-option difficulty-btn easy" onclick="startGame('easy')">EASY</button>
                <button class="menu-option difficulty-btn normal" onclick="startGame('normal')">NORMAL</button>
                <button class="menu-option difficulty-btn hard" onclick="startGame('hard')">HARD</button>
                <button class="menu-option difficulty-btn legendary" onclick="startGame('legendary')">LEGENDARY</button>
            </div>
            <div class="mode-section">
                <button class="menu-option mode-btn" onclick="startGame('endless')">ENDLESS</button>
                <button class="menu-option mode-btn" onclick="startGame('bossrush')">BOSS RUSH</button>
            </div>
            <div class="extra-section">
                <button class="menu-option extra-btn" onclick="showProgressionScreen()" style="background:linear-gradient(90deg,#0ff,#f0f);color:#000;">‚öôÔ∏è UPGRADES</button>
                <button class="menu-option extra-btn" onclick="showHeliSelect()">üöÅ HELICOPTERS</button>
                <button class="menu-option extra-btn" onclick="showSkinScreen()">üé® SKINS</button>
                <button class="menu-option extra-btn" onclick="showAchievements()">üèÜ ACHIEVEMENTS</button>
            </div>
            <div class="multiplayer-section" style="margin-top:15px;">
                <button class="menu-option" onclick="showMultiplayerMenu()" style="border-color:#0ff;color:#0ff;font-size:12px;padding:12px 30px;">üåê MULTIPLAYER</button>
            </div>
            <div class="bottom-section">
                <p class="controls-info">WASD: Move | SPACE: Fire | B: Bomb | L: Laser | R: Rockets | U: Ultimate<br>ESC: Pause | M: Music | 1-4: Weapons</p>
                <button id="menuMusicBtn" class="music-btn" onclick="toggleMenuMusic()">üéµ OFF</button>
            </div>
        </div>

        <div id="pauseScreen" class="overlay" style="display:none;">
            <h1>PAUSED</h1>
            <button class="menu-option" onclick="resumeGame()">RESUME</button>
            <button class="menu-option" onclick="quitToMenu()">QUIT</button>
        </div>

        <div id="upgradeScreen" class="overlay">
            <h1 style="font-size:24px;">LEVEL UP!</h1>
            <p style="color:#0ff;margin:20px;">Choose your upgrade:</p>
            <div id="upgradeOptions"></div>
        </div>

        <div id="shopScreen" class="overlay" style="display:none;">
            <h1>üè™ SHOP</h1>
            <p id="shopCoins" style="color:#fd0;font-size:18px;">ü™ô 0</p>
            <div id="shopItems"></div>
            <button class="menu-option" onclick="closeShop()">CONTINUE ‚Üí</button>
        </div>

        <div id="heliSelectScreen" class="overlay" style="display:none;">
            <h1>üöÅ SELECT HELICOPTER</h1>
            <div id="heliGrid"></div>
            <button class="menu-option" onclick="closeHeliSelect()">BACK</button>
        </div>

        <div id="gameOverScreen" class="overlay" style="display:none;">
            <h1>GAME OVER</h1>
            <div id="finalScore">00000000</div>
            <div class="highscore-list" id="highscoreList"></div>
            <button class="menu-option" onclick="showMenu()">MENU</button>
        </div>

        <div id="skinScreen" class="overlay" style="display:none;">
            <h1>HELICOPTERS</h1>
            <p style="color:#888;font-size:10px;margin-bottom:15px;">Unlock skins by earning achievements</p>
            <div id="skinGrid"></div>
            <button class="menu-option" onclick="closeSkinScreen()">BACK</button>
        </div>

        <div id="achievementScreen" class="overlay" style="display:none;">
            <h1>ACHIEVEMENTS</h1>
            <p style="color:#888;font-size:10px;margin-bottom:15px;" id="achievementProgress">0/15 Unlocked</p>
            <div id="achievementGrid"></div>
            <button class="menu-option" onclick="closeAchievements()">BACK</button>
        </div>

        <!-- MULTIPLAYER SCREENS -->
        <div id="multiplayerScreen" class="overlay" style="display:none;">
            <h1>üåê LAN MULTIPLAYER</h1>
            <p style="color:#0ff;font-size:10px;margin-bottom:20px;">Play with a friend on local network!</p>
            <div style="margin-bottom:20px;">
                <label style="font-size:10px;color:#888;">YOUR NICKNAME:</label><br>
                <input type="text" id="nicknameInput" maxlength="12" style="margin-top:8px;padding:10px 15px;font-family:'Press Start 2P';font-size:12px;background:#111;color:#0ff;border:2px solid #0ff;text-align:center;width:200px;">
            </div>
            <div style="display:flex;gap:15px;">
                <button class="menu-option" onclick="showCreateRoom()" style="border-color:#0f0;color:#0f0;">CREATE ROOM</button>
                <button class="menu-option" onclick="showJoinRoom()" style="border-color:#f0f;color:#f0f;">JOIN ROOM</button>
            </div>
            <button class="menu-option" onclick="backToMainMenu()" style="margin-top:20px;font-size:9px;">‚Üê BACK</button>
        </div>

        <div id="createRoomScreen" class="overlay" style="display:none;">
            <h1>CREATE ROOM (HOST)</h1>
            <p style="color:#888;font-size:9px;margin-bottom:15px;">Step 1: Copy OFFER code and send to friend</p>
            <div id="hostCodeBox" style="display:none;margin-bottom:15px;">
                <p style="color:#0f0;font-size:10px;">üì§ YOUR OFFER CODE:</p>
                <div style="background:#111;border:2px solid #0f0;padding:10px;margin:10px 0;max-width:400px;word-break:break-all;font-size:8px;max-height:80px;overflow-y:auto;" id="hostCode"></div>
                <button class="menu-option" onclick="copyCode('hostCode')" style="font-size:9px;padding:8px 15px;">üìã COPY OFFER</button>
            </div>
            <div style="margin-top:20px;">
                <p style="color:#ff0;font-size:10px;">Step 2: Paste friend's ANSWER code:</p>
                <textarea id="answerCodeInput" style="width:350px;height:60px;margin:10px 0;padding:8px;font-family:monospace;font-size:8px;background:#111;color:#ff0;border:2px solid #ff0;" placeholder="Paste ANSWER code here..."></textarea><br>
                <button class="menu-option" onclick="connectWithAnswer()" style="border-color:#ff0;color:#ff0;">CONNECT</button>
            </div>
            <button class="menu-option" onclick="backToMultiplayerMenu()" style="margin-top:20px;font-size:9px;">‚Üê BACK</button>
        </div>

        <div id="joinRoomScreen" class="overlay" style="display:none;">
            <h1>JOIN ROOM (GUEST)</h1>
            <p style="color:#888;font-size:9px;margin-bottom:15px;">Step 1: Paste host's OFFER code</p>
            <div style="margin-bottom:15px;">
                <p style="color:#0f0;font-size:10px;">üì• PASTE OFFER CODE:</p>
                <textarea id="joinCodeInput" style="width:350px;height:60px;margin:10px 0;padding:8px;font-family:monospace;font-size:8px;background:#111;color:#0f0;border:2px solid #0f0;" placeholder="Paste OFFER code here..."></textarea><br>
                <button class="menu-option" onclick="joinWithCode()" style="border-color:#0f0;color:#0f0;">GENERATE ANSWER</button>
            </div>
            <div id="guestCodeBox" style="display:none;margin-top:15px;">
                <p style="color:#f0f;font-size:10px;">üì§ YOUR ANSWER CODE (send to host):</p>
                <div style="background:#111;border:2px solid #f0f;padding:10px;margin:10px 0;max-width:400px;word-break:break-all;font-size:8px;max-height:80px;overflow-y:auto;" id="guestCode"></div>
                <button class="menu-option" onclick="copyCode('guestCode')" style="font-size:9px;padding:8px 15px;">üìã COPY ANSWER</button>
            </div>
            <button class="menu-option" onclick="backToMultiplayerMenu()" style="margin-top:20px;font-size:9px;">‚Üê BACK</button>
        </div>

        <div id="hostLobbyScreen" class="overlay" style="display:none;">
            <h1>üéÆ ROOM READY!</h1>
            <p style="color:#0f0;font-size:12px;margin:20px 0;">Connected: <span id="connectedPlayer" style="color:#0ff;">Player 2</span></p>
            <p style="color:#888;font-size:10px;margin-bottom:20px;">Select difficulty to start:</p>
            <div style="display:flex;flex-direction:column;gap:8px;">
                <button class="menu-option difficulty-btn easy" onclick="hostStartGame('easy')">EASY</button>
                <button class="menu-option difficulty-btn normal" onclick="hostStartGame('normal')">NORMAL</button>
                <button class="menu-option difficulty-btn hard" onclick="hostStartGame('hard')">HARD</button>
                <button class="menu-option difficulty-btn legendary" onclick="hostStartGame('legendary')">LEGENDARY</button>
            </div>
            <button class="menu-option" onclick="backToMainMenu()" style="margin-top:20px;font-size:9px;">CANCEL</button>
        </div>

        <div id="guestLobbyScreen" class="overlay" style="display:none;">
            <h1>üéÆ CONNECTED!</h1>
            <p style="color:#0f0;font-size:12px;margin:20px 0;">Host: <span id="hostPlayerName" style="color:#0ff;">Player 1</span></p>
            <p style="color:#888;font-size:10px;">Waiting for host to start game...</p>
            <div class="loader" style="margin:30px auto;width:40px;height:40px;border:4px solid #333;border-top-color:#0ff;border-radius:50%;animation:spin 1s linear infinite;"></div>
            <button class="menu-option" onclick="backToMainMenu()" style="margin-top:20px;font-size:9px;">LEAVE</button>
        </div>

        <div id="progressionScreen" class="overlay" style="display:none;">
            <h1>‚öôÔ∏è UPGRADES</h1>
            <div class="prog-header">
                <div class="prog-stat"><span class="prog-stat-label">LEVEL</span><span class="prog-stat-value" id="progLevel">1</span></div>
                <div class="prog-stat"><span class="prog-stat-label">XP</span><span class="prog-stat-value" id="progXP">0/100</span></div>
                <div class="prog-stat"><span class="prog-stat-label">COINS</span><span class="prog-stat-value" id="progCoins">0 ü™ô</span></div>
                <div class="prog-stat"><span class="prog-stat-label">PRESTIGE</span><span class="prog-stat-value" id="progPrestige">-</span></div>
            </div>
            <div class="prog-tabs">
                <button class="prog-tab active" onclick="showProgTab('upgrades')">UPGRADES</button>
                <button class="prog-tab" onclick="showProgTab('skills')">SKILLS</button>
                <button class="prog-tab" onclick="showProgTab('prestige')">PRESTIGE</button>
            </div>
            <div id="progUpgradesTab">
                <div class="cat-tabs">
                    <button class="cat-tab active" onclick="showUpgradeCat('offense')">‚öîÔ∏è OFFENSE</button>
                    <button class="cat-tab" onclick="showUpgradeCat('defense')">üõ°Ô∏è DEFENSE</button>
                    <button class="cat-tab" onclick="showUpgradeCat('utility')">üîß UTILITY</button>
                </div>
                <div id="upgradeGridPerm" class="upgrade-grid"></div>
            </div>
            <div id="progSkillsTab" style="display:none;">
                <div class="skill-tree">
                    <div class="skill-branch"><h4>‚öîÔ∏è ATTACK</h4><div id="skillsAttack" class="skill-nodes"></div></div>
                    <div class="skill-branch"><h4>üõ°Ô∏è DEFENSE</h4><div id="skillsDefense" class="skill-nodes"></div></div>
                    <div class="skill-branch"><h4>üîß UTILITY</h4><div id="skillsUtility" class="skill-nodes"></div></div>
                </div>
            </div>
            <div id="progPrestigeTab" style="display:none;">
                <div class="prestige-info">
                    <span class="prestige-stars" id="prestigeStarsDisplay"></span>
                    <p class="prestige-bonus" id="prestigeBonusDisplay">Bonus: +0% All Stats</p>
                    <button class="menu-option prestige-btn" id="prestigeBtn" onclick="confirmPrestige()">‚≠ê PRESTIGE</button>
                    <p style="font-size:8px;color:#888;margin-top:10px;">Requires Level 10. Resets level but keeps upgrades.</p>
                    <div class="prestige-rewards"><h4>PRESTIGE SKINS</h4><div id="prestigeSkinsList"></div></div>
                </div>
            </div>
            <button class="menu-option" onclick="closeProgressionScreen()">BACK</button>
        </div>

        <div id="mobileControls">
            <div id="joystickArea"><div id="joystick"></div></div>
            <div id="fireBtn" class="mobile-btn">FIRE</div>
            <div id="bombBtn" class="mobile-btn">BOMB</div>
            <div id="laserBtn" class="mobile-btn">LASER</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ============ LEGENDARY AUDIO ENGINE ============
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        let musicPlaying = false;
        let musicNodes = { bass: null, lead: null, drums: null, intensity: 0 };
        let voiceCooldown = 0;

        function initAudio() {
            if (!audioCtx && AudioCtx) audioCtx = new AudioCtx();
        }

        // Voice samples (8-bit style)
        function playVoice(text) {
            if (!audioCtx || voiceCooldown > 0) return;
            voiceCooldown = 120;

            const frequencies = {
                'COMBO': [440, 550, 660],
                'MEGA KILL': [330, 440, 550, 660],
                'UNSTOPPABLE': [220, 330, 440, 550, 660, 770],
                'GODLIKE': [110, 220, 330, 440, 550, 660, 770, 880],
                'BOSS INCOMING': [220, 165, 220, 165]
            };

            const freqs = frequencies[text] || [440];
            freqs.forEach((f, i) => {
                setTimeout(() => {
                    if (!audioCtx) return;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(f, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                }, i * 80);
            });
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(880, now);
                    osc.frequency.exponentialRampToValueAtTime(110, now + 0.06);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
                    osc.start(now); osc.stop(now + 0.06);
                    break;
                case 'laser':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                    osc.frequency.linearRampToValueAtTime(200, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                case 'rocket':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                case 'plasma':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.setValueAtTime(300, now + 0.05);
                    osc.frequency.setValueAtTime(150, now + 0.1);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                case 'explosion':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                    break;
                case 'megaExplosion':
                    // Multiple layered explosion
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const o = audioCtx.createOscillator();
                            const g = audioCtx.createGain();
                            o.connect(g); g.connect(audioCtx.destination);
                            o.type = 'sawtooth';
                            o.frequency.setValueAtTime(100 - i*20, audioCtx.currentTime);
                            o.frequency.exponentialRampToValueAtTime(15, audioCtx.currentTime + 0.6);
                            g.gain.setValueAtTime(0.4, audioCtx.currentTime);
                            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                            o.start(); o.stop(audioCtx.currentTime + 0.6);
                        }, i * 100);
                    }
                    return;
                case 'hit':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.08);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    osc.start(now); osc.stop(now + 0.08);
                    break;
                case 'powerup':
                    osc.type = 'sine';
                    [440, 550, 660, 880].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.05));
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                    osc.start(now); osc.stop(now + 0.25);
                    break;
                case 'combo':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(660, now);
                    osc.frequency.setValueAtTime(880, now + 0.05);
                    osc.frequency.setValueAtTime(1100, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                case 'bomb':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(60, now);
                    osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
                case 'boss':
                    for (let i = 0; i < 6; i++) {
                        osc.frequency.setValueAtTime(110, now + i*0.15);
                        osc.frequency.setValueAtTime(220, now + i*0.15 + 0.07);
                    }
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                    osc.start(now); osc.stop(now + 1);
                    break;
                case 'slowmo':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'thunder':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.setValueAtTime(60, now + 0.1);
                    osc.frequency.setValueAtTime(40, now + 0.3);
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'levelUp':
                    osc.type = 'square';
                    [440, 550, 660, 880, 1100].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.08));
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                case 'gameOver':
                    osc.type = 'square';
                    [440, 330, 220, 110, 55].forEach((f, i) => osc.frequency.setValueAtTime(f, now + i*0.15));
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now); osc.stop(now + 0.8);
                    break;
            }
        }

        // ============ BATTLE MUSIC ============
        // Aggressive E minor battle theme - war drums and synth assault
        let musicBeat = 0;
        let battleSection = 0; // 0-3 for different parts

        // E minor: E F# G A B C D E
        // E2=82, E3=165, E4=330, G4=392, A4=440, B4=494, D5=587, E5=659

        // Driving bass patterns (E minor power)
        const battleBass = [
            82, 0, 82, 82, 0, 82, 0, 82,   // E2 driving
            82, 0, 110, 0, 82, 0, 98, 0,   // E2, A2, G2
            73, 0, 73, 73, 0, 82, 0, 98,   // D2, E2, G2
            82, 0, 82, 0, 110, 0, 82, 82   // E2, A2, E2
        ];

        // Aggressive melody phrases
        const battleMelody = [
            // Phrase 1: Attack!
            [330, 392, 440, 494, 440, 392, 330, 0],
            // Phrase 2: Rising tension
            [494, 523, 587, 659, 587, 523, 494, 440],
            // Phrase 3: Heroic
            [659, 587, 494, 440, 494, 587, 659, 784],
            // Phrase 4: Resolution
            [440, 392, 330, 294, 330, 392, 440, 330]
        ];

        // Fast arpeggios for intensity
        const battleArp = [
            330, 392, 494, 659, 494, 392,  // Em arpeggio up/down
            294, 392, 494, 587, 494, 392,  // G arpeggio
            349, 440, 523, 698, 523, 440,  // F arpeggio (tension!)
            330, 392, 494, 659, 784, 659   // Em high
        ];

        let battleArpIndex = 0;
        let battleMelodyIndex = 0;
        let battleMelodyNote = 0;
        let scheduledBattleTime = 0;

        function playMusicBeat() {
            if (!audioCtx || !musicPlaying) return;
            const now = audioCtx.currentTime;

            // Dynamic intensity based on combo
            const intensity = Math.min(1, 0.4 + (typeof combo !== 'undefined' ? combo : 0) * 0.03);
            musicNodes.intensity = intensity;

            // Change section every 32 beats
            if (musicBeat % 128 === 0) {
                battleSection = (battleSection + 1) % 4;
            }

            // === KICK DRUM - Four on the floor with variations ===
            if (musicBeat % 4 === 0) {
                const kick = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kick.connect(kickGain);
                kickGain.connect(audioCtx.destination);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(120, now);
                kick.frequency.exponentialRampToValueAtTime(35, now + 0.12);
                kickGain.gain.setValueAtTime(0.25, now);
                kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                kick.start(now);
                kick.stop(now + 0.15);

                // Layer with click for punch
                const click = audioCtx.createOscillator();
                const clickGain = audioCtx.createGain();
                click.connect(clickGain);
                clickGain.connect(audioCtx.destination);
                click.type = 'square';
                click.frequency.setValueAtTime(1000, now);
                clickGain.gain.setValueAtTime(0.08, now);
                clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                click.start(now);
                click.stop(now + 0.02);
            }

            // === SNARE on 2 and 4 ===
            if (musicBeat % 8 === 4) {
                // Snare body
                const snare = audioCtx.createOscillator();
                const snareGain = audioCtx.createGain();
                snare.connect(snareGain);
                snareGain.connect(audioCtx.destination);
                snare.type = 'triangle';
                snare.frequency.setValueAtTime(200, now);
                snare.frequency.exponentialRampToValueAtTime(120, now + 0.1);
                snareGain.gain.setValueAtTime(0.15, now);
                snareGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                snare.start(now);
                snare.stop(now + 0.12);

                // Noise layer
                const noise = audioCtx.createOscillator();
                const noiseGain = audioCtx.createGain();
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.type = 'sawtooth';
                noise.frequency.setValueAtTime(400, now);
                noiseGain.gain.setValueAtTime(0.08, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                noise.start(now);
                noise.stop(now + 0.08);
            }

            // === HI-HAT - 8th notes with offbeat accent ===
            const hihatVol = (musicBeat % 2 === 1) ? 0.04 : 0.02;
            const hat = audioCtx.createOscillator();
            const hatGain = audioCtx.createGain();
            hat.connect(hatGain);
            hatGain.connect(audioCtx.destination);
            hat.type = 'square';
            hat.frequency.setValueAtTime(900 + Math.random() * 400, now);
            hatGain.gain.setValueAtTime(hihatVol, now);
            hatGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
            hat.start(now);
            hat.stop(now + 0.04);

            // === BASS LINE - Driving synth bass ===
            const bassNote = battleBass[(musicBeat + battleSection * 8) % battleBass.length];
            if (bassNote > 0) {
                // Main bass
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(audioCtx.destination);
                bass.type = 'sawtooth';
                bass.frequency.setValueAtTime(bassNote, now);
                bassGain.gain.setValueAtTime(0.12, now);
                bassGain.gain.exponentialRampToValueAtTime(0.02, now + 0.1);
                bass.start(now);
                bass.stop(now + 0.1);

                // Sub bass layer
                const sub = audioCtx.createOscillator();
                const subGain = audioCtx.createGain();
                sub.connect(subGain);
                subGain.connect(audioCtx.destination);
                sub.type = 'sine';
                sub.frequency.setValueAtTime(bassNote / 2, now);
                subGain.gain.setValueAtTime(0.1, now);
                subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                sub.start(now);
                sub.stop(now + 0.12);
            }

            // === MELODY - Every 2 beats, synth lead ===
            if (musicBeat % 4 === 0) {
                const melodyPhrase = battleMelody[battleSection];
                const note = melodyPhrase[battleMelodyNote % melodyPhrase.length];
                battleMelodyNote++;

                if (note > 0) {
                    // Lead synth with slight detune for thickness
                    const lead = audioCtx.createOscillator();
                    const lead2 = audioCtx.createOscillator();
                    const leadGain = audioCtx.createGain();
                    lead.connect(leadGain);
                    lead2.connect(leadGain);
                    leadGain.connect(audioCtx.destination);

                    lead.type = 'square';
                    lead2.type = 'square';
                    lead.frequency.setValueAtTime(note, now);
                    lead2.frequency.setValueAtTime(note * 1.005, now); // Slight detune
                    leadGain.gain.setValueAtTime(0.06, now);
                    leadGain.gain.setValueAtTime(0.08, now + 0.02);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
                    lead.start(now);
                    lead2.start(now);
                    lead.stop(now + 0.18);
                    lead2.stop(now + 0.18);
                }
            }

            // === ARPEGGIO - Fast 16th notes when intensity high ===
            if (intensity > 0.5) {
                const arpNote = battleArp[battleArpIndex % battleArp.length];
                battleArpIndex++;

                const arp = audioCtx.createOscillator();
                const arpGain = audioCtx.createGain();
                arp.connect(arpGain);
                arpGain.connect(audioCtx.destination);
                arp.type = 'triangle';
                arp.frequency.setValueAtTime(arpNote, now);
                arpGain.gain.setValueAtTime(0.03 * intensity, now);
                arpGain.gain.exponentialRampToValueAtTime(0.005, now + 0.06);
                arp.start(now);
                arp.stop(now + 0.06);
            }

            // === STAB - Chord stab on section changes ===
            if (musicBeat % 32 === 0) {
                // E minor power chord stab
                [165, 247, 330].forEach((freq, i) => {
                    const stab = audioCtx.createOscillator();
                    const stabGain = audioCtx.createGain();
                    stab.connect(stabGain);
                    stabGain.connect(audioCtx.destination);
                    stab.type = 'sawtooth';
                    stab.frequency.setValueAtTime(freq, now);
                    stabGain.gain.setValueAtTime(0.08, now);
                    stabGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    stab.start(now);
                    stab.stop(now + 0.3);
                });
            }

            // === RISER every 64 beats for tension ===
            if (musicBeat % 64 === 56) {
                const riser = audioCtx.createOscillator();
                const riserGain = audioCtx.createGain();
                riser.connect(riserGain);
                riserGain.connect(audioCtx.destination);
                riser.type = 'sawtooth';
                riser.frequency.setValueAtTime(200, now);
                riser.frequency.exponentialRampToValueAtTime(800, now + 0.8);
                riserGain.gain.setValueAtTime(0.05, now);
                riserGain.gain.setValueAtTime(0.1, now + 0.6);
                riserGain.gain.exponentialRampToValueAtTime(0.001, now + 0.85);
                riser.start(now);
                riser.stop(now + 0.85);
            }

            // === CRASH on section change ===
            if (musicBeat % 128 === 0 && musicBeat > 0) {
                const crash = audioCtx.createOscillator();
                const crashGain = audioCtx.createGain();
                crash.connect(crashGain);
                crashGain.connect(audioCtx.destination);
                crash.type = 'sawtooth';
                crash.frequency.setValueAtTime(600, now);
                crash.frequency.exponentialRampToValueAtTime(200, now + 0.8);
                crashGain.gain.setValueAtTime(0.12, now);
                crashGain.gain.exponentialRampToValueAtTime(0.001, now + 0.9);
                crash.start(now);
                crash.stop(now + 0.9);
            }

            musicBeat++;
        }

        let musicInterval = null;
        function toggleMusic() {
            musicPlaying = !musicPlaying;
            if (musicPlaying) {
                initAudio();
                musicBeat = 0;
                battleSection = 0;
                battleArpIndex = 0;
                battleMelodyNote = 0;
                musicInterval = setInterval(playMusicBeat, 107); // ~140 BPM - driving tempo
            } else {
                clearInterval(musicInterval);
            }
        }

        // ============ MENU MUSIC ============
        // Epic heroic theme in D minor - a lone pilot facing the unknown
        let menuMusicPlaying = false;
        let menuMusicGain = null; // Master gain for menu music
        let menuMusicInterval = null;
        let menuBeat = 0;

        // D minor scale: D E F G A Bb C D
        // Frequencies: D4=294, E4=330, F4=349, G4=392, A4=440, Bb4=466, C5=523, D5=587
        const menuMelody = [
            // Part 1: Rising hope (D minor arpeggio ascending)
            { note: 294, dur: 0.2 },  // D4 - –Ω–∞—á–∞–ª–æ, —Ç–∏—Ö–∞—è —Ä–µ—à–∏–º–æ—Å—Ç—å
            { note: 349, dur: 0.2 },  // F4
            { note: 440, dur: 0.3 },  // A4 - –ø–æ–¥—ä—ë–º
            { note: 587, dur: 0.5 },  // D5 - –º–æ–º–µ–Ω—Ç –æ—Å–æ–∑–Ω–∞–Ω–∏—è
            { note: 0, dur: 0.2 },    // –ø–∞—É–∑–∞ –¥–ª—è –¥—ã—Ö–∞–Ω–∏—è

            // Part 2: Tension builds (chromatic movement)
            { note: 523, dur: 0.15 }, // C5
            { note: 554, dur: 0.15 }, // C#5 - –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ
            { note: 587, dur: 0.4 },  // D5 - —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
            { note: 440, dur: 0.2 },  // A4
            { note: 466, dur: 0.3 },  // Bb4 - –≥—Ä—É—Å—Ç—å
            { note: 440, dur: 0.5 },  // A4 - –ø—Ä–∏–Ω—è—Ç–∏–µ
            { note: 0, dur: 0.2 },

            // Part 3: Call to action (faster, more urgent)
            { note: 587, dur: 0.12 }, // D5
            { note: 659, dur: 0.12 }, // E5
            { note: 698, dur: 0.12 }, // F5
            { note: 784, dur: 0.35 }, // G5 - –≤–∑–ª—ë—Ç!
            { note: 880, dur: 0.25 }, // A5 - –≤—ã—Å–æ—Ç–∞
            { note: 784, dur: 0.15 }, // G5
            { note: 698, dur: 0.15 }, // F5
            { note: 587, dur: 0.4 },  // D5 - –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ
            { note: 0, dur: 0.15 },

            // Part 4: Heroic resolve (power chords feeling)
            { note: 440, dur: 0.1 },  // A4
            { note: 440, dur: 0.1 },  // A4 - —É–¥–∞—Ä
            { note: 587, dur: 0.35 }, // D5
            { note: 523, dur: 0.2 },  // C5
            { note: 466, dur: 0.25 }, // Bb4 - –¥—Ä–∞–º–∞
            { note: 440, dur: 0.6 },  // A4 - –¥–æ–ª–≥–∞—è –Ω–æ—Ç–∞ –Ω–∞–¥–µ–∂–¥—ã
            { note: 0, dur: 0.3 },

            // Part 5: Soaring melody (emotional peak)
            { note: 698, dur: 0.2 },  // F5
            { note: 784, dur: 0.2 },  // G5
            { note: 880, dur: 0.5 },  // A5 - –∫—É–ª—å–º–∏–Ω–∞—Ü–∏—è
            { note: 784, dur: 0.15 }, // G5
            { note: 698, dur: 0.15 }, // F5
            { note: 659, dur: 0.15 }, // E5
            { note: 587, dur: 0.5 },  // D5

            // Part 6: Resolution (coming home)
            { note: 440, dur: 0.2 },  // A4
            { note: 349, dur: 0.2 },  // F4
            { note: 294, dur: 0.8 },  // D4 - —Ñ–∏–Ω–∞–ª, –∫—Ä—É–≥ –∑–∞–º–∫–Ω—É–ª—Å—è
            { note: 0, dur: 0.4 },    // —Ç–∏—à–∏–Ω–∞ –ø–µ—Ä–µ–¥ –Ω–æ–≤—ã–º —Ü–∏–∫–ª–æ–º
        ];

        // Deep bass pattern - heartbeat of the hero
        const menuBassPattern = [
            147, 0, 147, 73,   // D3, D2 (octave jump)
            147, 0, 175, 0,    // D3, F3
            131, 0, 131, 65,   // C3, C2
            147, 0, 110, 0,    // D3, A2
            147, 0, 147, 73,
            175, 0, 196, 0,    // F3, G3
            147, 0, 147, 0,
            110, 0, 131, 147,  // A2, C3, D3 (walking)
        ];

        // Arpeggio pattern for atmosphere
        const menuArpeggio = [
            294, 349, 440, 587, 440, 349,  // Dm arpeggio
            262, 330, 392, 523, 392, 330,  // C arpeggio
            233, 294, 349, 466, 349, 294,  // Bb arpeggio
            220, 277, 330, 440, 330, 277,  // Am arpeggio
        ];

        let menuNoteIndex = 0;
        let menuArpIndex = 0;
        let menuScheduledTime = 0;

        function playMenuMusic() {
            if (menuMusicPlaying) return;
            initAudio();
            if (!audioCtx) return;

            // Create master gain for menu music
            menuMusicGain = audioCtx.createGain();
            menuMusicGain.connect(audioCtx.destination);
            menuMusicGain.gain.setValueAtTime(1, audioCtx.currentTime);

            menuMusicPlaying = true;
            menuBeat = 0;
            menuNoteIndex = 0;
            menuArpIndex = 0;
            menuScheduledTime = audioCtx.currentTime + 0.1;

            menuMusicInterval = setInterval(() => {
                if (!audioCtx || !menuMusicPlaying) return;
                const now = audioCtx.currentTime;

                // Schedule melody notes ahead
                while (menuScheduledTime < now + 0.2) {
                    const noteData = menuMelody[menuNoteIndex % menuMelody.length];

                    if (noteData.note > 0) {
                        // Main melody - warm square wave with vibrato
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const vibrato = audioCtx.createOscillator();
                        const vibratoGain = audioCtx.createGain();

                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);
                        osc.connect(gain);
                        gain.connect(menuMusicGain);

                        osc.type = 'square';
                        osc.frequency.setValueAtTime(noteData.note, menuScheduledTime);
                        vibrato.frequency.setValueAtTime(5, menuScheduledTime); // slow vibrato
                        vibratoGain.gain.setValueAtTime(3, menuScheduledTime);

                        gain.gain.setValueAtTime(0.07, menuScheduledTime);
                        gain.gain.setValueAtTime(0.09, menuScheduledTime + 0.02); // slight attack
                        gain.gain.exponentialRampToValueAtTime(0.01, menuScheduledTime + noteData.dur * 0.95);

                        osc.start(menuScheduledTime);
                        vibrato.start(menuScheduledTime);
                        osc.stop(menuScheduledTime + noteData.dur);
                        vibrato.stop(menuScheduledTime + noteData.dur);

                        // Ethereal pad (sine wave, fifth above) - creates space
                        if (noteData.dur > 0.25) {
                            const pad = audioCtx.createOscillator();
                            const padGain = audioCtx.createGain();
                            pad.connect(padGain);
                            padGain.connect(menuMusicGain);
                            pad.type = 'sine';
                            pad.frequency.setValueAtTime(noteData.note * 1.5, menuScheduledTime); // fifth
                            padGain.gain.setValueAtTime(0.03, menuScheduledTime);
                            padGain.gain.exponentialRampToValueAtTime(0.005, menuScheduledTime + noteData.dur);
                            pad.start(menuScheduledTime);
                            pad.stop(menuScheduledTime + noteData.dur);
                        }

                        // Sub bass following melody (octave below)
                        const sub = audioCtx.createOscillator();
                        const subGain = audioCtx.createGain();
                        sub.connect(subGain);
                        subGain.connect(menuMusicGain);
                        sub.type = 'sine';
                        sub.frequency.setValueAtTime(noteData.note / 2, menuScheduledTime);
                        subGain.gain.setValueAtTime(0.04, menuScheduledTime);
                        subGain.gain.exponentialRampToValueAtTime(0.01, menuScheduledTime + noteData.dur * 0.7);
                        sub.start(menuScheduledTime);
                        sub.stop(menuScheduledTime + noteData.dur);
                    }

                    menuScheduledTime += noteData.dur;
                    menuNoteIndex++;
                }

                // Arpeggio layer - constant motion like rotor blades
                if (menuBeat % 2 === 0) {
                    const arpNote = menuArpeggio[menuArpIndex % menuArpeggio.length];
                    const arp = audioCtx.createOscillator();
                    const arpGain = audioCtx.createGain();
                    arp.connect(arpGain);
                    arpGain.connect(menuMusicGain);
                    arp.type = 'triangle';
                    arp.frequency.setValueAtTime(arpNote, now);
                    arpGain.gain.setValueAtTime(0.025, now);
                    arpGain.gain.exponentialRampToValueAtTime(0.005, now + 0.12);
                    arp.start(now);
                    arp.stop(now + 0.12);
                    menuArpIndex++;
                }

                // Deep kick drum - heartbeat
                if (menuBeat % 8 === 0) {
                    const kick = audioCtx.createOscillator();
                    const kickGain = audioCtx.createGain();
                    kick.connect(kickGain);
                    kickGain.connect(menuMusicGain);
                    kick.type = 'sine';
                    kick.frequency.setValueAtTime(100, now);
                    kick.frequency.exponentialRampToValueAtTime(30, now + 0.15);
                    kickGain.gain.setValueAtTime(0.2, now);
                    kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    kick.start(now);
                    kick.stop(now + 0.2);
                }

                // Secondary kick for drive
                if (menuBeat % 8 === 4) {
                    const kick2 = audioCtx.createOscillator();
                    const kick2Gain = audioCtx.createGain();
                    kick2.connect(kick2Gain);
                    kick2Gain.connect(menuMusicGain);
                    kick2.type = 'sine';
                    kick2.frequency.setValueAtTime(80, now);
                    kick2.frequency.exponentialRampToValueAtTime(35, now + 0.1);
                    kick2Gain.gain.setValueAtTime(0.12, now);
                    kick2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                    kick2.start(now);
                    kick2.stop(now + 0.12);
                }

                // Bass line - the foundation
                const bassNote = menuBassPattern[menuBeat % menuBassPattern.length];
                if (bassNote > 0) {
                    const bassLine = audioCtx.createOscillator();
                    const bassLineGain = audioCtx.createGain();
                    bassLine.connect(bassLineGain);
                    bassLineGain.connect(menuMusicGain);
                    bassLine.type = 'sawtooth';
                    bassLine.frequency.setValueAtTime(bassNote, now);
                    bassLineGain.gain.setValueAtTime(0.06, now);
                    bassLineGain.gain.exponentialRampToValueAtTime(0.01, now + 0.14);
                    bassLine.start(now);
                    bassLine.stop(now + 0.14);
                }

                // Hi-hat - lighter, more musical pattern
                if (menuBeat % 4 === 1 || menuBeat % 4 === 3) {
                    const hat = audioCtx.createOscillator();
                    const hatGain = audioCtx.createGain();
                    hat.connect(hatGain);
                    hatGain.connect(menuMusicGain);
                    hat.type = 'square';
                    hat.frequency.setValueAtTime(800 + Math.random() * 600, now);
                    hatGain.gain.setValueAtTime(0.015, now);
                    hatGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                    hat.start(now);
                    hat.stop(now + 0.04);
                }

                // Snare with more body
                if (menuBeat % 16 === 8 || menuBeat % 16 === 12) {
                    // Snare body
                    const snareBody = audioCtx.createOscillator();
                    const snareGain = audioCtx.createGain();
                    snareBody.connect(snareGain);
                    snareGain.connect(menuMusicGain);
                    snareBody.type = 'triangle';
                    snareBody.frequency.setValueAtTime(180, now);
                    snareBody.frequency.exponentialRampToValueAtTime(100, now + 0.08);
                    snareGain.gain.setValueAtTime(0.1, now);
                    snareGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                    snareBody.start(now);
                    snareBody.stop(now + 0.12);

                    // Snare noise
                    const snareNoise = audioCtx.createOscillator();
                    const snareNoiseGain = audioCtx.createGain();
                    snareNoise.connect(snareNoiseGain);
                    snareNoiseGain.connect(menuMusicGain);
                    snareNoise.type = 'sawtooth';
                    snareNoise.frequency.setValueAtTime(300, now);
                    snareNoiseGain.gain.setValueAtTime(0.04, now);
                    snareNoiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    snareNoise.start(now);
                    snareNoise.stop(now + 0.08);
                }

                // Occasional crash for drama
                if (menuBeat % 64 === 0 && menuBeat > 0) {
                    const crash = audioCtx.createOscillator();
                    const crashGain = audioCtx.createGain();
                    crash.connect(crashGain);
                    crashGain.connect(menuMusicGain);
                    crash.type = 'sawtooth';
                    crash.frequency.setValueAtTime(400, now);
                    crash.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    crashGain.gain.setValueAtTime(0.05, now);
                    crashGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                    crash.start(now);
                    crash.stop(now + 0.6);
                }

                menuBeat++;
            }, 110); // ~136 BPM - slightly faster, more energetic
        }

        function stopMenuMusic() {
            menuMusicPlaying = false;
            if (menuMusicInterval) {
                clearInterval(menuMusicInterval);
                menuMusicInterval = null;
            }
            // Immediately silence and disconnect menu music
            if (menuMusicGain) {
                menuMusicGain.gain.setValueAtTime(0, audioCtx ? audioCtx.currentTime : 0);
                menuMusicGain.disconnect();
                menuMusicGain = null;
            }
            updateMenuMusicButton();
        }

        function toggleMenuMusic() {
            if (menuMusicPlaying) {
                stopMenuMusic();
                localStorage.setItem('menuMusicOn', 'false');
            } else {
                playMenuMusic();
                localStorage.setItem('menuMusicOn', 'true');
            }
            updateMenuMusicButton();
        }

        function updateMenuMusicButton() {
            const btn = document.getElementById('menuMusicBtn');
            if (btn) {
                btn.textContent = menuMusicPlaying ? 'üéµ ON' : 'üéµ OFF';
                if (menuMusicPlaying) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        // ============ MULTIPLAYER (WebRTC) ============
        let isMultiplayer = false;
        let isHost = false;
        let peerConnection = null;
        let dataChannel = null;
        let connectionReady = false;
        let playerNickname = localStorage.getItem('playerNickname') || 'Player';
        let remotePlayer = {
            x: 600, y: 300,
            nickname: 'Player 2',
            animFrame: 0,
            bullets: [],
            lives: 3,
            score: 0,
            dead: false,
            respawnTimer: 0,
            invincible: 0
        };

        // WebRTC config with STUN servers for NAT traversal
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        function sendMP(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function initWebRTC(asHost) {
            isHost = asHost;

            // Close existing connection if any
            if (peerConnection) {
                peerConnection.close();
            }

            peerConnection = new RTCPeerConnection(rtcConfig);

            peerConnection.onicecandidate = (e) => {
                console.log('ICE candidate:', e.candidate ? 'found' : 'gathering complete');
                if (e.candidate === null) {
                    // ICE gathering complete - show the full offer/answer
                    const desc = peerConnection.localDescription;
                    const code = btoa(JSON.stringify(desc));
                    console.log('Generated code type:', desc.type, 'isHost:', isHost, 'state:', peerConnection.signalingState);
                    if (isHost) {
                        document.getElementById('hostCode').textContent = code;
                        document.getElementById('hostCodeBox').style.display = 'block';
                    } else {
                        document.getElementById('guestCode').textContent = code;
                        document.getElementById('guestCodeBox').style.display = 'block';
                    }
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };

            peerConnection.onsignalingstatechange = () => {
                console.log('Signaling state:', peerConnection.signalingState);
            };

            peerConnection.ondatachannel = (e) => {
                dataChannel = e.channel;
                setupDataChannel();
            };

            if (isHost) {
                dataChannel = peerConnection.createDataChannel('game');
                setupDataChannel();
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                connectionReady = true;
                console.log('Data channel open!');
                // Send nickname
                sendMP({ type: 'nick', name: playerNickname });
                // If host, start game selection
                if (isHost) {
                    showHostLobby();
                } else {
                    showGuestLobby();
                }
            };

            dataChannel.onclose = () => {
                connectionReady = false;
                handleDisconnect();
            };

            dataChannel.onmessage = (e) => {
                receiveMP(JSON.parse(e.data));
            };
        }

        async function createRoom() {
            initWebRTC(true);
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log('Offer created, state:', peerConnection.signalingState);

            // Fallback: show code after 2 seconds even if ICE not complete
            setTimeout(() => {
                if (peerConnection && peerConnection.localDescription &&
                    document.getElementById('hostCodeBox').style.display === 'none') {
                    const desc = peerConnection.localDescription;
                    const code = btoa(JSON.stringify(desc));
                    document.getElementById('hostCode').textContent = code;
                    document.getElementById('hostCodeBox').style.display = 'block';
                    console.log('Showing offer (timeout fallback), state:', peerConnection.signalingState);
                }
            }, 2000);
        }

        async function joinWithCode() {
            let code = document.getElementById('joinCodeInput').value;
            // Remove all whitespace and newlines
            code = code.replace(/\s/g, '');
            if (!code) return;

            initWebRTC(false);
            try {
                const offer = JSON.parse(atob(code));
                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Answer created, state:', peerConnection.signalingState);

                // Fallback: show code after 2 seconds even if ICE not complete
                setTimeout(() => {
                    if (peerConnection && peerConnection.localDescription &&
                        document.getElementById('guestCodeBox').style.display === 'none') {
                        const desc = peerConnection.localDescription;
                        const code = btoa(JSON.stringify(desc));
                        document.getElementById('guestCode').textContent = code;
                        document.getElementById('guestCodeBox').style.display = 'block';
                        console.log('Showing answer (timeout fallback), state:', peerConnection.signalingState);
                    }
                }, 2000);
            } catch (e) {
                console.error('Join code error:', e);
                alert('Invalid code! Make sure you copied the entire code.');
            }
        }

        async function connectWithAnswer() {
            let code = document.getElementById('answerCodeInput').value;
            // Remove all whitespace and newlines
            code = code.replace(/\s/g, '');
            if (!code) return;

            try {
                // Check if peerConnection is in correct state
                if (!peerConnection) {
                    alert('Connection lost! Please start over.');
                    backToMultiplayerMenu();
                    return;
                }

                console.log('Connection state:', peerConnection.signalingState);

                if (peerConnection.signalingState !== 'have-local-offer') {
                    alert('Connection expired. Please create a new room.');
                    backToMultiplayerMenu();
                    return;
                }

                const answer = JSON.parse(atob(code));
                await peerConnection.setRemoteDescription(answer);
                console.log('Answer set successfully!');
                // Connection should establish automatically
            } catch (e) {
                console.error('Answer code error:', e);
                alert('Invalid answer code! Make sure you copied the entire code.');
            }
        }

        function handleDisconnect() {
            if (isMultiplayer) {
                isMultiplayer = false;
                connectionReady = false;
                if (gameRunning) {
                    // Show disconnect message
                    floatingTexts.push({
                        x: canvas.width / 2, y: canvas.height / 2,
                        text: 'PLAYER DISCONNECTED', color: '#f00', life: 180, size: 16
                    });
                }
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                dataChannel = null;
            }
        }

        // Receive multiplayer messages
        function receiveMP(data) {
            switch (data.type) {
                case 'nick':
                    remotePlayer.nickname = data.name;
                    break;
                case 'pos':
                    remotePlayer.x = data.x;
                    remotePlayer.y = data.y;
                    remotePlayer.animFrame = data.anim;
                    remotePlayer.invincible = data.inv || 0;
                    break;
                case 'shoot':
                    // Add remote player's bullet
                    remotePlayer.bullets.push({
                        x: data.x, y: data.y,
                        speed: data.speed || 12,
                        damage: data.dmg || 1
                    });
                    playSound('shoot');
                    break;
                case 'state':
                    remotePlayer.lives = data.lives;
                    remotePlayer.score = data.score;
                    remotePlayer.dead = data.dead;
                    remotePlayer.respawnTimer = data.respawn || 0;
                    break;
                case 'start':
                    // Host started the game
                    if (!isHost) {
                        startMultiplayerGame(data.diff);
                    }
                    break;
                case 'enemies':
                    // Guest receives enemy data from host
                    if (!isHost) {
                        syncEnemiesFromHost(data.enemies);
                    }
                    break;
                case 'damage':
                    // Sync enemy damage
                    const enemy = enemies.find(e => e.id === data.id);
                    if (enemy) {
                        enemy.health -= data.dmg;
                    }
                    break;
                case 'kill':
                    // Remote player killed an enemy
                    enemies = enemies.filter(e => e.id !== data.id);
                    createExplosion(data.x, data.y, true);
                    playSound('explosion');
                    break;
                case 'powerup':
                    // Host spawned powerup
                    if (!isHost) {
                        powerups.push({
                            x: data.x, y: data.y,
                            type: data.ptype,
                            id: data.id
                        });
                    }
                    break;
                case 'level':
                    if (!isHost) {
                        level = data.level;
                        if (data.biome) switchBiome(data.biome);
                    }
                    break;
            }
        }

        function syncEnemiesFromHost(enemyData) {
            // Update enemies from host data
            enemyData.forEach(ed => {
                let enemy = enemies.find(e => e.id === ed.id);
                if (!enemy) {
                    // Create new enemy
                    enemy = createEnemy(ed.type);
                    enemy.id = ed.id;
                    enemies.push(enemy);
                }
                enemy.x = ed.x;
                enemy.y = ed.y;
                enemy.health = ed.hp;
            });
            // Remove enemies not in host data
            const hostIds = enemyData.map(e => e.id);
            enemies = enemies.filter(e => hostIds.includes(e.id));
        }

        let mpSendTimer = 0;
        let enemySyncTimer = 0;
        let enemyIdCounter = 0;

        function updateMultiplayer() {
            if (!isMultiplayer || !connectionReady) return;

            // Send position every frame
            sendMP({
                type: 'pos',
                x: Math.round(player.x),
                y: Math.round(player.y),
                anim: player.animFrame,
                inv: player.invincible
            });

            // Send state periodically
            mpSendTimer++;
            if (mpSendTimer >= 60) {
                mpSendTimer = 0;
                sendMP({
                    type: 'state',
                    lives: lives,
                    score: score,
                    dead: lives <= 0,
                    respawn: respawnTimer
                });
            }

            // Host syncs enemies
            if (isHost) {
                enemySyncTimer++;
                if (enemySyncTimer >= 6) { // ~10 times per second
                    enemySyncTimer = 0;
                    const enemyData = enemies.map(e => ({
                        id: e.id,
                        type: e.type,
                        x: Math.round(e.x),
                        y: Math.round(e.y),
                        hp: e.health
                    }));
                    sendMP({ type: 'enemies', enemies: enemyData });
                }
            }

            // Update remote player bullets
            remotePlayer.bullets = remotePlayer.bullets.filter(b => {
                b.x += b.speed;
                // Check hits on enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (b.x > enemy.x && b.x < enemy.x + enemy.width &&
                        b.y > enemy.y && b.y < enemy.y + enemy.height) {
                        enemy.health -= b.damage;
                        if (enemy.health <= 0) {
                            // Remote player gets the kill
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, true);
                            enemies.splice(i, 1);
                            playSound('explosion');
                        }
                        return false;
                    }
                }
                return b.x < canvas.width + 20;
            });

            // Respawn mechanic
            if (lives <= 0 && !remotePlayer.dead) {
                respawnTimer = (respawnTimer || 0) + 1;
                if (respawnTimer >= 600) { // 10 seconds
                    lives = 1;
                    respawnTimer = 0;
                    player.invincible = 180; // 3 sec invincibility
                    player.x = 100;
                    player.y = canvas.height / 2;
                    floatingTexts.push({
                        x: player.x, y: player.y - 30,
                        text: 'RESPAWNED!', color: '#0f0', life: 60, size: 14
                    });
                }
            }

            // Check if both dead = game over
            if (lives <= 0 && remotePlayer.dead) {
                gameOver();
            }
        }

        let respawnTimer = 0;

        function drawRemotePlayer() {
            if (!isMultiplayer || !connectionReady) return;

            ctx.save();

            // Draw remote player
            if (!remotePlayer.dead) {
                // Flicker if invincible
                if (remotePlayer.invincible > 0 && frame % 6 < 3) {
                    ctx.globalAlpha = 0.5;
                }

                ctx.translate(remotePlayer.x + 32, remotePlayer.y + 16);

                // Different color tint for player 2
                ctx.fillStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 10;

                // Draw helicopter sprite (use same sprite but tinted)
                ctx.drawImage(sprites.helicopter,
                    remotePlayer.animFrame * 96, 0, 96, 48,
                    -32, -16, 64, 32);

                ctx.shadowBlur = 0;

                // Draw nickname above
                ctx.fillStyle = '#0ff';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(remotePlayer.nickname, 0, -25);

                // Draw lives
                ctx.fillText('‚ô•'.repeat(Math.max(0, remotePlayer.lives)), 0, -15);

                ctx.globalAlpha = 1;
            } else {
                // Show respawn timer
                ctx.fillStyle = '#888';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                const timeLeft = Math.ceil((600 - (remotePlayer.respawnTimer || 0)) / 60);
                ctx.fillText(remotePlayer.nickname + ' respawning in ' + timeLeft + 's', remotePlayer.x, remotePlayer.y);
            }

            ctx.restore();

            // Draw remote player bullets
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 8;
            remotePlayer.bullets.forEach(b => {
                ctx.fillRect(b.x - 6, b.y - 2, 12, 4);
            });
            ctx.shadowBlur = 0;
        }

        function startMultiplayerGame(diff) {
            isMultiplayer = true;
            stopMenuMusic();
            hideAllScreens();
            startGame(diff);
        }

        function showHostLobby() {
            hideAllScreens();
            document.getElementById('hostLobbyScreen').style.display = 'flex';
            document.getElementById('connectedPlayer').textContent = remotePlayer.nickname;
        }

        function showGuestLobby() {
            hideAllScreens();
            document.getElementById('guestLobbyScreen').style.display = 'flex';
            document.getElementById('hostPlayerName').textContent = remotePlayer.nickname;
        }

        function hostStartGame(diff) {
            sendMP({ type: 'start', diff: diff });
            startMultiplayerGame(diff);
        }

        function hideAllScreens() {
            ['startScreen', 'multiplayerScreen', 'createRoomScreen', 'joinRoomScreen',
             'hostLobbyScreen', 'guestLobbyScreen', 'gameOverScreen', 'pauseScreen'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
        }

        function showMultiplayerMenu() {
            stopMenuMusic();
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('multiplayerScreen').style.display = 'flex';
            document.getElementById('nicknameInput').value = playerNickname;
        }

        function saveNickname() {
            playerNickname = document.getElementById('nicknameInput').value.trim() || 'Player';
            localStorage.setItem('playerNickname', playerNickname);
        }

        function showCreateRoom() {
            saveNickname();
            document.getElementById('multiplayerScreen').style.display = 'none';
            document.getElementById('createRoomScreen').style.display = 'flex';
            document.getElementById('hostCodeBox').style.display = 'none';
            createRoom();
        }

        function showJoinRoom() {
            saveNickname();
            document.getElementById('multiplayerScreen').style.display = 'none';
            document.getElementById('joinRoomScreen').style.display = 'flex';
            document.getElementById('guestCodeBox').style.display = 'none';
        }

        function copyCode(elementId) {
            const text = document.getElementById(elementId).textContent;
            navigator.clipboard.writeText(text).then(() => {
                floatingTexts.push({
                    x: canvas.width/2, y: canvas.height/2,
                    text: 'COPIED!', color: '#0f0', life: 60, size: 12
                });
            });
        }

        function backToMultiplayerMenu() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            dataChannel = null;
            connectionReady = false;
            hideAllScreens();
            document.getElementById('multiplayerScreen').style.display = 'flex';
        }

        function backToMainMenu() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            dataChannel = null;
            connectionReady = false;
            isMultiplayer = false;
            hideAllScreens();
            document.getElementById('startScreen').style.display = 'flex';
        }

        // ============ SPRITES ============
        const sprites = { helicopter: new Image(), explosion: new Image() };
        let spritesLoaded = 0;
        sprites.helicopter.onload = () => spritesLoaded++;
        sprites.explosion.onload = () => spritesLoaded++;
        sprites.helicopter.src = 'sprites/helicopter.png';
        sprites.explosion.src = 'sprites/explosion.png';

        // ============ GAME CONFIG ============
        const difficulties = {
            easy: { lives: 5, enemySpawnRate: 2500, enemySpeed: 0.7, playerSpeed: 6, scoreMultiplier: 0.5 },
            normal: { lives: 3, enemySpawnRate: 2000, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 1 },
            hard: { lives: 2, enemySpawnRate: 1500, enemySpeed: 1.3, playerSpeed: 5, scoreMultiplier: 1.5 },
            legendary: { lives: 1, enemySpawnRate: 1200, enemySpeed: 1.5, playerSpeed: 5.5, scoreMultiplier: 3 },
            endless: { lives: 3, enemySpawnRate: 2000, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 2, endless: true },
            bossrush: { lives: 5, enemySpawnRate: 99999, enemySpeed: 1, playerSpeed: 5, scoreMultiplier: 2, bossRush: true }
        };

        // ============ GAME STATE ============
        let gameRunning = false;
        let paused = false;
        let difficulty = 'normal';
        let gameMode = 'normal';
        let score = 0;
        let lives = 3;
        let lastDisplayedLives = 3;
        let level = 1;
        let enemySpawnRate = 2000;
        let lastEnemySpawn = 0;
        let frame = 0;
        let screenShake = 0;
        let bombs = 3;
        let killStreak = 0;
        let killStreakTimer = 0;

        // Slow motion
        let slowMotion = 0;
        let slowMotionFactor = 1;

        // ============ MEGA UPGRADE SYSTEMS ============
        // Coins & Economy
        let coins = 0;
        let totalKills = 0;
        let maxLives = 3;
        let permanentFireRate = 0;
        let permanentDamage = 0;
        let luckBonus = 0;

        // Ultimate system
        let ultCharge = 0;
        let ultActive = null;
        let ultTimer = 0;
        let flashColor = null;
        let flashAlpha = 0;
        let distortion = 0;

        // Helicopters
        const HELICOPTERS = {
            classic: { name: 'CLASSIC', maxLives: 3, speed: 5, damage: 1, ultimate: 'nuke', ultDuration: 1, color: '#0f0', desc: 'Balanced fighter' },
            tank: { name: 'TANK', maxLives: 5, speed: 3, damage: 0.8, ultimate: 'godMode', ultDuration: 600, color: '#48f', desc: 'Slow but tough' },
            speeder: { name: 'SPEEDER', maxLives: 2, speed: 8, damage: 1, ultimate: 'bulletTime', ultDuration: 300, color: '#f0f', desc: 'Fast and agile' },
            glassCannon: { name: 'GLASS CANNON', maxLives: 1, speed: 5, damage: 2.5, ultimate: 'nuke', ultDuration: 1, color: '#f00', desc: 'High risk high reward' },
            vampire: { name: 'VAMPIRE', maxLives: 2, speed: 5, damage: 1, ultimate: 'godMode', ultDuration: 300, color: '#808', special: 'lifesteal', desc: 'Heals on kills' }
        };
        let currentHelicopter = 'classic';
        let unlockedHelicopters = ['classic', 'tank', 'speeder', 'glassCannon', 'vampire'];

        // Shop items
        const SHOP_ITEMS = [
            { id: 'life', name: '+1 LIFE', cost: 100, icon: '‚ù§Ô∏è' },
            { id: 'bombs', name: '+3 BOMBS', cost: 50, icon: 'üí£' },
            { id: 'maxhp', name: 'MAX HP+', cost: 200, icon: 'üíñ' },
            { id: 'firerate', name: 'FIRE RATE', cost: 150, icon: '‚ö°' },
            { id: 'damage', name: 'DAMAGE+', cost: 150, icon: 'üí•' },
            { id: 'magnet', name: 'MAGNET', cost: 100, icon: 'üß≤' },
            { id: 'lucky', name: 'LUCKY', cost: 200, icon: 'üçÄ' }
        ];

        // ============ PROGRESSION SYSTEM ============
        // Player Data
        let playerData = {
            xp: 0,
            level: 1,
            totalXP: 0,
            prestigeLevel: 0,
            prestigeMultiplier: 1
        };
        let totalCoins = 0;
        let purchasedUpgrades = {};
        let unlockedSkills = {};
        let prestigeSkins = {};

        const MAX_PLAYER_LEVEL = 15;
        const XP_TABLE = [0, 100, 250, 500, 800, 1200, 1700, 2300, 3000, 4000, 5200, 6600, 8200, 10000, 12500];

        // Permanent Upgrades
        const PERMANENT_UPGRADES = {
            offense_damage: { id: 'offense_damage', name: 'DAMAGE BOOST', icon: 'üí•', category: 'offense', maxLevel: 10, costBase: 50, costScale: 1.5, effect: (lvl) => ({ damageBonus: lvl * 0.05 }), desc: (lvl) => `+${lvl * 5}% Damage` },
            offense_firerate: { id: 'offense_firerate', name: 'RAPID FIRE', icon: '‚ö°', category: 'offense', maxLevel: 10, costBase: 60, costScale: 1.5, effect: (lvl) => ({ fireRateBonus: lvl * 0.08 }), desc: (lvl) => `+${lvl * 8}% Fire Rate` },
            offense_crit: { id: 'offense_crit', name: 'CRITICAL HITS', icon: 'üéØ', category: 'offense', maxLevel: 5, costBase: 100, costScale: 2, effect: (lvl) => ({ critChance: lvl * 0.05, critDamage: 1.5 + lvl * 0.1 }), desc: (lvl) => `${lvl * 5}% Crit, ${150 + lvl * 10}% Dmg` },
            defense_health: { id: 'defense_health', name: 'EXTRA LIVES', icon: '‚ù§Ô∏è', category: 'defense', maxLevel: 3, costBase: 200, costScale: 2.5, effect: (lvl) => ({ extraLives: lvl }), desc: (lvl) => `+${lvl} Starting Lives` },
            defense_shield: { id: 'defense_shield', name: 'SHIELD BOOST', icon: 'üõ°Ô∏è', category: 'defense', maxLevel: 10, costBase: 40, costScale: 1.4, effect: (lvl) => ({ shieldBonus: lvl * 0.1 }), desc: (lvl) => `+${lvl * 10}% Shield Duration` },
            defense_armor: { id: 'defense_armor', name: 'ARMOR', icon: 'üî∞', category: 'defense', maxLevel: 5, costBase: 150, costScale: 1.8, effect: (lvl) => ({ armorFrames: lvl * 10 }), desc: (lvl) => `+${lvl * 10} Invincibility Frames` },
            utility_magnet: { id: 'utility_magnet', name: 'COIN MAGNET', icon: 'üß≤', category: 'utility', maxLevel: 10, costBase: 30, costScale: 1.3, effect: (lvl) => ({ magnetRange: 50 + lvl * 20 }), desc: (lvl) => `Magnet: ${50 + lvl * 20}px` },
            utility_xp: { id: 'utility_xp', name: 'XP BOOST', icon: 'üìà', category: 'utility', maxLevel: 10, costBase: 80, costScale: 1.6, effect: (lvl) => ({ xpBonus: lvl * 0.1 }), desc: (lvl) => `+${lvl * 10}% XP` },
            utility_coins: { id: 'utility_coins', name: 'COIN BOOST', icon: 'ü™ô', category: 'utility', maxLevel: 10, costBase: 70, costScale: 1.5, effect: (lvl) => ({ coinBonus: lvl * 0.15 }), desc: (lvl) => `+${lvl * 15}% Coins` },
            utility_luck: { id: 'utility_luck', name: 'LUCKY DROPS', icon: 'üçÄ', category: 'utility', maxLevel: 5, costBase: 120, costScale: 2, effect: (lvl) => ({ luckBonus: lvl * 0.1 }), desc: (lvl) => `+${lvl * 10}% Powerup Drop` }
        };

        // Skill Tree
        const SKILL_TREE = {
            attack_doubleshot: { id: 'attack_doubleshot', name: 'DOUBLE SHOT', icon: 'üî´', branch: 'attack', tier: 1, requiredLevel: 3, requires: [], effect: { doubleShot: true }, desc: 'Fire 2 bullets at once' },
            attack_explosive: { id: 'attack_explosive', name: 'EXPLOSIVE', icon: 'üí£', branch: 'attack', tier: 2, requiredLevel: 6, requires: ['attack_doubleshot'], effect: { explosiveRounds: true, explosionRadius: 30 }, desc: 'Bullets explode' },
            attack_pierce: { id: 'attack_pierce', name: 'PIERCING', icon: 'üó°Ô∏è', branch: 'attack', tier: 2, requiredLevel: 6, requires: ['attack_doubleshot'], effect: { piercingShots: 2 }, desc: 'Pierce 2 enemies' },
            attack_berserk: { id: 'attack_berserk', name: 'BERSERK', icon: 'üòà', branch: 'attack', tier: 3, requiredLevel: 10, requires: ['attack_explosive', 'attack_pierce'], effect: { berserkMode: true }, desc: '+50% dmg at 1 HP' },
            defense_regen: { id: 'defense_regen', name: 'REGEN', icon: 'üíö', branch: 'defense', tier: 1, requiredLevel: 3, requires: [], effect: { regenRate: 0.0005 }, desc: 'Slowly heal' },
            defense_reflect: { id: 'defense_reflect', name: 'REFLECT', icon: 'üîÑ', branch: 'defense', tier: 2, requiredLevel: 7, requires: ['defense_regen'], effect: { reflectChance: 0.15 }, desc: '15% bullet reflect' },
            defense_laststand: { id: 'defense_laststand', name: 'LAST STAND', icon: '‚≠ê', branch: 'defense', tier: 2, requiredLevel: 7, requires: ['defense_regen'], effect: { lastStand: true }, desc: 'Survive fatal hit once' },
            defense_fortress: { id: 'defense_fortress', name: 'FORTRESS', icon: 'üè∞', branch: 'defense', tier: 3, requiredLevel: 12, requires: ['defense_reflect', 'defense_laststand'], effect: { fortressStart: true }, desc: '3s invincibility/level' },
            utility_drone: { id: 'utility_drone', name: 'DRONE', icon: 'ü§ñ', branch: 'utility', tier: 1, requiredLevel: 4, requires: [], effect: { startWithDrone: true }, desc: 'Start with drone' },
            utility_bombs: { id: 'utility_bombs', name: 'BOMB EXPERT', icon: 'üí£', branch: 'utility', tier: 2, requiredLevel: 8, requires: ['utility_drone'], effect: { extraBombs: 2, bombRadius: 1.5 }, desc: '+2 bombs, +50% radius' },
            utility_ult: { id: 'utility_ult', name: 'ULT MASTER', icon: '‚ö°', branch: 'utility', tier: 2, requiredLevel: 8, requires: ['utility_drone'], effect: { ultChargeRate: 1.5 }, desc: '50% faster ult charge' },
            utility_godlike: { id: 'utility_godlike', name: 'GODLIKE', icon: 'üëë', branch: 'utility', tier: 3, requiredLevel: 15, requires: ['utility_bombs', 'utility_ult'], effect: { godlike: true }, desc: '+50% powerup duration' }
        };

        // Prestige Config
        const PRESTIGE_CONFIG = {
            minLevel: 10,
            bonusPerPrestige: 0.1,
            maxPrestige: 10,
            skins: {
                1: { id: 'prestige_bronze', name: 'Bronze Star', colors: ['#cd7f32', '#a0522d', '#8b4513'] },
                3: { id: 'prestige_silver', name: 'Silver Star', colors: ['#c0c0c0', '#a8a8a8', '#909090'] },
                5: { id: 'prestige_gold', name: 'Gold Star', colors: ['#ffd700', '#ffb700', '#ff9700'] },
                7: { id: 'prestige_platinum', name: 'Platinum', colors: ['#e5e4e2', '#d4d4d4', '#c0c0c0'] },
                10: { id: 'prestige_diamond', name: 'Diamond', colors: ['#b9f2ff', '#87ceeb', '#add8e6'], special: 'sparkle' }
            }
        };

        // Weather
        let weather = { rain: [], lightning: 0, thunderTimer: 0 };

        // Biomes system
        const BIOMES = {
            city: {
                name: 'CITY',
                skyTop: '#1a0a2e',
                skyBottom: '#ff6b35',
                groundColor: '#1a1a2e',
                glowColor: '#f80',
                obstacles: ['drone_cam', 'billboard'],
                weather: 'smog'
            },
            ocean: {
                name: 'OCEAN',
                skyTop: '#0a2a4a',
                skyBottom: '#2a6a8a',
                groundColor: '#0a3a5a',
                glowColor: '#0af',
                obstacles: ['mine', 'iceberg'],
                weather: 'storm'
            },
            desert: {
                name: 'DESERT',
                skyTop: '#4a2a0a',
                skyBottom: '#ffa040',
                groundColor: '#c9a030',
                glowColor: '#fa0',
                obstacles: ['sandstorm_obj', 'cactus'],
                weather: 'sandstorm'
            },
            space: {
                name: 'SPACE',
                skyTop: '#000010',
                skyBottom: '#000030',
                groundColor: '#101020',
                glowColor: '#f0f',
                obstacles: ['asteroid', 'satellite'],
                weather: 'meteors'
            }
        };
        let currentBiome = 'city';
        let obstacles = [];
        let biomeBuildings = [];
        let biomeTransition = 0;

        function getBiomeForLevel(lvl) {
            if (lvl <= 5) return 'city';
            if (lvl <= 10) return 'ocean';
            if (lvl <= 15) return 'desert';
            return 'space';
        }

        function switchBiome(biomeName) {
            if (currentBiome === biomeName) return;
            currentBiome = biomeName;
            biomeTransition = 60;
            obstacles = [];
            initBiomeBackground();

            // Show biome name
            if (floatingTexts) {
                floatingTexts.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    text: '‚òÖ ' + BIOMES[biomeName].name + ' ZONE ‚òÖ',
                    color: BIOMES[biomeName].glowColor,
                    life: 120,
                    size: 28
                });
            }
        }

        function initBiomeBackground() {
            biomeBuildings = [];
            if (currentBiome === 'city') {
                // Generate city buildings
                for (let i = 0; i < 15; i++) {
                    biomeBuildings.push({
                        x: i * 120 + Math.random() * 40,
                        width: 40 + Math.random() * 60,
                        height: 100 + Math.random() * 200,
                        windows: [],
                        speed: 0.2 + Math.random() * 0.3
                    });
                    // Pre-generate window lights
                    const b = biomeBuildings[biomeBuildings.length - 1];
                    for (let wy = 10; wy < b.height - 10; wy += 25) {
                        for (let wx = 8; wx < b.width - 8; wx += 18) {
                            b.windows.push({
                                x: wx,
                                y: wy,
                                lit: Math.random() > 0.3
                            });
                        }
                    }
                }
            }
        }

        // Combo system
        let combo = 0;
        let comboTimer = 0;
        let comboMultiplier = 1;

        // Weapons
        let currentWeapon = 'normal';
        let laserCharge = 100;
        let laserActive = false;
        let rocketAmmo = 5;
        let plasmaCharge = 0;

        // Perks/Upgrades
        let perks = {
            fireRate: 0,
            damage: 0,
            speed: 0,
            magnet: 0,
            doubleScore: false
        };

        // Boss
        let boss = null;
        let bossWarning = 0;
        let bossType = 0;

        // Power-ups
        let powerups = [];
        let activePowerups = { rapid: 0, spread: 0, shield: 0, timeslow: 0, drone: 0, piercing: 0, homing: 0, ghost: 0 };
        let playerDrone = null;

        // High scores
        let highScores = JSON.parse(localStorage.getItem('chopperLegendaryScores') || '[]');

        // Achievements system
        let achievements = JSON.parse(localStorage.getItem('chopperAchievements') || '{}');
        let gameStats = { droneKills: 0, ghostDodges: 0, collectedPowerups: new Set(), bossHitsTaken: 0, levelStartTime: 0 };

        const ACHIEVEMENTS = {
            first_blood: { name: 'First Blood', desc: 'Kill your first enemy', icon: 'ü©∏' },
            combo_10: { name: 'Combo Master', desc: 'Get 10+ combo', icon: 'üî•', reward: 'flame' },
            combo_25: { name: 'Unstoppable', desc: 'Get 25+ combo', icon: 'üí•', reward: 'neon' },
            boss_killer: { name: 'Boss Slayer', desc: 'Defeat a boss', icon: 'üíÄ', reward: 'military' },
            boss_no_hit: { name: 'Perfect Boss', desc: 'Kill boss without damage', icon: '‚≠ê', reward: 'stealth' },
            legendary_win: { name: 'Legend', desc: 'Reach level 10 on Legendary', icon: 'üëë', reward: 'gold' },
            bomb_multi: { name: 'Bomber', desc: 'Kill 5+ enemies with one bomb', icon: 'üí£' },
            emp_master: { name: 'EMP Expert', desc: 'Clear 20+ bullets with EMP', icon: '‚ö°' },
            drone_kills: { name: 'Drone Commander', desc: 'Drone kills 10 enemies', icon: 'ü§ñ' },
            score_100k: { name: 'Score Hunter', desc: 'Score 100,000 points', icon: 'üí∞', reward: 'chrome' },
            score_500k: { name: 'Score Legend', desc: 'Score 500,000 points', icon: 'üíé', reward: 'rainbow' },
            survivor: { name: 'Survivor', desc: 'Survive 5 min in Endless', icon: '‚è±Ô∏è' },
            speedrun: { name: 'Speedrunner', desc: 'Complete level in <30s', icon: 'üèÉ' },
            pacifist: { name: 'Close Call', desc: 'Dodge 50 bullets (ghost)', icon: 'üëª' },
            collector: { name: 'Collector', desc: 'Collect all powerup types', icon: 'üéÅ' }
        };

        // Skins system
        let unlockedSkins = JSON.parse(localStorage.getItem('chopperSkins') || '{"default": true}');
        let currentSkin = localStorage.getItem('chopperCurrentSkin') || 'default';

        const SKINS = {
            default:  { name: 'Classic',  colors: ['#0a0', '#080', '#060'], desc: 'Default helicopter' },
            flame:    { name: 'Flame',    colors: ['#f80', '#f40', '#c00'], desc: 'Combo Master reward' },
            neon:     { name: 'Neon',     colors: ['#f0f', '#80f', '#40f'], desc: 'Unstoppable reward' },
            military: { name: 'Military', colors: ['#654', '#543', '#432'], desc: 'Boss Slayer reward' },
            stealth:  { name: 'Stealth',  colors: ['#333', '#555', '#222'], desc: 'Perfect Boss reward' },
            gold:     { name: 'Gold',     colors: ['#fd0', '#fa0', '#c80'], desc: 'Legend reward' },
            chrome:   { name: 'Chrome',   colors: ['#ccc', '#aaa', '#888'], desc: 'Score Hunter reward' },
            rainbow:  { name: 'Rainbow',  colors: null, special: 'rainbow', desc: 'Score Legend reward' }
        };

        // ============ PROGRESSION FUNCTIONS ============
        function loadProgressionData() {
            try {
                const saved = localStorage.getItem('chopperPlayerData');
                if (saved) playerData = JSON.parse(saved);

                const savedUpgrades = localStorage.getItem('chopperPermanentUpgrades');
                if (savedUpgrades) purchasedUpgrades = JSON.parse(savedUpgrades);

                const savedSkills = localStorage.getItem('chopperSkillTree');
                if (savedSkills) unlockedSkills = JSON.parse(savedSkills);

                const savedCoins = localStorage.getItem('chopperTotalCoins');
                if (savedCoins) totalCoins = parseInt(savedCoins, 10);

                const savedPrestigeSkins = localStorage.getItem('chopperPrestigeSkins');
                if (savedPrestigeSkins) prestigeSkins = JSON.parse(savedPrestigeSkins);

                // Add prestige skins to SKINS
                Object.values(PRESTIGE_CONFIG.skins).forEach(skin => {
                    if (prestigeSkins[skin.id]) {
                        SKINS[skin.id] = skin;
                        unlockedSkins[skin.id] = true;
                    }
                });
            } catch(e) { console.log('Load progression error:', e); }
        }

        function saveProgressionData() {
            try {
                localStorage.setItem('chopperPlayerData', JSON.stringify(playerData));
                localStorage.setItem('chopperPermanentUpgrades', JSON.stringify(purchasedUpgrades));
                localStorage.setItem('chopperSkillTree', JSON.stringify(unlockedSkills));
                localStorage.setItem('chopperTotalCoins', totalCoins.toString());
                localStorage.setItem('chopperPrestigeSkins', JSON.stringify(prestigeSkins));
            } catch(e) { console.log('Save progression error:', e); }
        }

        // XP Functions
        function getXPForLevel(level) {
            if (level <= 1) return 0;
            if (level > MAX_PLAYER_LEVEL) return XP_TABLE[XP_TABLE.length - 1];
            return XP_TABLE[level - 1] || XP_TABLE[XP_TABLE.length - 1];
        }

        function addXP(amount) {
            const effects = getAllUpgradeEffects();
            const xpBonus = effects.xpBonus || 0;
            const totalXPGain = Math.floor(amount * (1 + xpBonus) * playerData.prestigeMultiplier);

            playerData.xp += totalXPGain;
            playerData.totalXP += totalXPGain;

            while (playerData.level < MAX_PLAYER_LEVEL) {
                const xpNeeded = getXPForLevel(playerData.level + 1);
                if (playerData.xp >= xpNeeded) {
                    playerData.xp -= xpNeeded;
                    playerData.level++;
                    onLevelUp();
                } else break;
            }
            saveProgressionData();
        }

        function onLevelUp() {
            playSound('powerup');
            floatingTexts.push({ x: canvas.width / 2, y: canvas.height / 2 - 100, text: `LEVEL ${playerData.level}!`, color: '#0ff', life: 120, size: 24 });
            const bonusCoins = playerData.level * 25;
            totalCoins += bonusCoins;
            floatingTexts.push({ x: canvas.width / 2, y: canvas.height / 2 - 60, text: `+${bonusCoins} COINS`, color: '#fd0', life: 90, size: 16 });
        }

        // Upgrade Functions
        function getUpgradeCost(upgradeId) {
            const upgrade = PERMANENT_UPGRADES[upgradeId];
            if (!upgrade) return Infinity;
            const currentLevel = purchasedUpgrades[upgradeId] || 0;
            if (currentLevel >= upgrade.maxLevel) return Infinity;
            return Math.floor(upgrade.costBase * Math.pow(upgrade.costScale, currentLevel));
        }

        function purchaseUpgrade(upgradeId) {
            const cost = getUpgradeCost(upgradeId);
            if (totalCoins < cost) return false;
            const upgrade = PERMANENT_UPGRADES[upgradeId];
            const currentLevel = purchasedUpgrades[upgradeId] || 0;
            if (currentLevel >= upgrade.maxLevel) return false;
            totalCoins -= cost;
            purchasedUpgrades[upgradeId] = currentLevel + 1;
            playSound('powerup');
            saveProgressionData();
            return true;
        }

        function getAllUpgradeEffects() {
            let effects = { damageBonus: 0, fireRateBonus: 0, critChance: 0, critDamage: 1, extraLives: 0, shieldBonus: 0, armorFrames: 0, magnetRange: 50, xpBonus: 0, coinBonus: 0, luckBonus: 0 };
            Object.entries(purchasedUpgrades).forEach(([id, level]) => {
                const upgrade = PERMANENT_UPGRADES[id];
                if (upgrade && level > 0) {
                    const effect = upgrade.effect(level);
                    Object.entries(effect).forEach(([key, value]) => {
                        if (typeof effects[key] === 'number') effects[key] += value;
                        else effects[key] = value;
                    });
                }
            });
            effects.damageBonus *= playerData.prestigeMultiplier;
            effects.fireRateBonus *= playerData.prestigeMultiplier;
            return effects;
        }

        // Skill Functions
        function canUnlockSkill(skillId) {
            const skill = SKILL_TREE[skillId];
            if (!skill || unlockedSkills[skillId]) return false;
            if (playerData.level < skill.requiredLevel) return false;
            for (const reqId of skill.requires) {
                if (!unlockedSkills[reqId]) return false;
            }
            return true;
        }

        function unlockSkill(skillId) {
            if (!canUnlockSkill(skillId)) return false;
            unlockedSkills[skillId] = true;
            playSound('powerup');
            floatingTexts.push({ x: canvas.width / 2, y: canvas.height / 2, text: `SKILL: ${SKILL_TREE[skillId].name}!`, color: '#f0f', life: 120, size: 20 });
            saveProgressionData();
            return true;
        }

        function getAllSkillEffects() {
            let effects = {};
            Object.entries(unlockedSkills).forEach(([id, unlocked]) => {
                if (unlocked && SKILL_TREE[id]) Object.assign(effects, SKILL_TREE[id].effect);
            });
            return effects;
        }

        function hasSkill(skillId) { return unlockedSkills[skillId] === true; }

        // Prestige Functions
        function canPrestige() {
            return playerData.level >= PRESTIGE_CONFIG.minLevel && playerData.prestigeLevel < PRESTIGE_CONFIG.maxPrestige;
        }

        function doPrestige() {
            if (!canPrestige()) return false;
            playerData.prestigeLevel++;
            playerData.prestigeMultiplier = 1 + (playerData.prestigeLevel * PRESTIGE_CONFIG.bonusPerPrestige);
            playerData.level = 1;
            playerData.xp = 0;
            unlockedSkills = {};

            const skinUnlock = PRESTIGE_CONFIG.skins[playerData.prestigeLevel];
            if (skinUnlock) {
                prestigeSkins[skinUnlock.id] = true;
                SKINS[skinUnlock.id] = skinUnlock;
                unlockedSkins[skinUnlock.id] = true;
                localStorage.setItem('chopperSkins', JSON.stringify(unlockedSkins));
            }
            playSound('combo');
            saveProgressionData();
            return true;
        }

        // Load progression on init
        loadProgressionData();

        const player = {
            x: 100, y: 300,
            width: 64, height: 32,
            speed: 5,
            bullets: [],
            rockets: [],
            plasma: [],
            lastShot: 0,
            shootCooldown: 180,
            animFrame: 0,
            invincible: 0,
            tilt: 0,
            fireLevel: 1
        };

        let enemies = [];
        let explosions = [];
        let particles = [];
        let floatingTexts = [];
        let shockwaves = [];
        let debris = [];

        // Background
        let stars = [];
        let clouds = [];
        let mountains = [];
        let trees = [];
        let neonGrid = [];

        function initBackground() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.6,
                    size: Math.random() < 0.1 ? 3 : Math.random() < 0.3 ? 2 : 1,
                    speed: Math.random() * 0.5 + 0.1,
                    twinkle: Math.random() * 100,
                    color: ['#fff', '#0ff', '#f0f', '#ff0'][Math.floor(Math.random() * 4)]
                });
            }
            clouds = [];
            for (let i = 0; i < 8; i++) {
                clouds.push({
                    x: Math.random() * canvas.width * 1.5,
                    y: Math.random() * 200 + 30,
                    width: Math.random() * 150 + 80,
                    speed: Math.random() * 0.4 + 0.2
                });
            }
            mountains = [];
            for (let i = 0; i < 20; i++) {
                mountains.push({
                    x: i * 100,
                    height: Math.random() * 150 + 80,
                    width: Math.random() * 120 + 80
                });
            }
            trees = [];
            for (let i = 0; i < 40; i++) {
                trees.push({
                    x: Math.random() * canvas.width * 2,
                    height: Math.random() * 40 + 25
                });
            }
            // Neon grid lines
            neonGrid = [];
            for (let i = 0; i < 20; i++) {
                neonGrid.push({ y: canvas.height - 80 + i * 15, offset: 0 });
            }
            // Rain
            weather.rain = [];
            for (let i = 0; i < 100; i++) {
                weather.rain.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 10 + 15,
                    length: Math.random() * 15 + 10
                });
            }
        }
        initBackground();

        // ============ INPUT ============
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
            if (e.code === 'Escape' && gameRunning) togglePause();
            if (e.code === 'KeyM') toggleMusic();
            if (e.code === 'KeyB' && gameRunning && !paused) useBomb();
            if (e.code === 'KeyL' && gameRunning && !paused) activateLaser();
            if (e.code === 'KeyR' && gameRunning && !paused) fireRocket();
            if (e.code === 'KeyU' && gameRunning && !paused) activateUltimate();
            if (e.code === 'Digit1') currentWeapon = 'normal';
            if (e.code === 'Digit2') currentWeapon = 'spread';
            if (e.code === 'Digit3') currentWeapon = 'laser';
            if (e.code === 'Digit4') currentWeapon = 'rocket';
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mobile controls
        let touchJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        let touchFire = false;

        const joystickArea = document.getElementById('joystickArea');
        const joystick = document.getElementById('joystick');
        const fireBtn = document.getElementById('fireBtn');
        const bombBtn = document.getElementById('bombBtn');
        const laserBtn = document.getElementById('laserBtn');

        joystickArea?.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = joystickArea.getBoundingClientRect();
            touchJoystick.active = true;
            touchJoystick.startX = rect.left + rect.width/2;
            touchJoystick.startY = rect.top + rect.height/2;
        });

        document.addEventListener('touchmove', (e) => {
            if (!touchJoystick.active) return;
            const touch = e.touches[0];
            touchJoystick.dx = (touch.clientX - touchJoystick.startX) / 40;
            touchJoystick.dy = (touch.clientY - touchJoystick.startY) / 40;
            const dist = Math.sqrt(touchJoystick.dx**2 + touchJoystick.dy**2);
            if (dist > 1) {
                touchJoystick.dx /= dist;
                touchJoystick.dy /= dist;
            }
            joystick.style.transform = `translate(${touchJoystick.dx*30}px, ${touchJoystick.dy*30}px)`;
        });

        document.addEventListener('touchend', () => {
            touchJoystick.active = false;
            touchJoystick.dx = 0;
            touchJoystick.dy = 0;
            joystick.style.transform = 'translate(0,0)';
            touchFire = false;
        });

        fireBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); touchFire = true; });
        fireBtn?.addEventListener('touchend', () => touchFire = false);
        bombBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); useBomb(); });
        laserBtn?.addEventListener('touchstart', (e) => { e.preventDefault(); activateLaser(); });

        // ============ GAME FUNCTIONS ============
        function startGame(diff) {
            initAudio();
            stopMenuMusic(); // Stop menu music when game starts
            if (spritesLoaded < 2) { setTimeout(() => startGame(diff), 100); return; }

            difficulty = diff;
            gameMode = diff;
            const cfg = difficulties[diff];
            const heli = HELICOPTERS[currentHelicopter];

            // Apply helicopter stats
            maxLives = heli.maxLives;
            lives = Math.min(cfg.lives, maxLives);
            lastDisplayedLives = lives;
            player.speed = cfg.playerSpeed * (heli.speed / 5); // Relative to base speed
            enemySpawnRate = cfg.enemySpawnRate;

            // Reset mega upgrade variables
            coins = 0;
            totalKills = 0;
            ultCharge = 0;
            ultActive = null;
            ultTimer = 0;
            flashAlpha = 0;
            distortion = 0;
            permanentFireRate = 0;
            permanentDamage = 0;
            luckBonus = 0;

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('upgradeScreen').style.display = 'none';

            score = 0;
            level = 1;
            bombs = 3;
            combo = 0;
            comboTimer = 0;
            comboMultiplier = 1;
            killStreak = 0;
            slowMotion = 0;
            slowMotionFactor = 1;
            currentWeapon = 'normal';
            laserCharge = 100;
            laserActive = false;
            rocketAmmo = 5;
            plasmaCharge = 0;
            bossType = 0;

            player.x = 100;
            player.y = canvas.height / 2;
            player.bullets = [];
            player.rockets = [];
            player.plasma = [];
            player.invincible = 0;
            player.tilt = 0;
            player.fireLevel = 1;

            perks = { fireRate: 0, damage: 0, speed: 0, magnet: 0, doubleScore: false };

            enemies = [];
            explosions = [];
            particles = [];
            powerups = [];
            floatingTexts = [];
            shockwaves = [];
            debris = [];
            boss = null;
            miniBoss = null;
            mines = [];
            obstacles = [];
            currentBiome = 'city';
            biomeTransition = 0;
            initBiomeBackground();
            activePowerups = { rapid: 0, spread: 0, shield: 0, timeslow: 0, drone: 0, piercing: 0, homing: 0, ghost: 0 };
            playerDrone = null;
            gameStats = { droneKills: 0, ghostDodges: 0, collectedPowerups: new Set(), bossHitsTaken: 0, levelStartTime: frame, lastStandUsed: false };

            // Apply progression upgrades
            const progEffects = getAllUpgradeEffects();
            const skillEffects = getAllSkillEffects();
            lives += progEffects.extraLives || 0;
            maxLives += progEffects.extraLives || 0;
            bombs += skillEffects.extraBombs || 0;
            if (skillEffects.startWithDrone) activePowerups.drone = 600;
            if (skillEffects.fortressStart) player.invincible = 180; // 3 seconds

            // Reset achievements for new game (can re-earn them!)
            achievements = {};
            localStorage.removeItem('chopperAchievements');
            weather.lightning = 0;
            weather.thunderTimer = 0;

            musicNodes.intensity = 0.3;
            updateUI();
            gameRunning = true;
            paused = false;
            lastEnemySpawn = Date.now();

            if (!musicPlaying) toggleMusic();

            // Boss rush mode starts with boss
            if (cfg.bossRush) {
                setTimeout(() => spawnBoss(), 1000);
            }

            updateXPBarGame();
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseScreen').style.display = paused ? 'flex' : 'none';
            if (!paused) requestAnimationFrame(gameLoop);
        }

        function resumeGame() { togglePause(); }

        function quitToMenu() {
            gameRunning = false;
            paused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            if (musicPlaying) toggleMusic();
            // Resume menu music if it was on
            if (localStorage.getItem('menuMusicOn') !== 'false') {
                playMenuMusic();
            }
        }

        function showMenu() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            // Resume menu music if it was on
            if (localStorage.getItem('menuMusicOn') !== 'false') {
                playMenuMusic();
            }
        }

        function gameOver() {
            gameRunning = false;
            playSound('gameOver');
            if (musicPlaying) toggleMusic();

            const cfg = difficulties[difficulty];
            const finalScore = Math.floor(score * cfg.scoreMultiplier);

            // Score achievements
            if (finalScore >= 100000) unlockAchievement('score_100k');
            if (finalScore >= 500000) unlockAchievement('score_500k');

            // Survivor achievement (5 minutes in endless = 18000 frames at 60fps)
            if (cfg.endless && frame - gameStats.levelStartTime >= 18000) {
                unlockAchievement('survivor');
            }

            // PROGRESSION: Transfer coins and add completion XP
            totalCoins += coins;
            const completionXP = level * 10 + Math.floor(finalScore / 1000);
            addXP(completionXP);
            saveProgressionData();

            highScores.push({ score: finalScore, level, difficulty, mode: gameMode });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('chopperLegendaryScores', JSON.stringify(highScores));

            document.getElementById('finalScore').textContent = String(finalScore).padStart(8, '0');
            document.getElementById('bossHealth').style.display = 'none';
            document.getElementById('bossName').style.display = 'none';
            document.getElementById('godlikeOverlay').style.opacity = '0';

            let listHTML = '<b style="color:#0ff">‚òÖ HIGH SCORES ‚òÖ</b><br>';
            highScores.slice(0, 5).forEach((hs, i) => {
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '  ';
                listHTML += `${medal} ${String(hs.score).padStart(8, '0')} L${hs.level}<br>`;
            });
            document.getElementById('highscoreList').innerHTML = listHTML;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        // Achievement system functions
        function playAchievementSound() {
            try {
                if (!audioCtx) return;
                const now = audioCtx.currentTime;

                // Epic fanfare sound
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(freq, now + i * 0.1);
                    gain.gain.setValueAtTime(0.15, now + i * 0.1);
                    gain.gain.setTargetAtTime(0.01, now + i * 0.1 + 0.15, 0.05);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.3);
                });

                // Shimmer effect
                for (let i = 0; i < 3; i++) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1500 + i * 400, now + 0.3);
                    gain.gain.setValueAtTime(0.08, now + 0.3);
                    gain.gain.setTargetAtTime(0.01, now + 0.45, 0.05);
                    osc.start(now + 0.3);
                    osc.stop(now + 0.6);
                }
            } catch(e) {
                console.log('Achievement sound error:', e);
            }
        }

        function unlockAchievement(id) {
            try {
                if (achievements[id]) return;
                const ach = ACHIEVEMENTS[id];
                if (!ach) return;

                achievements[id] = { unlocked: true, date: Date.now() };
                localStorage.setItem('chopperAchievements', JSON.stringify(achievements));

                // Epic sound!
                playAchievementSound();

                // Screen effects
                screenShake = 15;

                // Golden shockwave
                if (shockwaves) {
                    shockwaves.push({
                        x: canvas.width / 2, y: 100,
                        radius: 0, maxRadius: 250, speed: 10, color: '#ffd700'
                    });
                }

                // Sparkle particles
                if (particles) {
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        particles.push({
                            x: canvas.width / 2,
                            y: 100,
                            vx: Math.cos(angle) * (2 + Math.random() * 4),
                            vy: Math.sin(angle) * (2 + Math.random() * 4),
                            life: 40 + Math.random() * 20,
                            color: ['#ffd700', '#fff', '#ff0'][Math.floor(Math.random() * 3)],
                            size: 3 + Math.random() * 3
                        });
                    }
                }

                // Main achievement text
                if (floatingTexts) {
                    floatingTexts.push({
                        x: canvas.width / 2, y: 60,
                        text: '‚òÖ ACHIEVEMENT ‚òÖ', color: '#fff', life: 240, size: 12
                    });
                    floatingTexts.push({
                        x: canvas.width / 2, y: 85,
                        text: `${ach.icon} ${ach.name.toUpperCase()}`, color: '#ffd700', life: 240, size: 20
                    });

                    if (ach.reward) {
                        unlockedSkins[ach.reward] = true;
                        localStorage.setItem('chopperSkins', JSON.stringify(unlockedSkins));
                        floatingTexts.push({
                            x: canvas.width / 2, y: 115,
                            text: `üéÅ +${SKINS[ach.reward].name} SKIN`, color: '#0ff', life: 240, size: 14
                        });
                    }
                }
            } catch(e) {
                console.log('Achievement error:', e);
            }
        }

        function showAchievements() {
            const screen = document.getElementById('achievementScreen');
            const grid = document.getElementById('achievementGrid');
            grid.innerHTML = '';

            let unlocked = 0;
            Object.entries(ACHIEVEMENTS).forEach(([id, ach]) => {
                const isUnlocked = achievements[id];
                if (isUnlocked) unlocked++;

                const div = document.createElement('div');
                div.className = `achievement ${isUnlocked ? 'unlocked' : 'locked'}`;
                div.innerHTML = `
                    <div class="ach-icon">${ach.icon}</div>
                    <div class="ach-name">${ach.name}</div>
                    <div class="ach-desc">${ach.desc}</div>
                    ${ach.reward ? `<div class="ach-reward">üéÅ ${SKINS[ach.reward].name}</div>` : ''}
                `;
                grid.appendChild(div);
            });

            document.getElementById('achievementProgress').textContent = `${unlocked}/15 Unlocked`;
            document.getElementById('startScreen').style.display = 'none';
            screen.style.display = 'flex';
        }

        function closeAchievements() {
            document.getElementById('achievementScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function showSkinScreen() {
            const screen = document.getElementById('skinScreen');
            const grid = document.getElementById('skinGrid');
            grid.innerHTML = '';

            Object.entries(SKINS).forEach(([id, skin]) => {
                const isUnlocked = unlockedSkins[id];
                const isSelected = currentSkin === id;

                const div = document.createElement('div');
                div.className = `skin-item ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;

                let previewStyle = '';
                if (skin.special === 'rainbow') {
                    previewStyle = 'background: linear-gradient(90deg, red, orange, yellow, green, blue, purple);';
                } else {
                    previewStyle = `background: linear-gradient(135deg, ${skin.colors[0]}, ${skin.colors[1]}, ${skin.colors[2]});`;
                }

                div.innerHTML = `
                    <div class="skin-preview" style="${previewStyle}"></div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-desc">${isUnlocked ? '‚úì Owned' : 'üîí Locked'}</div>
                `;

                if (isUnlocked) {
                    div.onclick = () => selectSkin(id);
                }
                grid.appendChild(div);
            });

            document.getElementById('startScreen').style.display = 'none';
            screen.style.display = 'flex';
        }

        function closeSkinScreen() {
            document.getElementById('skinScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function selectSkin(id) {
            if (!unlockedSkins[id]) return;
            currentSkin = id;
            localStorage.setItem('chopperCurrentSkin', currentSkin);
            showSkinScreen(); // Refresh display
        }

        // ============ PROGRESSION SCREEN FUNCTIONS ============
        let currentProgTab = 'upgrades';
        let currentUpgradeCat = 'offense';

        function showProgressionScreen() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('progressionScreen').style.display = 'flex';
            updateProgressionHeader();
            showProgTab('upgrades');
        }

        function closeProgressionScreen() {
            document.getElementById('progressionScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function updateProgressionHeader() {
            document.getElementById('progLevel').textContent = playerData.level;
            const xpNeeded = playerData.level >= MAX_PLAYER_LEVEL ? 'MAX' : getXPForLevel(playerData.level + 1);
            document.getElementById('progXP').textContent = playerData.level >= MAX_PLAYER_LEVEL ? 'MAX' : `${playerData.xp}/${xpNeeded}`;
            document.getElementById('progCoins').textContent = `${totalCoins} ü™ô`;
            document.getElementById('progPrestige').textContent = playerData.prestigeLevel > 0 ? '‚≠ê'.repeat(playerData.prestigeLevel) : '-';
        }

        function showProgTab(tab) {
            currentProgTab = tab;
            document.querySelectorAll('.prog-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.prog-tab[onclick="showProgTab('${tab}')"]`).classList.add('active');
            document.getElementById('progUpgradesTab').style.display = tab === 'upgrades' ? 'block' : 'none';
            document.getElementById('progSkillsTab').style.display = tab === 'skills' ? 'block' : 'none';
            document.getElementById('progPrestigeTab').style.display = tab === 'prestige' ? 'block' : 'none';
            if (tab === 'upgrades') renderUpgradeGrid();
            if (tab === 'skills') renderSkillTree();
            if (tab === 'prestige') renderPrestigeTab();
        }

        function showUpgradeCat(cat) {
            currentUpgradeCat = cat;
            document.querySelectorAll('.cat-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.cat-tab[onclick="showUpgradeCat('${cat}')"]`).classList.add('active');
            renderUpgradeGrid();
        }

        function renderUpgradeGrid() {
            const grid = document.getElementById('upgradeGridPerm');
            grid.innerHTML = '';
            Object.values(PERMANENT_UPGRADES).filter(u => u.category === currentUpgradeCat).forEach(upgrade => {
                const level = purchasedUpgrades[upgrade.id] || 0;
                const cost = getUpgradeCost(upgrade.id);
                const canBuy = totalCoins >= cost && level < upgrade.maxLevel;
                const isMaxed = level >= upgrade.maxLevel;
                const div = document.createElement('div');
                div.className = `perm-upgrade ${canBuy ? 'can-buy' : ''} ${isMaxed ? 'maxed' : ''}`;
                div.innerHTML = `
                    <span class="upgrade-icon">${upgrade.icon}</span>
                    <div class="upgrade-info">
                        <div class="upgrade-name">${upgrade.name}</div>
                        <div class="upgrade-desc">${upgrade.desc(level)}</div>
                        <div class="upgrade-lvl">Lv.${level}/${upgrade.maxLevel}</div>
                    </div>
                    <span class="upgrade-cost ${!canBuy ? 'disabled' : ''} ${isMaxed ? 'maxed' : ''}">${isMaxed ? 'MAX' : cost + 'ü™ô'}</span>
                `;
                if (canBuy) div.onclick = () => { purchaseUpgrade(upgrade.id); updateProgressionHeader(); renderUpgradeGrid(); };
                grid.appendChild(div);
            });
        }

        function renderSkillTree() {
            ['attack', 'defense', 'utility'].forEach(branch => {
                const container = document.getElementById('skills' + branch.charAt(0).toUpperCase() + branch.slice(1));
                container.innerHTML = '';
                const skills = Object.values(SKILL_TREE).filter(s => s.branch === branch).sort((a, b) => a.tier - b.tier);
                skills.forEach(skill => {
                    const unlocked = unlockedSkills[skill.id];
                    const canUnlock = canUnlockSkill(skill.id);
                    const div = document.createElement('div');
                    div.className = `skill-node ${unlocked ? 'unlocked' : ''} ${canUnlock ? 'can-unlock' : ''} ${!unlocked && !canUnlock ? 'locked' : ''}`;
                    div.innerHTML = `<div class="skill-icon">${skill.icon}</div><div class="skill-name">${skill.name}</div><div class="skill-req">Lv.${skill.requiredLevel}</div>`;
                    div.title = `${skill.name}\n${skill.desc}\nRequired: Level ${skill.requiredLevel}`;
                    if (canUnlock) div.onclick = () => { unlockSkill(skill.id); updateProgressionHeader(); renderSkillTree(); };
                    container.appendChild(div);
                });
            });
        }

        function renderPrestigeTab() {
            const stars = playerData.prestigeLevel > 0 ? '‚≠ê'.repeat(playerData.prestigeLevel) : '(None)';
            document.getElementById('prestigeStarsDisplay').textContent = stars;
            document.getElementById('prestigeBonusDisplay').textContent = `Bonus: +${Math.round(playerData.prestigeLevel * 10)}% All Stats`;
            const btn = document.getElementById('prestigeBtn');
            btn.disabled = !canPrestige();
            btn.textContent = canPrestige() ? '‚≠ê PRESTIGE NOW' : `‚≠ê NEED LV.${PRESTIGE_CONFIG.minLevel}`;
            const skinsList = document.getElementById('prestigeSkinsList');
            skinsList.innerHTML = '';
            Object.entries(PRESTIGE_CONFIG.skins).forEach(([lvl, skin]) => {
                const unlocked = prestigeSkins[skin.id];
                const span = document.createElement('span');
                span.className = `prestige-skin ${unlocked ? 'unlocked' : ''}`;
                span.textContent = `P${lvl}: ${skin.name}`;
                skinsList.appendChild(span);
            });
        }

        function confirmPrestige() {
            if (!canPrestige()) return;
            if (confirm(`‚≠ê PRESTIGE ‚≠ê\n\nYou will gain +${(playerData.prestigeLevel + 1) * 10}% to all stats!\n\nYour level will reset to 1.\nYour upgrades will be KEPT.\n\nContinue?`)) {
                doPrestige();
                updateProgressionHeader();
                renderPrestigeTab();
                renderSkillTree();
            }
        }

        function updateXPBarGame() {
            const bar = document.getElementById('xpBarGameFill');
            const text = document.getElementById('xpBarGameText');
            if (playerData.level >= MAX_PLAYER_LEVEL) {
                bar.style.width = '100%';
                text.textContent = `LV.${playerData.level} MAX`;
            } else {
                const xpNeeded = getXPForLevel(playerData.level + 1);
                const progress = (playerData.xp / xpNeeded) * 100;
                bar.style.width = `${progress}%`;
                text.textContent = `LV.${playerData.level}`;
            }
        }

        function showUpgradeScreen() {
            paused = true;
            const screen = document.getElementById('upgradeScreen');
            const options = document.getElementById('upgradeOptions');

            const availablePerks = [
                { id: 'fireRate', icon: 'üî•', name: 'RAPID FIRE', desc: '+20% Fire Rate', effect: () => perks.fireRate++ },
                { id: 'damage', icon: 'üí•', name: 'POWER UP', desc: '+25% Damage', effect: () => perks.damage++ },
                { id: 'speed', icon: '‚ö°', name: 'SPEED BOOST', desc: '+15% Move Speed', effect: () => { perks.speed++; player.speed *= 1.15; } },
                { id: 'magnet', icon: 'üß≤', name: 'MAGNET', desc: 'Attract Power-ups', effect: () => perks.magnet++ },
                { id: 'rockets', icon: 'üöÄ', name: 'ROCKETS +3', desc: '+3 Homing Rockets', effect: () => rocketAmmo += 3 },
                { id: 'bombs', icon: 'üí£', name: 'BOMBS +2', desc: '+2 Mega Bombs', effect: () => bombs += 2 },
                { id: 'life', icon: '‚ù§Ô∏è', name: 'EXTRA LIFE', desc: '+1 Life', effect: () => lives++ }
            ];

            // Random 3 perks
            const shuffled = availablePerks.sort(() => Math.random() - 0.5).slice(0, 3);

            options.innerHTML = '';
            shuffled.forEach(perk => {
                const btn = document.createElement('button');
                btn.className = 'menu-option upgrade-option';
                btn.innerHTML = `<span class="perk-icon">${perk.icon}</span><div><b>${perk.name}</b><br><small style="color:#888">${perk.desc}</small></div>`;
                btn.onclick = () => {
                    perk.effect();
                    screen.style.display = 'none';
                    paused = false;
                    updateUI();
                    requestAnimationFrame(gameLoop);
                };
                options.appendChild(btn);
            });

            screen.style.display = 'flex';
        }

        function updateUI() {
            const cfg = difficulties[difficulty];
            const displayScore = Math.floor(score * cfg.scoreMultiplier);
            document.getElementById('score').textContent = String(displayScore).padStart(8, '0');
            document.getElementById('level').textContent = String(level).padStart(2, '0');

            const livesEl = document.getElementById('lives');
            livesEl.textContent = '‚ô•'.repeat(Math.max(0, lives)) + ' üí£' + bombs;

            // Flash lives display when hit
            if (lives < lastDisplayedLives) {
                const livesLabel = document.querySelector('.lives-display');
                if (livesLabel) {
                    livesLabel.classList.remove('lives-hit');
                    void livesLabel.offsetWidth; // Force reflow
                    livesLabel.classList.add('lives-hit');
                }
            }
            lastDisplayedLives = lives;

            // Coins display
            document.getElementById('coins').textContent = 'ü™ô ' + coins;

            // Ultimate bar
            const ultFill = document.getElementById('ultFill');
            const ultText = document.getElementById('ultText');
            ultFill.style.width = ultCharge + '%';
            if (ultCharge >= 100) {
                ultText.textContent = '‚ö° PRESS U ‚ö°';
                ultFill.style.background = 'linear-gradient(90deg, #ff0, #f0f, #0ff)';
            } else {
                ultText.textContent = 'ULT ' + Math.floor(ultCharge) + '%';
                ultFill.style.background = 'linear-gradient(90deg, #f0f, #0ff)';
            }

            // Rage mode indicator
            const rageEl = document.getElementById('rageIndicator');
            if (lives === 1 && !boss) {
                rageEl.style.display = 'block';
            } else {
                rageEl.style.display = 'none';
            }

            const comboEl = document.getElementById('comboIndicator');
            if (comboMultiplier > 1) {
                comboEl.textContent = 'x' + comboMultiplier + (combo >= 20 ? ' GODLIKE!' : combo >= 10 ? ' UNSTOPPABLE!' : combo >= 5 ? ' MEGA!' : '');
                comboEl.style.opacity = '1';
                comboEl.style.fontSize = Math.min(24 + combo, 40) + 'px';
            } else {
                comboEl.style.opacity = '0';
            }

            let pwrText = '';
            if (activePowerups.rapid > 0) pwrText += '‚ö°RAPID ';
            if (activePowerups.spread > 0) pwrText += 'üî±SPREAD ';
            if (activePowerups.shield > 0) pwrText += 'üõ°Ô∏èSHIELD ';
            if (activePowerups.timeslow > 0) pwrText += '‚è±Ô∏èSLOW ';
            if (activePowerups.drone > 0) pwrText += 'ü§ñDRONE ';
            if (activePowerups.piercing > 0) pwrText += 'üî´PIERCE ';
            if (activePowerups.homing > 0) pwrText += 'üéØHOMING ';
            if (activePowerups.ghost > 0) pwrText += 'üëªGHOST ';
            document.getElementById('powerupIndicator').textContent = pwrText;

            const weapons = {
                normal: { num: 1, name: 'NORMAL' },
                spread: { num: 2, name: 'SPREAD' },
                laser: { num: 3, name: `LASER [${Math.floor(laserCharge)}%]` },
                rocket: { num: 4, name: `ROCKETS [${rocketAmmo}]` }
            };
            const w = weapons[currentWeapon];
            document.getElementById('weaponIndicator').textContent = `[${w.num}] ${w.name}`;

            // Godlike overlay
            document.getElementById('godlikeOverlay').style.opacity = combo >= 20 ? '0.8' : combo >= 10 ? '0.4' : '0';

            // Music intensity
            musicNodes.intensity = Math.min(1, 0.3 + combo * 0.03 + (boss ? 0.3 : 0));
        }

        function activateLaser() {
            if (laserCharge >= 20 && !laserActive) {
                laserActive = true;
                playSound('laser');
            }
        }

        function fireRocket() {
            if (rocketAmmo > 0 && !paused) {
                rocketAmmo--;
                playSound('rocket');

                // Find nearest enemy
                let target = null;
                let minDist = Infinity;
                [...enemies, boss].filter(e => e).forEach(e => {
                    const dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist < minDist) { minDist = dist; target = e; }
                });

                player.rockets.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    width: 20, height: 8,
                    speed: 8,
                    target,
                    angle: 0,
                    trail: []
                });
                updateUI();
            }
        }

        // ============ MEGA UPGRADE FUNCTIONS ============

        // ULTIMATE ABILITY
        function activateUltimate() {
            if (ultCharge < 100) return;
            ultCharge = 0;

            const heli = HELICOPTERS[currentHelicopter];
            ultActive = heli.ultimate;
            ultTimer = heli.ultDuration;

            playSound('megaExplosion');
            screenShake = 25;

            if (ultActive === 'nuke') {
                // NUKE - Kill all enemies instantly
                enemies.forEach(e => {
                    createExplosion(e.x + e.width/2, e.y + e.height/2, true);
                    score += (e.points || 100) * 2;
                    coins += 5;
                });
                enemies = [];
                // White flash
                flashColor = '#fff';
                flashAlpha = 1;
                distortion = 0.05;
                floatingTexts.push({
                    x: canvas.width/2, y: canvas.height/2,
                    text: '‚ò¢Ô∏è NUKE ‚ò¢Ô∏è', color: '#ff0', life: 90, size: 32
                });
            } else if (ultActive === 'bulletTime') {
                // BULLET TIME - Slow motion
                floatingTexts.push({
                    x: canvas.width/2, y: canvas.height/2,
                    text: '‚è±Ô∏è BULLET TIME ‚è±Ô∏è', color: '#0ff', life: 90, size: 28
                });
                flashColor = '#08f';
                flashAlpha = 0.3;
            } else if (ultActive === 'godMode') {
                // GOD MODE - Invincibility
                floatingTexts.push({
                    x: canvas.width/2, y: canvas.height/2,
                    text: 'üëë GOD MODE üëë', color: '#fd0', life: 90, size: 28
                });
                flashColor = '#fd0';
                flashAlpha = 0.5;
            }

            updateUI();
        }

        // SHOP SYSTEM
        function showShop() {
            paused = true;
            const shopDiv = document.getElementById('shopScreen');
            const itemsDiv = document.getElementById('shopItems');
            document.getElementById('shopCoins').textContent = 'ü™ô ' + coins;

            itemsDiv.innerHTML = '';
            SHOP_ITEMS.forEach(item => {
                const canBuy = coins >= item.cost;
                const btn = document.createElement('button');
                btn.className = 'shop-item ' + (canBuy ? '' : 'disabled');
                btn.innerHTML = `${item.icon} ${item.name} - ${item.cost}ü™ô`;
                btn.onclick = () => buyItem(item.id);
                itemsDiv.appendChild(btn);
            });

            document.getElementById('upgradeScreen').style.display = 'none';
            shopDiv.style.display = 'flex';
        }

        function buyItem(id) {
            const item = SHOP_ITEMS.find(i => i.id === id);
            if (!item || coins < item.cost) return;

            coins -= item.cost;
            playSound('powerup');

            switch(id) {
                case 'life': lives = Math.min(lives + 1, maxLives); break;
                case 'bombs': bombs += 3; break;
                case 'maxhp': maxLives++; lives++; break;
                case 'firerate': permanentFireRate += 0.1; break;
                case 'damage': permanentDamage += 0.2; break;
                case 'magnet': perks.magnet++; break;
                case 'lucky': luckBonus += 0.1; break;
            }

            floatingTexts.push({
                x: canvas.width/2, y: canvas.height/2 - 50,
                text: item.icon + ' PURCHASED!', color: '#0f0', life: 60, size: 18
            });

            updateUI();
            showShop(); // Refresh
        }

        function closeShop() {
            document.getElementById('shopScreen').style.display = 'none';
            paused = false;
            requestAnimationFrame(gameLoop);
        }

        // HELICOPTER SELECTION
        function showHeliSelect() {
            const screen = document.getElementById('heliSelectScreen');
            const grid = document.getElementById('heliGrid');
            grid.innerHTML = '';

            Object.entries(HELICOPTERS).forEach(([id, heli]) => {
                const isUnlocked = unlockedHelicopters.includes(id);
                const isSelected = currentHelicopter === id;

                const div = document.createElement('div');
                div.className = 'heli-option ' + (isSelected ? 'selected' : '');
                div.innerHTML = `
                    <div class="heli-name" style="color:${heli.color}">${heli.name}</div>
                    <div class="heli-stat">‚ù§Ô∏è ${heli.maxLives} HP</div>
                    <div class="heli-stat">‚ö° ${heli.speed} SPD</div>
                    <div class="heli-stat">üí• ${heli.damage}x DMG</div>
                    <div class="heli-stat" style="color:#f0f">ULT: ${heli.ultimate.toUpperCase()}</div>
                    <div style="color:#666;font-size:6px;margin-top:5px">${heli.desc}</div>
                `;
                if (isUnlocked) {
                    div.onclick = () => selectHelicopter(id);
                }
                grid.appendChild(div);
            });

            document.getElementById('startScreen').style.display = 'none';
            screen.style.display = 'flex';
        }

        function selectHelicopter(id) {
            if (!unlockedHelicopters.includes(id)) return;
            currentHelicopter = id;
            localStorage.setItem('chopperHelicopter', currentHelicopter);
            showHeliSelect(); // Refresh
        }

        function closeHeliSelect() {
            document.getElementById('heliSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Check if Rage Mode is active
        function isRageMode() {
            return lives === 1 && !boss;
        }

        function useBomb() {
            if (bombs <= 0 || !gameRunning || paused) return;
            bombs--;
            playSound('megaExplosion');
            screenShake = 40;

            // Create mega shockwave
            shockwaves.push({ x: player.x + player.width/2, y: player.y + player.height/2, radius: 0, maxRadius: 600, speed: 15, color: '#f80' });

            // Kill all enemies
            const bombKills = enemies.length;
            enemies.forEach(e => {
                createExplosion(e.x + e.width/2, e.y + e.height/2, true);
                score += e.points;
                spawnDebris(e.x + e.width/2, e.y + e.height/2, 5);
            });
            enemies = [];
            if (bombKills >= 5) unlockAchievement('bomb_multi');

            // Heavy boss damage
            if (boss) {
                boss.health -= 30;
                createExplosion(boss.x + boss.width/2, boss.y + boss.height/2, true);
            }

            // Mini-boss damage
            if (miniBoss) {
                miniBoss.health -= 20;
                createExplosion(miniBoss.x + miniBoss.width/2, miniBoss.y + miniBoss.height/2, true);
                if (miniBoss.health <= 0) {
                    score += 2000 * level;
                    floatingTexts.push({ x: miniBoss.x, y: miniBoss.y, text: 'MINI-BOSS DOWN!', color: '#f80', life: 80, size: 14 });
                    miniBoss = null;
                }
            }

            // Clear all mines
            mines.forEach(m => {
                createExplosion(m.x, m.y, false);
            });
            mines = [];

            // Nuclear flash
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 60,
                    color: ['#fff', '#ff0', '#f80'][Math.floor(Math.random() * 3)],
                    size: Math.random() * 10 + 5
                });
            }

            updateUI();
        }

        function spawnPowerup(x, y) {
            const types = ['rapid', 'spread', 'shield', 'bomb', 'life', 'rocket', 'laser',
                           'timeslow', 'drone', 'piercing', 'homing', 'emp', 'ghost'];
            const colors = {
                rapid: '#ff0', spread: '#00f', shield: '#0f0', bomb: '#f00',
                life: '#f0f', rocket: '#fa0', laser: '#f00',
                timeslow: '#a0f', drone: '#f80', piercing: '#fff',
                homing: '#f8f', emp: '#8ff', ghost: '#888'
            };
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push({ x, y, type, color: colors[type], width: 24, height: 24, vy: 0, pulse: 0 });
        }

        function collectPowerup(p) {
            playSound('powerup');
            floatingTexts.push({ x: p.x, y: p.y, text: p.type.toUpperCase() + '!', color: p.color, life: 60, size: 14 });

            // Track for collector achievement
            gameStats.collectedPowerups.add(p.type);
            if (gameStats.collectedPowerups.size >= 13) unlockAchievement('collector');

            // SKILL: Godlike - 50% longer powerup duration
            const pwrMult = getAllSkillEffects().godlike ? 1.5 : 1;

            switch(p.type) {
                case 'rapid': activePowerups.rapid = 600 * pwrMult; player.shootCooldown = 60; break;
                case 'spread': activePowerups.spread = 600 * pwrMult; break;
                case 'shield': activePowerups.shield = 600 * pwrMult * (1 + (getAllUpgradeEffects().shieldBonus || 0)); break;
                case 'bomb': bombs = Math.min(bombs + 1, 9); break;
                case 'life': lives = Math.min(lives + 1, 9); break;
                case 'rocket': rocketAmmo = Math.min(rocketAmmo + 3, 20); break;
                case 'laser': laserCharge = Math.min(laserCharge + 50, 100); break;
                // NEW POWERUPS
                case 'timeslow': activePowerups.timeslow = 480 * pwrMult; break;
                case 'drone':
                    activePowerups.drone = 900 * pwrMult;
                    playerDrone = { x: player.x - 30, y: player.y - 20, lastShot: 0 };
                    break;
                case 'piercing': activePowerups.piercing = 600 * pwrMult; break;
                case 'homing': activePowerups.homing = 600 * pwrMult; break;
                case 'emp': triggerEMP(); break;
                case 'ghost': activePowerups.ghost = 300 * pwrMult; break;
            }
            updateUI();
        }

        function triggerEMP() {
            playSound('megaExplosion');
            // Count and clear all enemy bullets
            let bulletsCleared = 0;
            enemies.forEach(e => { bulletsCleared += e.bullets.length; e.bullets = []; });
            if (boss) { bulletsCleared += boss.bullets.length; boss.bullets = []; }
            if (miniBoss) { bulletsCleared += miniBoss.bullets.length; miniBoss.bullets = []; }
            if (bulletsCleared >= 20) unlockAchievement('emp_master');
            // Stun enemies
            enemies.forEach(e => e.stunned = 120);
            // Clear mines too
            mines.forEach(m => createExplosion(m.x, m.y, false));
            mines = [];
            // Visual effect
            shockwaves.push({
                x: player.x + player.width/2, y: player.y + player.height/2,
                radius: 0, maxRadius: 600, speed: 25, color: '#0ff'
            });
            screenShake = 15;
            floatingTexts.push({
                x: player.x + player.width/2, y: player.y - 30,
                text: '‚ö° EMP ‚ö°', color: '#0ff', life: 60, size: 16
            });
        }

        function triggerSlowMotion() {
            if (slowMotion <= 0) {
                slowMotion = 90;
                slowMotionFactor = 0.3;
                playSound('slowmo');
                playVoice('MEGA KILL');
            }
        }

        const MAX_DEBRIS = 50;

        function spawnDebris(x, y, count) {
            const actualCount = debris.length > MAX_DEBRIS ? Math.floor(count / 2) : count;
            for (let i = 0; i < actualCount; i++) {
                debris.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    rotation: Math.random() * 360,
                    rotSpeed: (Math.random() - 0.5) * 20,
                    size: Math.random() * 12 + 4,
                    life: 100,
                    color: ['#555', '#666', '#777', '#444'][Math.floor(Math.random() * 4)]
                });
            }
            // Hard limit
            if (debris.length > MAX_DEBRIS) {
                debris.splice(0, debris.length - MAX_DEBRIS);
            }
        }

        // ============ ENEMY SPAWNING ============
        // Mines array
        let mines = [];

        // Mini-boss system
        let miniBoss = null;
        const miniBossTypes = [
            { name: 'STRIKE LEADER', health: 50, width: 80, height: 35, color: '#a44', escort: 3 },
            { name: 'HEAVY BOMBER', health: 80, width: 120, height: 55, color: '#4a4', bombRate: 40 },
            { name: 'STEALTH HUNTER', health: 40, width: 70, height: 30, color: '#448', cloakDuration: 120 }
        ];

        // Formation patterns
        const formations = {
            v: [{x:0,y:0}, {x:-35,y:35}, {x:35,y:35}, {x:-70,y:70}, {x:70,y:70}],
            wall: [{x:0,y:-50}, {x:0,y:-25}, {x:0,y:0}, {x:0,y:25}, {x:0,y:50}],
            circle: [{x:0,y:-40}, {x:35,y:-20}, {x:35,y:20}, {x:0,y:40}, {x:-35,y:20}, {x:-35,y:-20}],
            snake: [{x:0,y:0}, {x:40,y:15}, {x:80,y:0}, {x:120,y:-15}, {x:160,y:0}]
        };

        function spawnFormation(formationType, enemyType) {
            const pattern = formations[formationType];
            const baseX = canvas.width + 100;
            const baseY = 150 + Math.random() * (canvas.height - 400);
            const cfg = difficulties[difficulty];

            pattern.forEach((pos, i) => {
                setTimeout(() => {
                    const enemy = createEnemy(enemyType || 'fighter', baseX + pos.x, baseY + pos.y);
                    enemy.formation = formationType;
                    enemy.formationIndex = i;
                    enemy.formationBaseY = baseY;
                    enemies.push(enemy);
                }, i * 100);
            });
        }

        function createEnemy(type, x, y) {
            const cfg = difficulties[difficulty];
            const isGround = type === 'turret';

            // Extended enemy properties
            const props = {
                fighter: { width: 55, height: 24, speed: 3, health: 1, points: 100, shootCooldown: 1500, glowColor: '#4af' },
                bomber: { width: 100, height: 40, speed: 1.5, health: 4, points: 500, shootCooldown: 800, glowColor: '#4a4' },
                jet: { width: 60, height: 20, speed: 6, health: 1, points: 200, shootCooldown: 2000, glowColor: '#f44' },
                helicopter: { width: 75, height: 28, speed: 2.5, health: 2, points: 300, shootCooldown: 1000, glowColor: '#f84' },
                turret: { width: 40, height: 35, speed: 0.8, health: 2, points: 150, shootCooldown: 600, glowColor: '#ff0' },
                drone: { width: 30, height: 30, speed: 4, health: 1, points: 250, shootCooldown: 1200, glowColor: '#f0f' },
                // NEW ENEMIES
                kamikaze: { width: 35, height: 25, speed: 7, health: 1, points: 150, shootCooldown: 9999, glowColor: '#f00' },
                blinker: { width: 28, height: 28, speed: 2, health: 2, points: 300, shootCooldown: 800, glowColor: '#0ff' },
                shielder: { width: 65, height: 40, speed: 1.5, health: 3, points: 400, shootCooldown: 1200, glowColor: '#00f', shieldHP: 5 },
                miner: { width: 50, height: 30, speed: 2, health: 2, points: 250, shootCooldown: 9999, glowColor: '#0f0' },
                scout: { width: 25, height: 18, speed: 7, health: 1, points: 350, shootCooldown: 1500, glowColor: '#ff0' },
                // MEGA UPGRADE ENEMIES
                teleporter: { width: 32, height: 32, speed: 1, health: 2, points: 400, shootCooldown: 1000, glowColor: '#f0f' },
                splitter: { width: 50, height: 35, speed: 2.5, health: 4, points: 350, shootCooldown: 1500, glowColor: '#0f8' },
                splitter_mini: { width: 25, height: 18, speed: 4, health: 1, points: 75, shootCooldown: 2000, glowColor: '#0f8' },
                healer: { width: 40, height: 35, speed: 1.5, health: 3, points: 500, shootCooldown: 9999, glowColor: '#0f0' },
                reflector: { width: 45, height: 40, speed: 2, health: 5, points: 450, shootCooldown: 1200, glowColor: '#ccc' },
                suicide_bomber: { width: 30, height: 30, speed: 5, health: 1, points: 200, shootCooldown: 9999, glowColor: '#f80' },
                // NEW ADVANCED ENEMIES
                phantom: { width: 45, height: 40, speed: 2, health: 3, points: 450, shootCooldown: 1500, glowColor: '#a0f' },
                laserDrone: { width: 35, height: 35, speed: 1.5, health: 2, points: 500, shootCooldown: 9999, glowColor: '#f00' },
                gravityWell: { width: 50, height: 50, speed: 0.5, health: 6, points: 600, shootCooldown: 9999, glowColor: '#08f' },
                mirror: { width: 40, height: 60, speed: 1, health: 4, points: 550, shootCooldown: 9999, glowColor: '#fff' },
                spawner: { width: 70, height: 50, speed: 0.8, health: 8, points: 700, shootCooldown: 9999, glowColor: '#fa0' },
                bee: { width: 20, height: 15, speed: 5, health: 1, points: 25, shootCooldown: 9999, glowColor: '#ff0' },
                teslaCoil: { width: 45, height: 55, speed: 1.2, health: 5, points: 650, shootCooldown: 9999, glowColor: '#0ff' }
            };

            const p = props[type] || props.fighter;

            return {
                id: ++enemyIdCounter,
                x: x !== undefined ? x : canvas.width + 50,
                y: y !== undefined ? y : (isGround ? canvas.height - 100 : Math.random() * (canvas.height - 300) + 100),
                width: p.width,
                height: p.height,
                speed: p.speed * cfg.enemySpeed,
                type,
                bullets: [],
                lastShot: Date.now(),
                shootCooldown: p.shootCooldown,
                health: p.health,
                maxHealth: p.health,
                points: p.points,
                amplitude: Math.random() * 50 + 20,
                frequency: Math.random() * 0.04 + 0.01,
                startY: y !== undefined ? y : 0,
                glowColor: p.glowColor,
                // Special properties
                shieldHP: p.shieldHP || 0,
                shieldMaxHP: p.shieldHP || 0,
                teleportTimer: type === 'blinker' ? 150 + Math.random() * 60 : 0,
                teleportWarning: 0,
                mineTimer: type === 'miner' ? 90 : 0,
                cloaked: false,
                cloakTimer: 0,
                dodgeCooldown: 0,
                afterImages: [],
                // NEW ENEMY PROPERTIES
                phantomPhase: type === 'phantom' ? 0 : 0,
                phantomVisible: true,
                laserCharging: 0,
                laserFiring: 0,
                mirrorOpen: false,
                mirrorTimer: type === 'mirror' ? 180 : 0,
                spawnTimer: type === 'spawner' ? 180 : 0,
                parentId: null,
                teslaTimer: type === 'teslaCoil' ? 90 : 0,
                charged: false
            };
        }

        function spawnEnemy() {
            if (boss || miniBoss) return;

            const cfg = difficulties[difficulty];

            // Check for mini-boss spawn (levels 3, 7, 13, etc - primes)
            if ([3, 7, 11, 13, 17, 19, 23].includes(level) && !miniBoss && enemies.length === 0 && Math.random() < 0.3) {
                spawnMiniBoss();
                return;
            }

            // Chance to spawn formation
            if (level >= 3 && Math.random() < 0.15) {
                const formTypes = Object.keys(formations);
                const formType = formTypes[Math.floor(Math.random() * formTypes.length)];
                spawnFormation(formType, 'fighter');
                return;
            }

            // Regular enemy types + new enemies based on level
            const baseTypes = ['fighter', 'bomber', 'jet', 'helicopter', 'turret', 'drone'];

            let available = baseTypes.slice(0, Math.min(baseTypes.length, 2 + Math.floor(level / 2)));

            // Add new enemy types progressively
            if (level >= 2) available.push('kamikaze');
            if (level >= 4) available.push('blinker');
            if (level >= 6) available.push('shielder');
            if (level >= 8) available.push('miner');
            if (level >= 10) available.push('scout');

            // MEGA UPGRADE: New enemy types
            if (level >= 7) available.push('teleporter');
            if (level >= 9) available.push('splitter');
            if (level >= 11) available.push('healer');
            if (level >= 13) available.push('reflector');
            if (level >= 15) available.push('suicide_bomber');

            // ADVANCED ENEMIES
            if (level >= 12) available.push('phantom');
            if (level >= 14) available.push('laserDrone');
            if (level >= 16) available.push('gravityWell');
            if (level >= 17) available.push('mirror');
            if (level >= 18) available.push('spawner');
            if (level >= 19) available.push('teslaCoil');

            const type = available[Math.floor(Math.random() * available.length)];
            const enemy = createEnemy(type);
            enemy.startY = enemy.y;
            enemies.push(enemy);
        }

        function spawnObstacle() {
            const biome = BIOMES[currentBiome];
            if (!biome.obstacles || biome.obstacles.length === 0) return;

            const type = biome.obstacles[Math.floor(Math.random() * biome.obstacles.length)];
            const yPos = 100 + Math.random() * (canvas.height - 280);

            const obs = {
                x: canvas.width + 60,
                y: yPos,
                type: type,
                width: 45,
                height: 45,
                speed: 2 + Math.random() * 2,
                rotation: 0,
                health: type === 'asteroid' || type === 'satellite' ? 2 : 1
            };

            // Type-specific sizes
            if (type === 'iceberg') { obs.width = 60; obs.height = 70; }
            if (type === 'billboard') { obs.width = 80; obs.height = 50; }
            if (type === 'satellite') { obs.width = 50; obs.height = 50; obs.health = 3; }
            if (type === 'asteroid') { obs.width = 55; obs.height = 55; }

            obstacles.push(obs);
        }

        function updateObstacles() {
            obstacles = obstacles.filter(o => {
                o.x -= o.speed;
                o.rotation += 0.03;

                // Collision with player
                if (player && player.invincible === 0 && activePowerups.shield === 0 && activePowerups.ghost === 0) {
                    const px = player.x + player.width / 2;
                    const py = player.y + player.height / 2;
                    const ox = o.x + o.width / 2;
                    const oy = o.y + o.height / 2;
                    const dist = Math.hypot(px - ox, py - oy);

                    if (dist < (player.width + o.width) / 2.5) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, false);
                        playSound('hit');
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                }

                // Bullets can destroy obstacles
                if (player && player.bullets) {
                    player.bullets.forEach((b, bi) => {
                        if (b.x > o.x && b.x < o.x + o.width && b.y > o.y && b.y < o.y + o.height) {
                            o.health--;
                            if (!b.piercing) player.bullets.splice(bi, 1);
                            if (o.health <= 0) {
                                createExplosion(o.x + o.width / 2, o.y + o.height / 2, false);
                                score += 25;
                                playSound('explosion');
                            }
                        }
                    });
                }

                return o.x > -100 && o.health > 0;
            });
        }

        function drawObstacles() {
            obstacles.forEach(o => {
                ctx.save();
                ctx.translate(o.x + o.width / 2, o.y + o.height / 2);

                if (o.type === 'asteroid') {
                    ctx.rotate(o.rotation);
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(0, 0, o.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(-8, -5, 8, 0, Math.PI * 2);
                    ctx.arc(10, 8, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (o.type === 'satellite') {
                    ctx.rotate(o.rotation * 0.5);
                    // Body
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-10, -8, 20, 16);
                    // Solar panels
                    ctx.fillStyle = '#228';
                    ctx.fillRect(-30, -5, 18, 10);
                    ctx.fillRect(12, -5, 18, 10);
                    // Antenna
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(-2, -15, 4, 8);
                } else if (o.type === 'iceberg') {
                    ctx.fillStyle = '#aef';
                    ctx.beginPath();
                    ctx.moveTo(0, -o.height / 2);
                    ctx.lineTo(o.width / 2, o.height / 2);
                    ctx.lineTo(-o.width / 2, o.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#8cf';
                    ctx.beginPath();
                    ctx.moveTo(0, -o.height / 2 + 10);
                    ctx.lineTo(o.width / 3, o.height / 3);
                    ctx.lineTo(-o.width / 4, o.height / 3);
                    ctx.closePath();
                    ctx.fill();
                } else if (o.type === 'mine') {
                    ctx.rotate(o.rotation);
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.fill();
                    // Spikes
                    ctx.fillStyle = '#f44';
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(i * Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(15, -3);
                        ctx.lineTo(25, 0);
                        ctx.lineTo(15, 3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    // Blink
                    ctx.fillStyle = frame % 30 < 15 ? '#f00' : '#800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (o.type === 'billboard') {
                    // Neon warning sign
                    ctx.shadowColor = '#f0f';
                    ctx.shadowBlur = 15;
                    // Outer glow
                    ctx.strokeStyle = frame % 40 < 20 ? '#f0f' : '#0ff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(-o.width / 2, -o.height / 2, o.width, o.height);
                    // Inner fill
                    ctx.fillStyle = 'rgba(50, 0, 80, 0.7)';
                    ctx.fillRect(-o.width / 2, -o.height / 2, o.width, o.height);
                    // Warning symbol - triangle
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(12, 10);
                    ctx.lineTo(-12, 10);
                    ctx.closePath();
                    ctx.fill();
                    // Exclamation mark
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-2, -8, 4, 10);
                    ctx.beginPath();
                    ctx.arc(0, 7, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (o.type === 'drone_cam') {
                    // Sleek surveillance drone
                    ctx.rotate(Math.sin(frame * 0.05) * 0.2);
                    // Body glow
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 15;
                    // Main body
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Top dome
                    ctx.fillStyle = '#3a3a3a';
                    ctx.beginPath();
                    ctx.ellipse(0, -3, 10, 6, 0, Math.PI, Math.PI * 2);
                    ctx.fill();
                    // Propeller arms
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-25, -2, 12, 4);
                    ctx.fillRect(13, -2, 12, 4);
                    // Spinning props
                    ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(-19, 0, 8, frame * 0.5, frame * 0.5 + Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(19, 0, 8, -frame * 0.5, -frame * 0.5 + Math.PI);
                    ctx.stroke();
                    // Camera eye
                    ctx.fillStyle = frame % 20 < 10 ? '#f00' : '#a00';
                    ctx.beginPath();
                    ctx.arc(0, 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Recording indicator
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(-7, -6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (o.type === 'sandstorm_obj') {
                    ctx.globalAlpha = 0.6;
                    ctx.rotate(o.rotation);
                    ctx.fillStyle = '#a85';
                    ctx.beginPath();
                    ctx.arc(0, 0, o.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Swirl lines
                    ctx.strokeStyle = '#c96';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (o.type === 'cactus') {
                    ctx.fillStyle = '#2a5';
                    ctx.fillRect(-5, -o.height / 2, 10, o.height);
                    // Arms
                    ctx.fillRect(-20, -10, 15, 8);
                    ctx.fillRect(-20, -10, 8, -20);
                    ctx.fillRect(5, 0, 15, 8);
                    ctx.fillRect(12, 0, 8, -15);
                }

                ctx.restore();
            });
        }

        function spawnMiniBoss() {
            const mbType = miniBossTypes[Math.floor(Math.random() * miniBossTypes.length)];
            playSound('boss');
            floatingTexts.push({
                x: canvas.width / 2, y: 150,
                text: '‚ö† ' + mbType.name + ' ‚ö†', color: '#f80', life: 120, size: 16
            });

            miniBoss = {
                x: canvas.width + 50,
                y: canvas.height / 2 - mbType.height / 2,
                width: mbType.width,
                height: mbType.height,
                speed: 2,
                health: mbType.health + level * 5,
                maxHealth: mbType.health + level * 5,
                name: mbType.name,
                type: mbType.name,
                color: mbType.color,
                bullets: [],
                lastShot: 0,
                shootCooldown: 40,
                escort: mbType.escort || 0,
                bombRate: mbType.bombRate || 0,
                cloakDuration: mbType.cloakDuration || 0,
                cloaked: false,
                cloakTimer: 0,
                escortSpawned: false
            };

            // Spawn escort for Strike Leader
            if (miniBoss.escort > 0) {
                for (let i = 0; i < miniBoss.escort; i++) {
                    setTimeout(() => {
                        if (miniBoss) {
                            const escort = createEnemy('fighter', canvas.width + 80, miniBoss.y + (i - 1) * 50);
                            escort.isEscort = true;
                            enemies.push(escort);
                        }
                    }, 500 + i * 300);
                }
            }
        }

        function spawnMine(x, y) {
            mines.push({
                x, y,
                radius: 12,
                timer: 300, // 5 seconds
                pulse: 0,
                armed: false
            });
        }

        const bossTypes = [
            { name: 'MEGA BOMBER', color: '#2a4a2a', width: 220, height: 160, healthMult: 1, specialAttack: 'carpet_bomb' },
            { name: 'CYBER FORTRESS', color: '#2a2a4a', width: 250, height: 180, healthMult: 1.5, specialAttack: 'laser_sweep' },
            { name: 'DEATH MACHINE', color: '#4a2a2a', width: 200, height: 200, healthMult: 2, specialAttack: 'transform' }
        ];

        // Boss music settings per phase
        let bossMusicBPM = 120;
        let bossMusicPhase = 1;
        let bossMusicInterval = null;

        function startBossMusic(phase) {
            bossMusicPhase = phase;
            bossMusicBPM = phase === 1 ? 120 : phase === 2 ? 140 : 160;
            if (bossMusicInterval) clearInterval(bossMusicInterval);
            bossMusicInterval = setInterval(playBossMusicBeat, 60000 / bossMusicBPM / 4);
        }

        function stopBossMusic() {
            if (bossMusicInterval) {
                clearInterval(bossMusicInterval);
                bossMusicInterval = null;
            }
        }

        let bossMusicBeat = 0;
        function playBossMusicBeat() {
            if (!audioCtx || !boss) return;
            const now = audioCtx.currentTime;
            const phase = bossMusicPhase;

            // Kick drum on beats 0, 4, 8, 12
            if (bossMusicBeat % 4 === 0) {
                const kick = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kick.connect(kickGain);
                kickGain.connect(audioCtx.destination);
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, now);
                kick.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                kickGain.gain.setValueAtTime(0.25, now);
                kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                kick.start(now);
                kick.stop(now + 0.1);
            }

            // Bass on every beat (phase 1+)
            if (bossMusicBeat % 2 === 0) {
                const bass = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                bass.connect(bassGain);
                bassGain.connect(audioCtx.destination);
                bass.type = 'sawtooth';
                const bassNotes = [55, 55, 65, 55, 55, 55, 73, 65];
                bass.frequency.setValueAtTime(bassNotes[Math.floor(bossMusicBeat/2) % 8], now);
                bassGain.gain.setValueAtTime(0.12, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                bass.start(now);
                bass.stop(now + 0.15);
            }

            // Hi-hat (phase 2+)
            if (phase >= 2 && bossMusicBeat % 2 === 1) {
                const hat = audioCtx.createOscillator();
                const hatGain = audioCtx.createGain();
                hat.connect(hatGain);
                hatGain.connect(audioCtx.destination);
                hat.type = 'square';
                hat.frequency.setValueAtTime(1000 + Math.random() * 500, now);
                hatGain.gain.setValueAtTime(0.04, now);
                hatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                hat.start(now);
                hat.stop(now + 0.02);
            }

            // Melody (phase 2+)
            if (phase >= 2 && bossMusicBeat % 4 === 0) {
                const mel = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();
                mel.connect(melGain);
                melGain.connect(audioCtx.destination);
                mel.type = 'square';
                const melodyNotes = [330, 392, 440, 392, 330, 294, 330, 392];
                mel.frequency.setValueAtTime(melodyNotes[Math.floor(bossMusicBeat/4) % 8], now);
                melGain.gain.setValueAtTime(0.06, now);
                melGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                mel.start(now);
                mel.stop(now + 0.1);
            }

            // Arpeggio (phase 3)
            if (phase === 3) {
                const arpNotes = [220, 277, 330, 440];
                const arp = audioCtx.createOscillator();
                const arpGain = audioCtx.createGain();
                arp.connect(arpGain);
                arpGain.connect(audioCtx.destination);
                arp.type = 'sine';
                arp.frequency.setValueAtTime(arpNotes[bossMusicBeat % 4], now);
                arpGain.gain.setValueAtTime(0.08, now);
                arpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                arp.start(now);
                arp.stop(now + 0.05);
            }

            // Tension notes (phase 3)
            if (phase === 3 && bossMusicBeat % 8 === 0) {
                const tension = audioCtx.createOscillator();
                const tensionGain = audioCtx.createGain();
                tension.connect(tensionGain);
                tensionGain.connect(audioCtx.destination);
                tension.type = 'sawtooth';
                tension.frequency.setValueAtTime(110, now);
                tension.frequency.linearRampToValueAtTime(220, now + 0.3);
                tensionGain.gain.setValueAtTime(0.1, now);
                tensionGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                tension.start(now);
                tension.stop(now + 0.3);
            }

            bossMusicBeat++;
        }

        function playPhaseTransition() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            // Drop effect - dramatic pause then hit
            [0, 200, 400].forEach((delay, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(110 * (i + 1), audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                }, delay);
            });
        }

        function spawnBoss() {
            playSound('boss');
            playVoice('BOSS INCOMING');
            bossWarning = 150;
            weather.lightning = 60;

            const bt = bossTypes[bossType % 3];
            const baseHealth = (100 + level * 30) * bt.healthMult;

            boss = {
                x: canvas.width + 100,
                y: canvas.height / 2 - bt.height/2,
                width: bt.width,
                height: bt.height,
                speed: 1,
                health: baseHealth,
                maxHealth: baseHealth,
                bullets: [],
                lastShot: Date.now(),
                // Enhanced turrets with individual health
                turrets: [
                    { x: 30, y: 30, lastShot: 0, health: 25, maxHealth: 25, alive: true },
                    { x: 30, y: bt.height - 30, lastShot: 0, health: 25, maxHealth: 25, alive: true },
                    { x: bt.width - 40, y: bt.height/2, lastShot: 0, health: 25, maxHealth: 25, alive: true }
                ],
                // Engines - weak points
                engines: [
                    { x: bt.width - 20, y: 20, health: 20, maxHealth: 20, destroyed: false },
                    { x: bt.width - 20, y: bt.height - 40, health: 20, maxHealth: 20, destroyed: false }
                ],
                // Core - exposed when 2+ turrets destroyed
                core: { x: bt.width/2 - 25, y: bt.height/2 - 25, width: 50, height: 50, exposed: false },
                // Phase system (1, 2, 3)
                currentPhase: 1,
                phase: 0, // attack pattern phase
                phaseTimer: 0,
                lastPhaseChange: 0,
                type: bossType % 3,
                name: bt.name,
                color: bt.color,
                specialAttack: bt.specialAttack,
                enraged: false,
                specialAttackTimer: 0,
                transformState: 0 // for Death Machine
            };

            bossType++;
            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').style.display = 'block';
            document.getElementById('bossName').textContent = `‚òÖ ${bt.name} Mk.${Math.ceil(level/5)} ‚òÖ`;

            // Start phase 1 music
            startBossMusic(1);
        }

        function updateBossPhase() {
            if (!boss) return;
            const healthPercent = boss.health / boss.maxHealth;
            let newPhase = boss.currentPhase;

            if (healthPercent > 0.66) newPhase = 1;
            else if (healthPercent > 0.33) newPhase = 2;
            else newPhase = 3;

            if (newPhase !== boss.currentPhase) {
                boss.currentPhase = newPhase;
                boss.lastPhaseChange = frame;
                playPhaseTransition();
                startBossMusic(newPhase);
                screenShake = 20;

                // Phase transition effects
                const phaseName = newPhase === 2 ? 'PHASE 2: AGGRESSION!' : 'PHASE 3: BERSERK!';
                floatingTexts.push({
                    x: boss.x + boss.width/2, y: boss.y - 50,
                    text: phaseName, color: newPhase === 3 ? '#f00' : '#ff0', life: 120, size: 18
                });

                // Drop loot on phase change
                if (newPhase === 2) {
                    dropBossLoot(boss.x + boss.width/2, boss.y + boss.height/2, 'life');
                } else if (newPhase === 3) {
                    dropBossLoot(boss.x + boss.width/2, boss.y + boss.height/2, 'bomb');
                    boss.enraged = true;
                }

                playVoice(newPhase === 2 ? 'UNSTOPPABLE' : 'GODLIKE');
            }

            // Check if core should be exposed
            const aliveTurrets = boss.turrets.filter(t => t.alive).length;
            boss.core.exposed = aliveTurrets <= 1;
        }

        function dropBossLoot(x, y, type) {
            const colors = { life: '#f0f', bomb: '#f80', rocket: '#fa0', rapid: '#ff0', spread: '#00f', shield: '#0f0' };
            powerups.push({
                x, y,
                type: type || ['rapid', 'spread', 'shield', 'rocket'][Math.floor(Math.random() * 4)],
                color: colors[type] || '#ff0',
                width: 28, height: 28, vy: -3, pulse: 0,
                fromBoss: true
            });

            // Sparkle effect
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 40,
                    color: '#ff0',
                    size: 4
                });
            }
        }

        function hitBossComponent(bullet) {
            if (!boss) return false;
            const b = boss;
            const bx = bullet.x, by = bullet.y;
            const damage = bullet.damage || 1;
            let hit = false;

            // Check turrets
            for (let t of b.turrets) {
                if (!t.alive) continue;
                const tx = b.x + t.x, ty = b.y + t.y;
                if (Math.hypot(bx - tx, by - ty) < 20) {
                    t.health -= damage;
                    hit = true;
                    if (t.health <= 0) {
                        t.alive = false;
                        createExplosion(tx, ty, true);
                        floatingTexts.push({ x: tx, y: ty - 20, text: 'TURRET DOWN!', color: '#0ff', life: 60, size: 12 });
                        score += 500;
                        playSound('megaExplosion');
                        if (Math.random() < 0.4) dropBossLoot(tx, ty);
                    }
                    break;
                }
            }

            // Check engines (2x damage)
            if (!hit) {
                for (let e of b.engines) {
                    if (e.destroyed) continue;
                    const ex = b.x + e.x, ey = b.y + e.y;
                    if (Math.abs(bx - ex) < 25 && Math.abs(by - ey) < 25) {
                        e.health -= damage * 2;
                        b.health -= damage; // Also damages main health
                        hit = true;
                        if (e.health <= 0) {
                            e.destroyed = true;
                            createExplosion(ex, ey, true);
                            b.speed *= 0.7; // Slow down boss
                            floatingTexts.push({ x: ex, y: ey - 20, text: 'ENGINE HIT!', color: '#f80', life: 60, size: 12 });
                            score += 300;
                            dropBossLoot(ex, ey, 'rocket');
                        }
                        break;
                    }
                }
            }

            // Check core (3x damage when exposed)
            if (!hit && b.core.exposed) {
                const cx = b.x + b.core.x + b.core.width/2;
                const cy = b.y + b.core.y + b.core.height/2;
                if (Math.abs(bx - cx) < b.core.width/2 + 10 && Math.abs(by - cy) < b.core.height/2 + 10) {
                    b.health -= damage * 3;
                    hit = true;
                    floatingTexts.push({ x: cx, y: cy - 30, text: 'CRITICAL!', color: '#f00', life: 30, size: 14 });
                }
            }

            // Normal hit on body
            if (!hit) {
                if (bx > b.x && bx < b.x + b.width && by > b.y && by < b.y + b.height) {
                    b.health -= damage;
                    hit = true;
                }
            }

            return hit;
        }

        function bossSpecialAttack() {
            if (!boss || boss.currentPhase < 3) return;
            const b = boss;

            if (b.specialAttack === 'carpet_bomb') {
                // Mega Bomber: rain of bombs from above
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        if (!boss) return;
                        const bx = 100 + Math.random() * (canvas.width - 200);
                        b.bullets.push({
                            x: bx, y: -20,
                            width: 16, height: 16,
                            speed: 4 + Math.random() * 2,
                            angle: Math.PI / 2,
                            isBomb: true
                        });
                    }, i * 150);
                }
            } else if (b.specialAttack === 'laser_sweep') {
                // Cyber Fortress: horizontal laser sweep
                b.laserSweep = { active: true, y: b.y + 30, direction: 1, timer: 60 };
            } else if (b.specialAttack === 'transform') {
                // Death Machine: transformation
                b.transformState = (b.transformState + 1) % 3;
                floatingTexts.push({
                    x: b.x + b.width/2, y: b.y - 30,
                    text: 'TRANSFORM!', color: '#f0f', life: 60, size: 16
                });
                screenShake = 15;
                // Change attack pattern
                if (b.transformState === 1) {
                    // Rapid fire mode
                    b.turrets.forEach(t => { if (t.alive) t.fireRate = 0.5; });
                } else if (b.transformState === 2) {
                    // Spiral attack
                    for (let i = 0; i < 16; i++) {
                        setTimeout(() => {
                            if (!boss) return;
                            const angle = (i / 16) * Math.PI * 2;
                            b.bullets.push({
                                x: b.x + b.width/2, y: b.y + b.height/2,
                                width: 10, height: 10, speed: 4, angle
                            });
                        }, i * 50);
                    }
                }
            }
        }

        // ============ DRAWING ============
        function drawNeonGlow(x, y, w, h, color, intensity = 1) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * intensity;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 2, y - 2, w + 4, h + 4);
            ctx.shadowBlur = 0;
        }

        function drawPixelPlane(x, y, w, h, type, damaged = false, glowColor = '#fff', enemy = null) {
            const colors = {
                fighter: { body: '#4a7dc4', dark: '#2d5a9e', cockpit: '#adf', accent: '#f44' },
                bomber: { body: '#5a7e23', dark: '#3a5e12', cockpit: '#adf', accent: '#fa0' },
                jet: { body: '#9b1010', dark: '#6b0000', cockpit: '#adf', accent: '#f60' },
                helicopter: { body: '#c55', dark: '#933', cockpit: '#adf', accent: '#ff0' },
                turret: { body: '#666', dark: '#444', cockpit: '#f00', accent: '#ff0' },
                drone: { body: '#808', dark: '#606', cockpit: '#f0f', accent: '#0ff' },
                // NEW ENEMY COLORS
                kamikaze: { body: '#c22', dark: '#811', cockpit: '#f88', accent: '#ff0' },
                blinker: { body: '#2cc', dark: '#1aa', cockpit: '#8ff', accent: '#fff' },
                shielder: { body: '#22c', dark: '#119', cockpit: '#88f', accent: '#0ff' },
                miner: { body: '#2a2', dark: '#181', cockpit: '#8f8', accent: '#ff0' },
                scout: { body: '#cc2', dark: '#991', cockpit: '#ff8', accent: '#fff' },
                // MEGA ENEMIES
                teleporter: { body: '#808', dark: '#505', cockpit: '#f0f', accent: '#fff' },
                splitter: { body: '#0a8', dark: '#064', cockpit: '#0ff', accent: '#fff' },
                splitter_mini: { body: '#0a8', dark: '#064', cockpit: '#0ff', accent: '#fff' },
                healer: { body: '#0a0', dark: '#060', cockpit: '#0f0', accent: '#fff' },
                reflector: { body: '#888', dark: '#555', cockpit: '#ccc', accent: '#fff' },
                suicide_bomber: { body: '#f60', dark: '#a40', cockpit: '#ff0', accent: '#f00' },
                // ADVANCED ENEMIES
                phantom: { body: '#a080ff', dark: '#6040a0', cockpit: '#ff4040', accent: '#fff' },
                laserDrone: { body: '#400', dark: '#200', cockpit: '#f00', accent: '#ff0' },
                gravityWell: { body: '#004', dark: '#002', cockpit: '#08f', accent: '#fff' },
                mirror: { body: '#ddd', dark: '#aaa', cockpit: '#fff', accent: '#0ff' },
                spawner: { body: '#a80', dark: '#640', cockpit: '#ff0', accent: '#fff' },
                bee: { body: '#fc0', dark: '#420', cockpit: '#ff0', accent: '#000' },
                teslaCoil: { body: '#068', dark: '#024', cockpit: '#0ff', accent: '#fff' }
            };
            const c = colors[type] || colors.fighter;

            ctx.save();
            if (damaged && frame % 4 < 2) ctx.globalAlpha = 0.5;

            // Neon glow
            if (combo >= 10) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 10;
            }

            if (type === 'turret') {
                ctx.fillStyle = c.dark;
                ctx.fillRect(x, y + h*0.5, w, h*0.5);
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.25, y, w*0.5, h*0.6);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.35, y - h*0.3, w*0.3, h*0.4);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.4, y + h*0.15, w*0.2, h*0.15);
            } else if (type === 'helicopter') {
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.12, y + h*0.28, w*0.65, h*0.44);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.72, y + h*0.32, w*0.28, h*0.36);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.02, y + h*0.32, w*0.14, h*0.36);
                // Rotor animation
                ctx.fillStyle = '#888';
                if (frame % 3 === 0) {
                    ctx.fillRect(x - w*0.1, y + h*0.08, w*0.9, h*0.12);
                } else {
                    ctx.fillRect(x + w*0.1, y + h*0.08, w*0.5, h*0.12);
                }
            } else if (type === 'drone') {
                // Circular drone
                ctx.fillStyle = c.body;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = c.cockpit;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.2, 0, Math.PI * 2);
                ctx.fill();
                // Spinning blades
                ctx.fillStyle = '#888';
                const angle = frame * 0.3;
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.translate(x + w/2, y + h/2);
                    ctx.rotate(angle + i * Math.PI/2);
                    ctx.fillRect(-w*0.1, -h*0.5, w*0.2, h*0.3);
                    ctx.restore();
                }
            } else if (type === 'phantom') {
                // PHANTOM - Ghost with wavy edges
                const alpha = enemy && !enemy.phantomVisible ? 0.2 : 0.7;
                ctx.globalAlpha *= alpha;

                // Ghostly body with wavy effect
                ctx.fillStyle = c.body;
                ctx.beginPath();
                ctx.moveTo(x + w*0.2, y + h*0.1);
                ctx.quadraticCurveTo(x + w*0.5, y - h*0.1, x + w*0.8, y + h*0.1);
                ctx.lineTo(x + w*0.85, y + h*0.6);
                // Wavy bottom
                for (let i = 0; i < 4; i++) {
                    const wx = x + w*0.85 - (w*0.7/4) * i;
                    const wy = y + h*0.8 + Math.sin(frame*0.1 + i) * h*0.1;
                    ctx.lineTo(wx, wy);
                }
                ctx.lineTo(x + w*0.15, y + h*0.6);
                ctx.closePath();
                ctx.fill();

                // Glowing eyes
                ctx.fillStyle = c.cockpit;
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 10;
                ctx.fillRect(x + w*0.3, y + h*0.25, w*0.15, h*0.12);
                ctx.fillRect(x + w*0.55, y + h*0.25, w*0.15, h*0.12);
                ctx.shadowBlur = 0;

            } else if (type === 'laserDrone') {
                // LASER DRONE - Circular with big red eye
                const charging = enemy && enemy.laserCharging > 0;

                // Outer ring
                ctx.fillStyle = c.dark;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.45, 0, Math.PI * 2);
                ctx.fill();

                // Inner body
                ctx.fillStyle = c.body;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, w*0.35, 0, Math.PI * 2);
                ctx.fill();

                // Central eye - pulsing when charging
                const eyeSize = charging ? w*0.25 + Math.sin(frame*0.3)*w*0.05 : w*0.2;
                ctx.fillStyle = c.cockpit;
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = charging ? 20 : 5;
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Eye pupil
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x + w/2, y + h/2, eyeSize*0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

            } else if (type === 'gravityWell') {
                // GRAVITY WELL - Black hole with accretion disk
                const cx = x + w/2, cy = y + h/2;

                // Outer glow/accretion disk
                for (let i = 3; i >= 0; i--) {
                    const alpha = 0.3 - i*0.05;
                    ctx.fillStyle = `rgba(0, 128, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, w*0.5 - i*3, h*0.25 - i*2, frame*0.02, 0, Math.PI*2);
                    ctx.fill();
                }

                // Event horizon (black center)
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(cx, cy, w*0.25, 0, Math.PI * 2);
                ctx.fill();

                // Spinning particles
                ctx.fillStyle = c.cockpit;
                for (let i = 0; i < 6; i++) {
                    const angle = frame*0.05 + i*Math.PI/3;
                    const dist = w*0.35;
                    const px = cx + Math.cos(angle) * dist;
                    const py = cy + Math.sin(angle) * dist * 0.5;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI*2);
                    ctx.fill();
                }

            } else if (type === 'mirror') {
                // MIRROR - Vertical reflective panel
                const isOpen = enemy && enemy.mirrorOpen;
                const flashPhase = enemy && enemy.mirrorTimer < 30;

                // Frame
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.2, y, w*0.6, h);

                // Reflective surface with gradient
                const grad = ctx.createLinearGradient(x, y, x + w, y);
                grad.addColorStop(0, '#666');
                grad.addColorStop(0.3, '#fff');
                grad.addColorStop(0.5, '#ddd');
                grad.addColorStop(0.7, '#fff');
                grad.addColorStop(1, '#888');

                ctx.fillStyle = isOpen ? '#444' : grad;
                ctx.fillRect(x + w*0.25, y + h*0.05, w*0.5, h*0.9);

                // Flashing warning before opening
                if (flashPhase && frame % 10 < 5) {
                    ctx.fillStyle = 'rgba(255,255,0,0.5)';
                    ctx.fillRect(x + w*0.25, y + h*0.05, w*0.5, h*0.9);
                }

                // Sparkles on surface
                if (!isOpen) {
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 3; i++) {
                        const sx = x + w*0.3 + Math.sin(frame*0.1 + i*2) * w*0.2;
                        const sy = y + h*0.2 + i*h*0.25;
                        ctx.fillRect(sx, sy, 3, 3);
                    }
                }

            } else if (type === 'spawner') {
                // SPAWNER - Hexagonal hive
                const cx = x + w/2, cy = y + h/2;

                // Outer hexagon
                ctx.fillStyle = c.body;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3 - Math.PI/6;
                    const px = cx + Math.cos(angle) * w*0.45;
                    const py = cy + Math.sin(angle) * h*0.45;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                // Honeycomb pattern inside
                ctx.strokeStyle = c.dark;
                ctx.lineWidth = 2;
                const cellSize = w * 0.12;
                for (let row = -1; row <= 1; row++) {
                    for (let col = -1; col <= 1; col++) {
                        const hx = cx + col * cellSize * 1.5;
                        const hy = cy + row * cellSize * 1.3 + (col % 2) * cellSize * 0.65;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const a = i * Math.PI / 3;
                            const px = hx + Math.cos(a) * cellSize * 0.5;
                            const py = hy + Math.sin(a) * cellSize * 0.5;
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                }

                // Central opening (yellow glow)
                ctx.fillStyle = c.cockpit;
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(cx, cy, w*0.1, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;

            } else if (type === 'bee') {
                // BEE - Small yellow-black striped
                const cx = x + w/2, cy = y + h/2;

                // Body (oval)
                ctx.fillStyle = c.body;
                ctx.beginPath();
                ctx.ellipse(cx, cy, w*0.4, h*0.35, 0, 0, Math.PI*2);
                ctx.fill();

                // Black stripes
                ctx.fillStyle = c.accent;
                ctx.fillRect(x + w*0.35, y + h*0.25, w*0.1, h*0.5);
                ctx.fillRect(x + w*0.55, y + h*0.25, w*0.1, h*0.5);

                // Wings (animated)
                ctx.fillStyle = 'rgba(200,200,255,0.6)';
                const wingAngle = Math.sin(frame * 0.8) * 0.3;
                ctx.save();
                ctx.translate(cx, cy - h*0.2);
                ctx.rotate(wingAngle);
                ctx.beginPath();
                ctx.ellipse(0, -h*0.15, w*0.2, h*0.1, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
                ctx.save();
                ctx.translate(cx, cy - h*0.2);
                ctx.rotate(-wingAngle);
                ctx.beginPath();
                ctx.ellipse(0, -h*0.15, w*0.2, h*0.1, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();

                // Head
                ctx.fillStyle = c.dark;
                ctx.beginPath();
                ctx.arc(x + w*0.2, cy, w*0.15, 0, Math.PI*2);
                ctx.fill();

            } else if (type === 'teslaCoil') {
                // TESLA COIL - Vertical coil with spheres
                const cx = x + w/2, cy = y + h/2;

                // Base
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.2, y + h*0.75, w*0.6, h*0.25);

                // Coil body
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.35, y + h*0.2, w*0.3, h*0.6);

                // Coil windings
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const yy = y + h*0.25 + i * h*0.065;
                    ctx.beginPath();
                    ctx.moveTo(x + w*0.3, yy);
                    ctx.lineTo(x + w*0.7, yy);
                    ctx.stroke();
                }

                // Top sphere
                ctx.fillStyle = c.cockpit;
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(cx, y + h*0.12, w*0.18, 0, Math.PI*2);
                ctx.fill();

                // Electric arcs between spheres
                if (frame % 5 < 3) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - w*0.1, y + h*0.2);
                    ctx.lineTo(cx - w*0.15 + Math.random()*w*0.1, y + h*0.35);
                    ctx.lineTo(cx - w*0.05 + Math.random()*w*0.1, y + h*0.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cx + w*0.1, y + h*0.2);
                    ctx.lineTo(cx + w*0.05 + Math.random()*w*0.1, y + h*0.4);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

            } else {
                // Standard planes
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.2, y + h*0.28, w*0.55, h*0.44);
                ctx.fillRect(x, y + h*0.32, w*0.25, h*0.36);
                ctx.fillStyle = c.dark;
                ctx.fillRect(x + w*0.7, y + h*0.18, w*0.3, h*0.64);
                ctx.fillStyle = c.body;
                ctx.fillRect(x + w*0.25, y - h*0.05, w*0.35, h*1.1);
                ctx.fillStyle = c.cockpit;
                ctx.fillRect(x + w*0.1, y + h*0.38, w*0.18, h*0.24);
                ctx.fillStyle = c.accent;
                if (frame % 6 < 3) {
                    ctx.fillRect(x + w*0.92, y + h*0.38, w*0.15, h*0.24);
                }
            }

            ctx.restore();
        }

        function drawBoss() {
            if (!boss) return;
            const b = boss;
            const bt = bossTypes[b.type];

            ctx.save();

            // Phase-based visual effects
            if (b.currentPhase === 3) {
                // Berserk glow - intense pulsing
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 40 + Math.sin(frame * 0.3) * 20;
            } else if (b.currentPhase === 2) {
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 20 + Math.sin(frame * 0.15) * 10;
            }

            // Main body with neon outline
            ctx.fillStyle = bt.color;
            ctx.fillRect(b.x + 20, b.y + 30, b.width - 40, b.height - 60);

            // Phase-colored outline
            const phaseColors = ['#0ff', '#ff0', '#f00'];
            ctx.strokeStyle = phaseColors[b.currentPhase - 1];
            ctx.lineWidth = b.currentPhase === 3 ? 4 : 2;
            ctx.strokeRect(b.x + 20, b.y + 30, b.width - 40, b.height - 60);

            // Wings
            ctx.fillStyle = b.type === 1 ? '#1a1a3a' : b.type === 2 ? '#3a1a1a' : '#1a3a1a';
            ctx.fillRect(b.x + 50, b.y, b.width - 100, b.height);

            // Cockpit
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 10;
            ctx.fillRect(b.x + 15, b.y + b.height/2 - 20, 35, 40);
            ctx.shadowBlur = 0;

            // Draw engines (weak points)
            b.engines.forEach((eng, i) => {
                const ex = b.x + eng.x;
                const ey = b.y + eng.y;

                if (eng.destroyed) {
                    // Destroyed engine - smoke and fire
                    ctx.fillStyle = '#222';
                    ctx.fillRect(ex - 15, ey, 30, 20);
                    if (frame % 4 === 0) {
                        particles.push({
                            x: ex, y: ey + 10,
                            vx: 2 + Math.random(), vy: -1 - Math.random(),
                            life: 30, color: '#333', size: 8
                        });
                    }
                } else {
                    // Active engine with weak point indicator
                    ctx.fillStyle = '#444';
                    ctx.fillRect(ex - 15, ey, 30, 20);

                    // Pulsing weak point indicator
                    const pulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 150, 0, ${pulse})`;
                    ctx.shadowColor = '#f80';
                    ctx.shadowBlur = 10;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(ex - 18, ey - 3, 36, 26);
                    ctx.shadowBlur = 0;

                    // Flame
                    const flameLen = 15 + Math.random() * 25;
                    const gradient = ctx.createLinearGradient(ex + 15, ey, ex + 15 + flameLen, ey);
                    gradient.addColorStop(0, '#fff');
                    gradient.addColorStop(0.3, '#ff0');
                    gradient.addColorStop(0.6, '#f80');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(ex + 15, ey + 3, flameLen, 14);

                    // Engine health bar
                    const healthPct = eng.health / eng.maxHealth;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(ex - 15, ey - 8, 30, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(ex - 15, ey - 8, 30 * healthPct, 4);
                }
            });

            // Draw core (when exposed)
            if (b.core.exposed) {
                const cx = b.x + b.core.x;
                const cy = b.y + b.core.y;

                // Pulsing critical weak point
                const corePulse = Math.sin(frame * 0.2) * 0.4 + 0.6;
                ctx.fillStyle = `rgba(255, 0, 0, ${corePulse * 0.5})`;
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;
                ctx.fillRect(cx, cy, b.core.width, b.core.height);

                // Core border
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.strokeRect(cx, cy, b.core.width, b.core.height);

                // "WEAK POINT" indicator
                ctx.fillStyle = '#f00';
                ctx.font = '8px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('WEAK', cx + b.core.width/2, cy - 5);
                ctx.shadowBlur = 0;
            }

            // Draw turrets (with individual health)
            b.turrets.forEach(t => {
                const tx = b.x + t.x;
                const ty = b.y + t.y;

                if (!t.alive) {
                    // Destroyed turret - wreckage
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 12, 0, Math.PI * 2);
                    ctx.fill();
                    // Smoke
                    if (frame % 8 === 0) {
                        particles.push({
                            x: tx, y: ty, vx: Math.random() - 0.5, vy: -2,
                            life: 25, color: '#444', size: 6
                        });
                    }
                } else {
                    // Active turret
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 18, 0, Math.PI * 2);
                    ctx.fill();

                    // Turret glow based on phase
                    const turretColor = b.currentPhase === 3 ? '#f00' : b.currentPhase === 2 ? '#f80' : '#f0f';
                    ctx.fillStyle = turretColor;
                    ctx.shadowColor = turretColor;
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(tx, ty, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Turret health bar
                    const healthPct = t.health / t.maxHealth;
                    ctx.fillStyle = '#300';
                    ctx.fillRect(tx - 15, ty - 25, 30, 4);
                    ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(tx - 15, ty - 25, 30 * healthPct, 4);
                }
            });

            // Phase 2+ damage smoke
            if (b.currentPhase >= 2) {
                if (frame % 4 === 0) {
                    particles.push({
                        x: b.x + Math.random() * b.width,
                        y: b.y + Math.random() * b.height,
                        vx: -2 + Math.random(), vy: -3 - Math.random() * 2,
                        life: 50, color: '#333', size: 12 + Math.random() * 8
                    });
                }
            }

            // Phase 3 fire effects
            if (b.currentPhase === 3) {
                if (frame % 2 === 0) {
                    particles.push({
                        x: b.x + 30 + Math.random() * (b.width - 60),
                        y: b.y + Math.random() * b.height,
                        vx: Math.random() - 0.5, vy: -3,
                        life: 25,
                        color: ['#f00', '#f80', '#ff0'][Math.floor(Math.random() * 3)],
                        size: 10 + Math.random() * 8
                    });
                }
            }

            // Laser sweep (Cyber Fortress special)
            if (b.laserSweep && b.laserSweep.active) {
                ctx.strokeStyle = '#f00';
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(b.x + 30, b.laserSweep.y);
                ctx.lineTo(0, b.laserSweep.y);
                ctx.stroke();

                // Warning line
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.lineWidth = 20;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.restore();

            // Update phase indicator in health bar
            const phaseText = `PHASE ${b.currentPhase}`;
            const bossNameEl = document.getElementById('bossName');
            if (bossNameEl) bossNameEl.textContent = `‚òÖ ${b.name} - ${phaseText} ‚òÖ`;

            // Health bar update with phase colors
            const healthPercent = b.health / b.maxHealth * 100;
            const hpBar = document.getElementById('bossHealthBar');
            if (hpBar) {
                hpBar.style.width = healthPercent + '%';
                hpBar.style.background = b.currentPhase === 3 ? 'linear-gradient(90deg, #f00, #ff0, #f00)' :
                                         b.currentPhase === 2 ? 'linear-gradient(90deg, #f80, #ff0, #f80)' :
                                         'linear-gradient(90deg, #0f0, #ff0, #0f0)';
            }
        }

        const MAX_PARTICLES = 200; // Limit particles to prevent lag

        function createExplosion(x, y, large = false) {
            explosions.push({ x, y, frame: 0, maxFrames: 12, size: large ? 128 : 64 });
            playSound(large ? 'megaExplosion' : 'explosion');
            if (large) {
                screenShake = Math.max(screenShake, 15);
                shockwaves.push({ x, y, radius: 0, maxRadius: 150, speed: 8, color: '#f80' });
            }

            // Reduce particle count if we're at the limit
            const baseCount = large ? 20 : 10;
            const count = particles.length > MAX_PARTICLES ? Math.floor(baseCount / 2) : baseCount;

            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * (large ? 16 : 10),
                    vy: (Math.random() - 0.5) * (large ? 16 : 10),
                    life: 40 + Math.random() * 30,
                    color: ['#ff0', '#f80', '#f00', '#fff', '#f0f'][Math.floor(Math.random() * 5)],
                    size: Math.random() * 6 + 3
                });
            }

            // Hard limit - remove oldest particles if over limit
            if (particles.length > MAX_PARTICLES) {
                particles.splice(0, particles.length - MAX_PARTICLES);
            }
        }

        function addCombo() {
            combo++;
            comboTimer = 180;
            killStreak++;
            killStreakTimer = 60;

            // Slow motion trigger
            if (killStreak >= 5) {
                triggerSlowMotion();
                killStreak = 0;
            }

            if (combo >= 20) {
                comboMultiplier = 8;
                if (combo === 20) { playVoice('GODLIKE'); }
                if (combo === 25) { unlockAchievement('combo_25'); }
            } else if (combo >= 10) {
                comboMultiplier = 4;
                if (combo === 10) { playVoice('UNSTOPPABLE'); unlockAchievement('combo_10'); }
            } else if (combo >= 5) {
                comboMultiplier = 2;
                if (combo === 5) { playVoice('COMBO'); playSound('combo'); }
            } else {
                comboMultiplier = 1;
            }

            if (combo % 5 === 0 && combo > 0) {
                floatingTexts.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2 - 50,
                    text: combo >= 20 ? '‚òÖ GODLIKE! ‚òÖ' : combo >= 10 ? 'UNSTOPPABLE!' : 'x' + comboMultiplier + ' COMBO!',
                    color: combo >= 20 ? '#ff0' : '#f0f',
                    life: 80,
                    size: combo >= 20 ? 28 : 20
                });
            }
            updateUI();
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x &&
                   a.y < b.y + b.height && a.y + a.height > b.y;
        }

        // ============ UPDATE ============
        function update() {
            frame++;
            if (voiceCooldown > 0) voiceCooldown--;

            // Slow motion handling
            if (slowMotion > 0) {
                slowMotion--;
                slowMotionFactor = 0.3 + (1 - slowMotion/90) * 0.7;
            } else {
                slowMotionFactor = 1;
            }

            // ============ MEGA UPGRADE: Ultimate effects ============
            if (ultActive && ultTimer > 0) {
                ultTimer--;

                if (ultActive === 'bulletTime') {
                    slowMotionFactor = 0.2; // Super slow
                    // Auto-aim bullets towards enemies
                    player.bullets.forEach(b => {
                        let nearest = null, minDist = 300;
                        enemies.forEach(e => {
                            const dist = Math.hypot(e.x - b.x, e.y - b.y);
                            if (dist < minDist) { minDist = dist; nearest = e; }
                        });
                        if (nearest) {
                            const angle = Math.atan2(nearest.y + nearest.height/2 - b.y, nearest.x - b.x);
                            b.vy = Math.sin(angle) * 3;
                        }
                    });
                } else if (ultActive === 'godMode') {
                    player.invincible = 10; // Keep invincible
                }

                if (ultTimer <= 0) {
                    ultActive = null;
                    slowMotionFactor = 1;
                    updateUI();
                }
            }

            // ============ MEGA UPGRADE: Rage Mode ============
            const heli = HELICOPTERS[currentHelicopter];
            let damageMultiplier = heli.damage * (1 + permanentDamage);
            let fireRateMultiplier = 1 + permanentFireRate + perks.fireRate * 0.2;

            if (isRageMode()) {
                damageMultiplier *= 2;
                fireRateMultiplier *= 1.5;
                // Rage particles
                if (frame % 3 === 0) {
                    particles.push({
                        x: player.x - 5, y: player.y + player.height/2 + (Math.random() - 0.5) * 20,
                        vx: -4 - Math.random() * 3, vy: (Math.random() - 0.5) * 2,
                        life: 25, color: ['#f00', '#f80', '#ff0'][Math.floor(Math.random() * 3)], size: 4 + Math.random() * 4
                    });
                }
            }
            if (ultActive === 'godMode') {
                damageMultiplier *= 3;
            }

            // Store multipliers for use in damage calculations
            player.currentDamageMultiplier = damageMultiplier;
            player.currentFireRateMultiplier = fireRateMultiplier;

            // Kill streak timer
            if (killStreakTimer > 0) {
                killStreakTimer--;
                if (killStreakTimer === 0) killStreak = 0;
            }

            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                    comboMultiplier = 1;
                    updateUI();
                }
            }

            // Power-up timers
            Object.keys(activePowerups).forEach(k => {
                if (activePowerups[k] > 0) {
                    activePowerups[k]--;
                    if (activePowerups[k] === 0) {
                        if (k === 'rapid') player.shootCooldown = 180;
                        if (k === 'drone') playerDrone = null;
                        updateUI();
                    }
                }
            });

            // Drone helper
            if (playerDrone && activePowerups.drone > 0) {
                // Follow player
                playerDrone.x += (player.x - 40 - playerDrone.x) * 0.08;
                playerDrone.y += (player.y - 25 - playerDrone.y) * 0.08;
                // Drone shooting
                if (frame - playerDrone.lastShot > 180) {
                    player.bullets.push({
                        x: playerDrone.x + 20, y: playerDrone.y + 12,
                        width: 14, height: 5, speed: 13, vy: 0, damage: 0.7, isDroneBullet: true
                    });
                    playerDrone.lastShot = frame;
                    playSound('shoot');
                }
            }

            // Screen shake decay
            if (screenShake > 0) screenShake *= 0.9;

            // Laser charge regen (much faster recharge)
            if (!laserActive && laserCharge < 100) {
                laserCharge += 0.4;
            }

            // Weather
            if (weather.lightning > 0) weather.lightning--;
            if (weather.thunderTimer > 0) {
                weather.thunderTimer--;
                if (weather.thunderTimer === 0) playSound('thunder');
            }

            // Random lightning in hard modes
            if ((difficulty === 'hard' || difficulty === 'legendary') && Math.random() < 0.002) {
                weather.lightning = 10;
                weather.thunderTimer = 20;
            }

            // Player animation
            if (frame % 3 === 0) player.animFrame = (player.animFrame + 1) % 8;

            // Movement
            let dx = 0, dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) dy = -1;
            if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -1;
            if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

            if (touchJoystick.active) {
                dx = touchJoystick.dx;
                dy = touchJoystick.dy;
            }

            const speedMod = slowMotionFactor;
            const enemySpeedMod = speedMod * (activePowerups.timeslow > 0 ? 0.4 : 1);
            player.x += dx * player.speed * speedMod;
            player.y += dy * player.speed * speedMod;
            player.tilt = dy * 6;

            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(70, Math.min(canvas.height - player.height - 100, player.y));

            if (player.invincible > 0) player.invincible--;

            // Shooting
            const shooting = keys['Space'] || touchFire;
            const progUpgrades = getAllUpgradeEffects();
            const progSkills = getAllSkillEffects();
            const fireRateMod = (1 - perks.fireRate * 0.15) * (1 - (progUpgrades.fireRateBonus || 0));
            if (shooting && Date.now() - player.lastShot > player.shootCooldown * fireRateMod) {
                const bulletY = player.y + player.height / 2 - 3;
                let damage = (1 + perks.damage * 0.25) * (1 + (progUpgrades.damageBonus || 0));
                // Berserk mode: +50% damage at 1 HP
                if (progSkills.berserkMode && lives === 1) damage *= 1.5;
                // Critical hit chance
                if (Math.random() < (progUpgrades.critChance || 0)) {
                    damage *= (progUpgrades.critDamage || 1.5);
                    floatingTexts.push({ x: player.x + player.width, y: player.y, text: 'CRIT!', color: '#ff0', life: 20, size: 12 });
                }

                if (currentWeapon === 'laser') {
                    // Laser weapon - activate laser beam
                    if (laserCharge >= 10 && !laserActive) {
                        laserActive = true;
                        playSound('laser');
                    }
                    player.lastShot = Date.now();
                } else if (currentWeapon === 'rocket') {
                    // Rocket weapon - fire homing rockets
                    if (rocketAmmo > 0) {
                        fireRocket();
                        player.lastShot = Date.now();
                    }
                } else if (activePowerups.spread > 0 || currentWeapon === 'spread') {
                    // Spread weapon
                    for (let i = -2; i <= 2; i++) {
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY + i * 12,
                            width: 18, height: 5, speed: 14, vy: i * 1.5, damage
                        });
                    }
                    player.lastShot = Date.now();
                    playSound('shoot');
                    if (isMultiplayer && connectionReady) {
                        sendMP({ type: 'shoot', x: player.x + player.width, y: bulletY, dmg: damage });
                    }
                } else {
                    // Normal weapon
                    player.bullets.push({
                        x: player.x + player.width, y: bulletY,
                        width: 20, height: 6, speed: 14, vy: 0, damage
                    });
                    // SKILL: Double Shot
                    if (progSkills.doubleShot) {
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY + 10,
                            width: 20, height: 6, speed: 14, vy: 0.3, damage
                        });
                    }
                    // Double shot at high combo
                    if (combo >= 15) {
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY - 15,
                            width: 20, height: 6, speed: 14, vy: -1, damage
                        });
                        player.bullets.push({
                            x: player.x + player.width, y: bulletY + 15,
                            width: 20, height: 6, speed: 14, vy: 1, damage
                        });
                    }
                    player.lastShot = Date.now();
                    playSound('shoot');
                    // Multiplayer: send shoot event
                    if (isMultiplayer && connectionReady) {
                        sendMP({ type: 'shoot', x: player.x + player.width, y: bulletY, dmg: damage });
                    }
                }
            }

            // Laser weapon - SCREEN CLEAR BEAM
            if (laserActive) {
                laserCharge -= 0.25;
                if (laserCharge <= 0) {
                    laserActive = false;
                    laserCharge = 0;
                }
                updateUI();

                // Screen shake while firing
                if (frame % 3 === 0) screenShake = 3;

                const laserY = player.y + player.height / 2;
                const laserDamage = 8.0 + perks.damage; // MASSIVE damage

                // KILL ALL enemies - simple distance check from laser line
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    const enemyMidY = e.y + (e.height || 40) / 2;
                    const distFromLaser = Math.abs(enemyMidY - laserY);

                    if (distFromLaser < 100) {
                        e.health -= laserDamage;

                        // Sparks every frame
                        particles.push({
                            x: e.x + (e.width || 40) / 2,
                            y: enemyMidY,
                            vx: -8 - Math.random() * 4, vy: (Math.random() - 0.5) * 10,
                            life: 20, color: '#0ff', size: 6
                        });

                        // KILL if health <= 0
                        if (e.health <= 0) {
                            const pts = (e.points || 100) * comboMultiplier * (perks.doubleScore ? 2 : 1);
                            score += pts;
                            addCombo();
                            createExplosion(e.x + e.width / 2, e.y + e.height / 2, true);
                            playSound('explosion');
                            floatingTexts.push({
                                x: e.x + e.width / 2, y: e.y,
                                text: '+' + pts, color: '#0ff', life: 40, size: 14
                            });
                            enemies.splice(i, 1);
                            updateUI();
                        }
                    }
                }

                // Miniboss - laser melts it
                if (miniBoss) {
                    const mbY = miniBoss.y + miniBoss.height / 2;
                    if (Math.abs(mbY - laserY) < 150) {
                        miniBoss.health -= laserDamage;
                        particles.push({ x: miniBoss.x, y: mbY, vx: -8, vy: (Math.random() - 0.5) * 8, life: 25, color: '#fff', size: 8 });

                        // Kill miniboss if health depleted
                        if (miniBoss.health <= 0) {
                            createExplosion(miniBoss.x + miniBoss.width / 2, miniBoss.y + miniBoss.height / 2, true);
                            score += 1000 * comboMultiplier;
                            playSound('explosion');
                            floatingTexts.push({ x: miniBoss.x, y: miniBoss.y, text: 'MINI-BOSS DESTROYED!', color: '#f80', life: 90, size: 16 });
                            miniBoss = null;
                            updateUI();
                        }
                    }
                }

                // Boss - heavy damage
                if (boss) {
                    const bossY = boss.y + boss.height / 2;
                    if (Math.abs(bossY - laserY) < 180) {
                        boss.health -= laserDamage * 0.8;
                        particles.push({ x: boss.x, y: bossY, vx: -10, vy: (Math.random() - 0.5) * 12, life: 30, color: '#0ff', size: 10 });
                    }
                }

                // Destroy obstacles instantly
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const o = obstacles[i];
                    const oY = o.y + (o.height || 40) / 2;
                    if (Math.abs(oY - laserY) < 100) {
                        createExplosion(o.x, o.y, false);
                        obstacles.splice(i, 1);
                    }
                }

                // Destroy ALL enemy bullets!
                const laserHitY = 100; // Wide hitbox for bullets

                enemies.forEach(e => {
                    if (e.bullets && e.bullets.length > 0) {
                        e.bullets = e.bullets.filter(b => {
                            const bulletY = b.y + (b.height || 0) / 2;
                            if (Math.abs(bulletY - laserY) < laserHitY) {
                                particles.push({ x: b.x, y: bulletY, vx: -4, vy: (Math.random() - 0.5) * 4, life: 15, color: '#ff0', size: 4 });
                                return false;
                            }
                            return true;
                        });
                    }
                });

                // MiniBoss bullets
                if (miniBoss && miniBoss.bullets && miniBoss.bullets.length > 0) {
                    miniBoss.bullets = miniBoss.bullets.filter(b => {
                        const bulletY = b.y + (b.height || 0) / 2;
                        if (Math.abs(bulletY - laserY) < laserHitY) {
                            particles.push({ x: b.x, y: bulletY, vx: -4, vy: (Math.random() - 0.5) * 4, life: 15, color: '#ff0', size: 5 });
                            return false;
                        }
                        return true;
                    });
                }

                // Boss bullets
                if (boss && boss.bullets && boss.bullets.length > 0) {
                    boss.bullets = boss.bullets.filter(b => {
                        const bulletY = b.y + (b.height || 0) / 2;
                        if (Math.abs(bulletY - laserY) < laserHitY) {
                            particles.push({ x: b.x, y: bulletY, vx: -5, vy: (Math.random() - 0.5) * 5, life: 20, color: '#ff0', size: 6 });
                            return false;
                        }
                        return true;
                    });
                }

                // Destroy ALL mines
                for (let i = mines.length - 1; i >= 0; i--) {
                    const m = mines[i];
                    const mineY = m.y + (m.height || 30) / 2;
                    if (Math.abs(mineY - laserY) < 120) {
                        createExplosion(m.x, m.y, false);
                        playSound('explosion');
                        score += 50;
                        mines.splice(i, 1);
                    }
                }
            }

            // Update bullets
            player.bullets = player.bullets.filter(b => {
                // Homing effect
                if (activePowerups.homing > 0 && !b.isDroneBullet) {
                    let nearestEnemy = null;
                    let nearestDist = 200;
                    enemies.forEach(e => {
                        const dist = Math.hypot(e.x - b.x, e.y + e.height/2 - b.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = e;
                        }
                    });
                    if (nearestEnemy) {
                        const targetY = nearestEnemy.y + nearestEnemy.height/2;
                        b.vy = (b.vy || 0) + (targetY - b.y) * 0.02;
                        b.vy = Math.max(-4, Math.min(4, b.vy)); // Limit homing strength
                    }
                }

                b.x += b.speed * speedMod;
                b.y += (b.vy || 0) * speedMod;

                // Check mine collision
                for (let i = mines.length - 1; i >= 0; i--) {
                    const m = mines[i];
                    if (Math.hypot(b.x - m.x, b.y - m.y) < m.radius + 5) {
                        createExplosion(m.x, m.y, true);
                        mines.splice(i, 1);
                        score += 50;
                        return false;
                    }
                }

                return b.x < canvas.width + 20 && b.y > -20 && b.y < canvas.height + 20;
            });

            // Update rockets (homing)
            player.rockets = player.rockets.filter(r => {
                // Trail
                r.trail.push({ x: r.x, y: r.y, life: 20 });
                r.trail = r.trail.filter(t => { t.life--; return t.life > 0; });

                // Homing
                if (r.target && (r.target.health > 0 || r.target === boss)) {
                    const tx = r.target.x + r.target.width/2;
                    const ty = r.target.y + r.target.height/2;
                    const angle = Math.atan2(ty - r.y, tx - r.x);
                    r.angle += (angle - r.angle) * 0.1;
                }

                r.x += Math.cos(r.angle) * r.speed * speedMod;
                r.y += Math.sin(r.angle) * r.speed * speedMod;

                // Hit enemies
                for (let e of enemies) {
                    if (checkCollision(r, e)) {
                        e.health -= 3;
                        createExplosion(r.x, r.y, false);
                        return false;
                    }
                }
                // Hit boss
                if (boss && checkCollision(r, boss)) {
                    boss.health -= 5;
                    createExplosion(r.x, r.y, false);
                    return false;
                }
                // Hit mini-boss
                if (miniBoss && !miniBoss.cloaked && checkCollision(r, miniBoss)) {
                    miniBoss.health -= 5;
                    createExplosion(r.x, r.y, false);
                    return false;
                }
                // Hit mines
                for (let i = mines.length - 1; i >= 0; i--) {
                    const m = mines[i];
                    if (Math.hypot(r.x - m.x, r.y - m.y) < m.radius + 10) {
                        createExplosion(m.x, m.y, true);
                        mines.splice(i, 1);
                        score += 50;
                        return false;
                    }
                }

                return r.x > -20 && r.x < canvas.width + 50 && r.y > -50 && r.y < canvas.height + 50;
            });

            // Boss warning
            if (bossWarning > 0) bossWarning--;

            // Check for boss level
            const cfg = difficulties[difficulty];
            if (!cfg.bossRush && level % 5 === 0 && !boss && enemies.length === 0 && bossWarning === 0) {
                spawnBoss();
            }

            // Spawn enemies
            if (!boss && Date.now() - lastEnemySpawn > enemySpawnRate) {
                spawnEnemy();
                lastEnemySpawn = Date.now();
            }

            // Spawn and update obstacles
            if (!boss && frame % 120 === 0 && Math.random() < 0.4) {
                spawnObstacle();
            }
            updateObstacles();

            // Update boss
            if (boss) {
                const b = boss;

                // Update boss phase system
                updateBossPhase();

                // Move to position
                if (b.x > canvas.width - b.width - 60) {
                    b.x -= b.speed * 2 * speedMod;
                } else {
                    b.phaseTimer++;
                    if (b.phaseTimer > 250) {
                        b.phase = (b.phase + 1) % 3;
                        b.phaseTimer = 0;
                    }

                    // Movement patterns based on boss type AND current phase
                    const phaseSpeedMult = b.currentPhase === 3 ? 1.5 : b.currentPhase === 2 ? 1.2 : 1;
                    const moveSpeed = b.speed * 2 * phaseSpeedMult * speedMod;

                    if (b.type === 0) { // Mega Bomber - sine wave, faster in later phases
                        b.y += Math.sin(frame * (0.02 * phaseSpeedMult)) * moveSpeed;
                    } else if (b.type === 1) { // Cyber Fortress - tracking, more aggressive
                        const trackSpeed = b.currentPhase === 3 ? 0.04 : b.currentPhase === 2 ? 0.03 : 0.02;
                        b.y += (player.y - b.y - b.height/2 + player.height/2) * trackSpeed * speedMod;
                    } else { // Death Machine - aggressive patterns
                        if (b.currentPhase === 3) {
                            // Erratic movement in phase 3
                            b.y += Math.sin(frame * 0.05) * moveSpeed * 2;
                            b.y += Math.cos(frame * 0.03) * moveSpeed;
                        } else if (b.currentPhase === 2) {
                            b.y += (player.y - b.y - b.height/2) * 0.035 * speedMod;
                        } else {
                            b.y += Math.sin(frame * 0.03) * moveSpeed;
                        }
                    }

                    b.y = Math.max(40, Math.min(canvas.height - b.height - 90, b.y));

                    // Turret shooting (only alive turrets)
                    const baseInterval = b.currentPhase === 3 ? 20 : b.currentPhase === 2 ? 35 : 50;
                    b.turrets.forEach(t => {
                        if (!t.alive) return;
                        const interval = t.fireRate ? baseInterval * t.fireRate : baseInterval;
                        if (frame - t.lastShot > interval) {
                            const angle = Math.atan2(player.y + player.height/2 - (b.y + t.y), player.x - (b.x + t.x));
                            const bulletSpeed = b.currentPhase === 3 ? 8 : b.currentPhase === 2 ? 6 : 5;
                            b.bullets.push({
                                x: b.x + t.x, y: b.y + t.y,
                                width: 12, height: 12, speed: bulletSpeed, angle
                            });

                            // Extra bullets in phase 2+
                            if (b.currentPhase >= 2) {
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 10, height: 10, speed: bulletSpeed - 1, angle: angle + 0.15 });
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 10, height: 10, speed: bulletSpeed - 1, angle: angle - 0.15 });
                            }
                            // Even more in phase 3
                            if (b.currentPhase === 3 && b.type === 2) {
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 8, height: 8, speed: bulletSpeed, angle: angle + 0.3 });
                                b.bullets.push({ x: b.x + t.x, y: b.y + t.y, width: 8, height: 8, speed: bulletSpeed, angle: angle - 0.3 });
                            }
                            t.lastShot = frame;
                        }
                    });

                    // Special attacks (phase 3 only)
                    b.specialAttackTimer++;
                    if (b.currentPhase === 3 && b.specialAttackTimer > 180) {
                        bossSpecialAttack();
                        b.specialAttackTimer = 0;
                    }

                    // Laser sweep update (Cyber Fortress)
                    if (b.laserSweep && b.laserSweep.active) {
                        b.laserSweep.y += b.laserSweep.direction * 3;
                        b.laserSweep.timer--;

                        // Damage player if in laser path
                        if (player.invincible === 0 && activePowerups.shield === 0 &&
                            Math.abs(player.y + player.height/2 - b.laserSweep.y) < 15 &&
                            player.x < b.x + 30) {
                            lives--;
                            player.invincible = 90;
                            gameStats.bossHitsTaken++;
                            createExplosion(player.x + player.width/2, player.y + player.height/2);
                            updateUI();
                            if (lives <= 0) gameOver();
                        }

                        // Reverse or end
                        if (b.laserSweep.y < b.y + 30 || b.laserSweep.y > b.y + b.height - 30) {
                            b.laserSweep.direction *= -1;
                        }
                        if (b.laserSweep.timer <= 0) {
                            b.laserSweep.active = false;
                        }
                    }
                }

                // Update boss bullets
                b.bullets = b.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * enemySpeedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * enemySpeedMod;

                    // Bomb bullets explode on ground
                    if (bullet.isBomb && bullet.y > canvas.height - 100) {
                        createExplosion(bullet.x, bullet.y, true);
                        // Area damage to player (not if ghost)
                        if (Math.abs(player.x - bullet.x) < 80 && player.invincible === 0 && activePowerups.shield === 0 && activePowerups.ghost === 0) {
                            lives--;
                            player.invincible = 90;
                            gameStats.bossHitsTaken++;
                            updateUI();
                            if (lives <= 0) gameOver();
                        }
                        return false;
                    }

                    // Ghost powerup - bullets pass through (track dodges)
                    if (activePowerups.ghost > 0) {
                        if (checkCollision(bullet, player)) {
                            gameStats.ghostDodges++;
                            if (gameStats.ghostDodges >= 50) unlockAchievement('pacifist');
                        }
                        return bullet.x > -30 && bullet.x < canvas.width + 30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                    }

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--;
                        player.invincible = 90;
                        gameStats.bossHitsTaken++;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }

                    return bullet.x > -30 && bullet.x < canvas.width + 30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                });

                // Player bullets hitting boss components
                player.bullets = player.bullets.filter(bullet => {
                    if (hitBossComponent(bullet)) {
                        playSound('hit');
                        createExplosion(bullet.x, bullet.y, false);
                        updateBossPhase();

                        if (b.health <= 0) {
                            // EPIC BOSS DEFEAT
                            stopBossMusic();
                            const bossScore = 10000 * level;
                            score += bossScore;

                            // Achievements
                            unlockAchievement('boss_killer');
                            if (gameStats.bossHitsTaken === 0) {
                                unlockAchievement('boss_no_hit');
                            }
                            if (difficulty === 'legendary' && level >= 10) {
                                unlockAchievement('legendary_win');
                            }

                            // Multiple explosions (reduced for performance)
                            for (let i = 0; i < 6; i++) {
                                setTimeout(() => {
                                    if (!boss) return;
                                    createExplosion(
                                        b.x + Math.random() * b.width,
                                        b.y + Math.random() * b.height,
                                        true
                                    );
                                }, i * 150);
                            }

                            screenShake = 60;
                            shockwaves.push({ x: b.x + b.width/2, y: b.y + b.height/2, radius: 0, maxRadius: 500, speed: 12, color: '#ff0' });
                            spawnDebris(b.x + b.width/2, b.y + b.height/2, 15);
                            playSound('megaExplosion');
                            triggerSlowMotion();
                            playVoice('GODLIKE');

                            floatingTexts.push({
                                x: b.x + b.width/2, y: b.y + b.height/2,
                                text: '‚òÖ BOSS DESTROYED! +' + bossScore + ' ‚òÖ',
                                color: '#ff0', life: 180, size: 28
                            });

                            setTimeout(() => {
                                boss = null;
                                document.getElementById('bossHealth').style.display = 'none';
                                document.getElementById('bossName').style.display = 'none';

                                level++;
                                enemySpawnRate = Math.max(500, enemySpawnRate - 120);
                                playSound('levelUp');
                                updateUI();

                                // Check biome change
                                const newBiome = getBiomeForLevel(level);
                                if (newBiome !== currentBiome) {
                                    switchBiome(newBiome);
                                }

                                // Show upgrade screen every 5 levels
                                if (level % 5 === 1 && level > 1) {
                                    showUpgradeScreen();
                                }

                                // Boss rush mode: spawn next boss
                                if (difficulties[difficulty].bossRush) {
                                    setTimeout(() => spawnBoss(), 2000);
                                }
                            }, 1500);
                        }
                        return false;
                    }
                    return true;
                });
            }

            // Update mines
            mines = mines.filter(mine => {
                mine.timer--;
                mine.pulse = (mine.pulse + 0.1) % (Math.PI * 2);
                mine.armed = mine.timer < 270; // Armed after 0.5 sec

                // Check player collision
                if (mine.armed && player.invincible === 0 && activePowerups.shield === 0) {
                    const dist = Math.hypot(player.x + player.width/2 - mine.x, player.y + player.height/2 - mine.y);
                    if (dist < mine.radius + 20) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(mine.x, mine.y, true);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                }

                // Expire
                if (mine.timer <= 0) {
                    createExplosion(mine.x, mine.y, false);
                    return false;
                }

                return true;
            });

            // Update mini-boss
            if (miniBoss) {
                const mb = miniBoss;

                // Move into position
                if (mb.x > canvas.width - mb.width - 80) {
                    mb.x -= mb.speed * 2 * speedMod;
                } else {
                    // Movement
                    mb.y += Math.sin(frame * 0.03) * 2 * speedMod;
                    mb.y = Math.max(80, Math.min(canvas.height - mb.height - 100, mb.y));

                    // Stealth Hunter cloaking
                    if (mb.cloakDuration > 0) {
                        mb.cloakTimer++;
                        if (mb.cloakTimer > 120 && !mb.cloaked) {
                            mb.cloaked = true;
                            mb.cloakTimer = 0;
                        } else if (mb.cloaked && mb.cloakTimer > mb.cloakDuration) {
                            mb.cloaked = false;
                            mb.cloakTimer = 0;
                        }
                    }

                    // Shooting
                    if (!mb.cloaked) {
                        if (mb.bombRate > 0) {
                            // Heavy Bomber - drops bombs continuously
                            if (frame % mb.bombRate === 0) {
                                mb.bullets.push({
                                    x: mb.x + mb.width/2 + (Math.random() - 0.5) * 40,
                                    y: mb.y + mb.height,
                                    width: 16, height: 16, speed: 4, angle: Math.PI/2, isBomb: true
                                });
                                playSound('shoot');
                            }
                        } else if (frame - mb.lastShot > mb.shootCooldown) {
                            // Other mini-bosses - aimed shots
                            const angle = Math.atan2(player.y + player.height/2 - (mb.y + mb.height/2), player.x - mb.x);
                            mb.bullets.push({
                                x: mb.x, y: mb.y + mb.height/2,
                                width: 10, height: 10, speed: 7, angle
                            });
                            mb.lastShot = frame;
                        }
                    }
                }

                // Update mini-boss bullets
                mb.bullets = mb.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * enemySpeedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * enemySpeedMod;

                    if (bullet.isBomb && bullet.y > canvas.height - 100) {
                        createExplosion(bullet.x, bullet.y, true);
                        if (Math.abs(player.x - bullet.x) < 60 && player.invincible === 0 && activePowerups.shield === 0 && activePowerups.ghost === 0) {
                            lives--; player.invincible = 90; updateUI();
                            if (lives <= 0) gameOver();
                        }
                        return false;
                    }

                    // Ghost powerup - bullets pass through
                    if (activePowerups.ghost > 0) {
                        return bullet.x > -30 && bullet.y < canvas.height + 30;
                    }

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--; player.invincible = 90;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                    return bullet.x > -30 && bullet.y < canvas.height + 30;
                });

                // Player bullets hitting mini-boss
                player.bullets = player.bullets.filter(bullet => {
                    if (!mb.cloaked && checkCollision(bullet, mb)) {
                        mb.health -= bullet.damage || 1;
                        playSound('hit');
                        createExplosion(bullet.x, bullet.y, false);

                        if (mb.health <= 0) {
                            const mbScore = 2000 * level;
                            score += mbScore;
                            screenShake = 25;
                            createExplosion(mb.x + mb.width/2, mb.y + mb.height/2, true);
                            spawnDebris(mb.x + mb.width/2, mb.y + mb.height/2, 10);
                            playSound('megaExplosion');
                            floatingTexts.push({
                                x: mb.x + mb.width/2, y: mb.y,
                                text: '‚òÖ MINI-BOSS DOWN! +' + mbScore + ' ‚òÖ',
                                color: '#f80', life: 100, size: 16
                            });
                            spawnPowerup(mb.x + mb.width/2, mb.y + mb.height/2);
                            miniBoss = null;
                            updateUI();
                        }
                        return false;
                    }
                    return true;
                });
            }

            // Update enemies
            enemies = enemies.filter(enemy => {
                // Stun timer
                if (enemy.stunned > 0) {
                    enemy.stunned--;
                    enemy.x -= 0.5 * enemySpeedMod; // Drift slowly while stunned
                    return enemy.x > -120;
                }

                // Base movement
                if (enemy.type === 'turret') {
                    enemy.x -= 1 * enemySpeedMod;
                } else if (enemy.type === 'kamikaze') {
                    // Chase player aggressively
                    const dx = player.x - enemy.x;
                    const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                    const dist = Math.hypot(dx, dy);
                    enemy.x += (dx / dist) * enemy.speed * enemySpeedMod * 0.7;
                    enemy.y += (dy / dist) * enemy.speed * enemySpeedMod;
                    // Trail effect
                    if (frame % 3 === 0) {
                        particles.push({
                            x: enemy.x + enemy.width, y: enemy.y + enemy.height/2,
                            vx: 2 + Math.random(), vy: (Math.random() - 0.5) * 2,
                            life: 20, color: '#f80', size: 6
                        });
                    }
                } else if (enemy.type === 'blinker') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.teleportTimer--;
                    // Teleport warning
                    if (enemy.teleportTimer < 30) {
                        enemy.teleportWarning = 30 - enemy.teleportTimer;
                    }
                    // Teleport!
                    if (enemy.teleportTimer <= 0) {
                        // Glitch effect at old position
                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
                                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                                life: 20, color: '#0ff', size: 4
                            });
                        }
                        // New position
                        enemy.x = canvas.width - 100 - Math.random() * 200;
                        enemy.y = 100 + Math.random() * (canvas.height - 300);
                        enemy.teleportTimer = 150 + Math.random() * 60;
                        enemy.teleportWarning = 0;
                        // Shoot after teleport
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 8, height: 8, speed: 8, angle });
                    }
                } else if (enemy.type === 'scout') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    // Dodge bullets!
                    if (enemy.dodgeCooldown <= 0) {
                        for (let b of player.bullets) {
                            const dist = Math.hypot(b.x - enemy.x, b.y - (enemy.y + enemy.height/2));
                            if (dist < 80 && b.x < enemy.x) {
                                // Dodge up or down
                                enemy.y += (enemy.y > canvas.height/2 ? -60 : 60);
                                enemy.dodgeCooldown = 30;
                                // After image
                                enemy.afterImages.push({ x: enemy.x, y: enemy.y + (enemy.y > canvas.height/2 ? 60 : -60), alpha: 0.7 });
                                break;
                            }
                        }
                    } else {
                        enemy.dodgeCooldown--;
                    }
                    // Update after images
                    enemy.afterImages = enemy.afterImages.filter(ai => { ai.alpha -= 0.1; return ai.alpha > 0; });
                } else if (enemy.type === 'miner') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.mineTimer--;
                    if (enemy.mineTimer <= 0 && enemy.x < canvas.width - 50) {
                        spawnMine(enemy.x + enemy.width, enemy.y + enemy.height/2);
                        enemy.mineTimer = 90;
                    }
                } else if (enemy.type === 'shielder') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.y += Math.sin(frame * 0.02) * 1.5 * enemySpeedMod;
                // MEGA UPGRADE: New enemy behaviors
                } else if (enemy.type === 'teleporter') {
                    enemy.x -= enemy.speed * enemySpeedMod * 0.5;
                    enemy.teleportTimer = (enemy.teleportTimer || 120) - 1;
                    if (enemy.teleportTimer <= 0) {
                        // Teleport effect
                        for (let i = 0; i < 12; i++) {
                            particles.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
                                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                life: 25, color: '#f0f', size: 5
                            });
                        }
                        enemy.x = 300 + Math.random() * (canvas.width - 400);
                        enemy.y = 80 + Math.random() * (canvas.height - 200);
                        enemy.teleportTimer = 100 + Math.random() * 60;
                        playSound('hit');
                    }
                } else if (enemy.type === 'splitter' || enemy.type === 'splitter_mini') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.y += Math.sin(frame * 0.03 + enemy.x * 0.01) * 2 * enemySpeedMod;
                } else if (enemy.type === 'healer') {
                    enemy.x -= enemy.speed * enemySpeedMod * 0.5;
                    enemy.y += Math.cos(frame * 0.015) * 1.5 * enemySpeedMod;
                    enemy.healTimer = (enemy.healTimer || 90) - 1;
                    if (enemy.healTimer <= 0) {
                        // Heal nearby enemies
                        enemies.forEach(e => {
                            if (e !== enemy && e.health < e.maxHealth) {
                                const dist = Math.hypot(e.x - enemy.x, e.y - enemy.y);
                                if (dist < 200) {
                                    e.health = Math.min(e.health + 1, e.maxHealth);
                                    // Heal beam effect
                                    for (let i = 0; i < 5; i++) {
                                        const t = i / 5;
                                        particles.push({
                                            x: enemy.x + (e.x - enemy.x) * t, y: enemy.y + (e.y - enemy.y) * t,
                                            vx: 0, vy: -1, life: 15, color: '#0f0', size: 3
                                        });
                                    }
                                }
                            }
                        });
                        enemy.healTimer = 90;
                    }
                } else if (enemy.type === 'reflector') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.y += Math.sin(frame * 0.02) * 2 * enemySpeedMod;
                    // Shield visual pulse
                    enemy.shieldPulse = (enemy.shieldPulse || 0) + 0.1;
                } else if (enemy.type === 'suicide_bomber') {
                    // Chase player and explode on contact
                    const dx = player.x - enemy.x;
                    const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                    const dist = Math.hypot(dx, dy);
                    enemy.x += (dx / dist) * enemy.speed * enemySpeedMod;
                    enemy.y += (dy / dist) * enemy.speed * enemySpeedMod;
                    // Warning effect - blink faster as closer
                    enemy.blinkRate = Math.max(5, 30 - Math.floor(dist / 20));
                    // Trail
                    if (frame % 4 === 0) {
                        particles.push({
                            x: enemy.x + enemy.width, y: enemy.y + enemy.height/2,
                            vx: 2, vy: (Math.random() - 0.5) * 2,
                            life: 15, color: '#f80', size: 5
                        });
                    }
                    // Explode on contact!
                    if (dist < 40 && player.invincible === 0 && activePowerups.shield === 0) {
                        lives -= 2;
                        player.invincible = 90;
                        createExplosion(enemy.x, enemy.y, true);
                        screenShake = 25;
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                // === ADVANCED ENEMIES ===
                } else if (enemy.type === 'phantom') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.phantomPhase = (enemy.phantomPhase || 0) + 1;
                    // Toggle visibility every 120 frames
                    if (enemy.phantomPhase >= 120) {
                        enemy.phantomPhase = 0;
                        enemy.phantomVisible = !enemy.phantomVisible;
                        // Phase effect particles
                        for (let i = 0; i < 10; i++) {
                            particles.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2,
                                vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                                life: 25, color: '#a0f', size: 4
                            });
                        }
                    }
                    // Floaty movement
                    enemy.y += Math.sin(frame * 0.04) * 1.5 * enemySpeedMod;
                } else if (enemy.type === 'laserDrone') {
                    // Slow horizontal, then stop to charge
                    if (enemy.laserCharging === 0 && enemy.laserFiring === 0) {
                        enemy.x -= enemy.speed * enemySpeedMod;
                        // Start charging when in position
                        if (enemy.x < canvas.width - 150 && Math.random() < 0.01) {
                            enemy.laserCharging = 90;
                            enemy.laserTargetY = player.y + player.height/2;
                        }
                    } else if (enemy.laserCharging > 0) {
                        enemy.laserCharging--;
                        // Fire when charged
                        if (enemy.laserCharging === 0) {
                            enemy.laserFiring = 30;
                        }
                    } else if (enemy.laserFiring > 0) {
                        enemy.laserFiring--;
                    }
                } else if (enemy.type === 'gravityWell') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    // Attract player bullets
                    player.bullets.forEach(b => {
                        const dx = (enemy.x + enemy.width/2) - b.x;
                        const dy = (enemy.y + enemy.height/2) - b.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 180 && dist > 20) {
                            b.vy = (b.vy || 0) + (dy / dist) * 0.5;
                            b.speed *= 0.99;
                        }
                    });
                    // Attract powerups
                    powerups.forEach(p => {
                        const dx = (enemy.x + enemy.width/2) - p.x;
                        const dy = (enemy.y + enemy.height/2) - p.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 200 && dist > 30) {
                            p.x += (dx / dist) * 2;
                            p.y += (dy / dist) * 2;
                        }
                    });
                } else if (enemy.type === 'mirror') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.mirrorTimer = (enemy.mirrorTimer || 180) - 1;
                    if (enemy.mirrorTimer <= 0) {
                        enemy.mirrorOpen = !enemy.mirrorOpen;
                        enemy.mirrorTimer = enemy.mirrorOpen ? 45 : 180; // Open for shorter time
                    }
                    enemy.y += Math.sin(frame * 0.02) * 1.5 * enemySpeedMod;
                } else if (enemy.type === 'spawner') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.spawnTimer = (enemy.spawnTimer || 180) - 1;
                    // Count active bees from this spawner
                    const myBees = enemies.filter(e => e.parentId === enemy.id).length;
                    if (enemy.spawnTimer <= 0 && myBees < 4) {
                        // Spawn a bee
                        const bee = createEnemy('bee');
                        bee.x = enemy.x - 10;
                        bee.y = enemy.y + enemy.height/2;
                        bee.parentId = enemy.id;
                        enemies.push(bee);
                        enemy.spawnTimer = 150;
                        // Spawn effect
                        for (let i = 0; i < 6; i++) {
                            particles.push({
                                x: bee.x, y: bee.y,
                                vx: -2 - Math.random() * 3, vy: (Math.random() - 0.5) * 4,
                                life: 20, color: '#ff0', size: 3
                            });
                        }
                    }
                } else if (enemy.type === 'bee') {
                    // Zigzag aggressive movement
                    const dx = player.x - enemy.x;
                    const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                    const dist = Math.hypot(dx, dy);
                    enemy.x += (dx / dist) * enemy.speed * enemySpeedMod * 0.6;
                    enemy.y += (dy / dist) * enemy.speed * enemySpeedMod * 0.8;
                    enemy.y += Math.sin(frame * 0.3 + enemy.x * 0.05) * 3 * enemySpeedMod;
                } else if (enemy.type === 'teslaCoil') {
                    enemy.x -= enemy.speed * enemySpeedMod;
                    enemy.teslaTimer = (enemy.teslaTimer || 90) - 1;
                    if (enemy.teslaTimer <= 0) {
                        // Find nearby enemy to charge, or shoot player
                        let target = null;
                        let minDist = 250;
                        enemies.forEach(e => {
                            if (e !== enemy && e.type !== 'teslaCoil' && e.type !== 'bee') {
                                const dist = Math.hypot(e.x - enemy.x, e.y - enemy.y);
                                if (dist < minDist) {
                                    minDist = dist;
                                    target = e;
                                }
                            }
                        });
                        if (target) {
                            target.charged = true;
                            // Lightning effect
                            for (let i = 0; i < 8; i++) {
                                const t = i / 8;
                                particles.push({
                                    x: enemy.x + (target.x - enemy.x) * t + (Math.random()-0.5)*15,
                                    y: enemy.y + (target.y - enemy.y) * t + (Math.random()-0.5)*15,
                                    vx: 0, vy: 0, life: 15, color: '#0ff', size: 4
                                });
                            }
                        } else {
                            // Shoot lightning at player
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemy.bullets.push({
                                x: enemy.x, y: enemy.y + enemy.height/4,
                                width: 15, height: 6, speed: 12, angle,
                                isLightning: true
                            });
                        }
                        enemy.teslaTimer = 75;
                    }
                } else {
                    enemy.x -= enemy.speed * enemySpeedMod;
                }

                // Standard movement patterns for basic enemies
                if (enemy.type === 'fighter') {
                    enemy.y = enemy.startY + Math.sin(frame * enemy.frequency) * enemy.amplitude;
                } else if (enemy.type === 'helicopter' || enemy.type === 'drone') {
                    enemy.y += (player.y - enemy.y) * 0.015 * enemySpeedMod;
                } else if (enemy.type === 'jet') {
                    enemy.y += Math.cos(frame * 0.05) * 3 * enemySpeedMod;
                }

                // Keep in bounds
                enemy.y = Math.max(70, Math.min(canvas.height - enemy.height - 90, enemy.y));

                // Enemy shooting (not for kamikaze, miner, scout)
                if (!['kamikaze', 'miner', 'scout'].includes(enemy.type)) {
                    if (Date.now() - enemy.lastShot > enemy.shootCooldown && enemy.x < canvas.width - 80) {
                        if (enemy.type === 'turret') {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemy.bullets.push({ x: enemy.x + enemy.width/2, y: enemy.y, width: 8, height: 8, speed: 7, angle });
                        } else if (enemy.type === 'bomber') {
                            for (let i = -1; i <= 1; i++) {
                                enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 10, height: 6, speed: 6, angle: Math.PI + i * 0.3 });
                            }
                        } else if (enemy.type === 'shielder') {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 12, height: 8, speed: 5, angle });
                        } else {
                            enemy.bullets.push({ x: enemy.x, y: enemy.y + enemy.height/2, width: 10, height: 4, speed: 8, angle: Math.PI });
                        }
                        enemy.lastShot = Date.now();
                    }
                }

                // Update enemy bullets
                enemy.bullets = enemy.bullets.filter(bullet => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed * enemySpeedMod;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed * enemySpeedMod;

                    // Ghost powerup - bullets pass through
                    if (activePowerups.ghost > 0) {
                        return bullet.x > -30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                    }

                    if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(bullet, player)) {
                        lives--;
                        player.invincible = 90;
                        createExplosion(player.x + player.width/2, player.y + player.height/2);
                        updateUI();
                        if (lives <= 0) gameOver();
                        return false;
                    }
                    return bullet.x > -30 && bullet.y > -30 && bullet.y < canvas.height + 30;
                });

                // Collision with player (kamikaze explodes!)
                if (player.invincible === 0 && activePowerups.shield === 0 && checkCollision(enemy, player)) {
                    lives--;
                    player.invincible = 90;
                    const isKamikaze = enemy.type === 'kamikaze';
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, isKamikaze);
                    if (isKamikaze) {
                        screenShake = 20;
                        // Chain reaction - damage nearby enemies
                        enemies.forEach(e => {
                            if (e !== enemy && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 80) {
                                e.health -= 2;
                            }
                        });
                    }
                    updateUI();
                    if (lives <= 0) gameOver();
                    return false;
                }

                // Hit by player bullet
                for (let i = player.bullets.length - 1; i >= 0; i--) {
                    const bullet = player.bullets[i];

                    // Shielder: check if bullet hits from front (blocked by shield)
                    if (enemy.type === 'shielder' && enemy.shieldHP > 0) {
                        if (bullet.x > enemy.x - 10 && bullet.x < enemy.x + 20 && checkCollision(bullet, enemy)) {
                            // Hit shield
                            enemy.shieldHP -= bullet.damage || 1;
                            player.bullets.splice(i, 1);
                            playSound('hit');
                            // Shield spark effect
                            for (let j = 0; j < 5; j++) {
                                particles.push({
                                    x: enemy.x, y: enemy.y + enemy.height/2,
                                    vx: -3 - Math.random() * 3, vy: (Math.random() - 0.5) * 6,
                                    life: 15, color: '#0af', size: 4
                                });
                            }
                            if (enemy.shieldHP <= 0) {
                                floatingTexts.push({ x: enemy.x, y: enemy.y - 10, text: 'SHIELD DOWN!', color: '#0ff', life: 40, size: 10 });
                            }
                            continue;
                        }
                    }

                    // ADVANCED ENEMY: Phantom is immune when invisible
                    if (enemy.type === 'phantom' && !enemy.phantomVisible) {
                        continue; // Bullet passes through
                    }

                    // ADVANCED ENEMY: Mirror reflects ALL bullets when closed
                    if (enemy.type === 'mirror' && !enemy.mirrorOpen && checkCollision(bullet, enemy)) {
                        bullet.speed = -bullet.speed * 1.2; // Faster reflect
                        bullet.isReflected = true;
                        bullet.color = '#fff';
                        // Sparkle effect
                        for (let r = 0; r < 8; r++) {
                            particles.push({
                                x: bullet.x, y: bullet.y,
                                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                life: 20, color: '#fff', size: 3
                            });
                        }
                        playSound('hit');
                        continue;
                    }

                    if (checkCollision(bullet, enemy)) {
                        // MEGA UPGRADE: Reflector has 50% chance to reflect bullets
                        if (enemy.type === 'reflector' && !bullet.isReflected && Math.random() < 0.5) {
                            bullet.speed = -bullet.speed * 0.8; // Reverse direction
                            bullet.isReflected = true;
                            bullet.color = '#f00'; // Change color to show it's reflected
                            // Reflection effect
                            for (let r = 0; r < 5; r++) {
                                particles.push({
                                    x: bullet.x, y: bullet.y,
                                    vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                    life: 15, color: '#ccc', size: 3
                                });
                            }
                            playSound('hit');
                            continue; // Don't damage the reflector
                        }

                        // Piercing - bullet goes through (but reduce damage slightly)
                        if (activePowerups.piercing > 0) {
                            enemy.health -= (bullet.damage || 1) * 0.8;
                            bullet.pierceCount = (bullet.pierceCount || 0) + 1;
                            if (bullet.pierceCount >= 5) player.bullets.splice(i, 1); // Max 5 pierces
                        } else {
                            player.bullets.splice(i, 1);
                            enemy.health -= bullet.damage || 1;
                        }

                        if (enemy.health <= 0) {
                            const pts = enemy.points * comboMultiplier * (perks.doubleScore ? 2 : 1);
                            score += pts;
                            addCombo();

                            // PROGRESSION: Add XP
                            const xpGain = Math.floor((enemy.points || 100) / 10);
                            addXP(xpGain);
                            updateXPBarGame();

                            // MEGA UPGRADE: Coins and Ultimate charge
                            const progEff = getAllUpgradeEffects();
                            const coinMult = 1 + (progEff.coinBonus || 0);
                            const coinDrop = Math.floor((1 + Math.random() * 5 * (1 + luckBonus + (progEff.luckBonus || 0))) * coinMult);
                            coins += coinDrop;
                            totalKills++;
                            const ultChargeRate = getAllSkillEffects().ultChargeRate || 1;
                            ultCharge = Math.min(100, ultCharge + (1 + (comboMultiplier - 1) * 0.5) * ultChargeRate);

                            // Vampire helicopter: chance to heal on kill
                            if (HELICOPTERS[currentHelicopter].special === 'lifesteal' && Math.random() < 0.05) {
                                lives = Math.min(lives + 1, maxLives);
                                floatingTexts.push({x: player.x, y: player.y - 20, text: '+1 LIFE', color: '#0f0', life: 60, size: 14});
                            }

                            updateUI();
                            unlockAchievement('first_blood');
                            // Track drone kills
                            if (bullet.isDroneBullet) {
                                gameStats.droneKills++;
                                if (gameStats.droneKills >= 10) unlockAchievement('drone_kills');
                            }
                            const isKamikaze = enemy.type === 'kamikaze';
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, true);
                            spawnDebris(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 3);

                            // Kamikaze chain reaction
                            if (isKamikaze) {
                                screenShake = 15;
                                enemies.forEach(e => {
                                    if (e !== enemy && Math.hypot(e.x - enemy.x, e.y - enemy.y) < 80) {
                                        e.health -= 2;
                                    }
                                });
                            }

                            // MEGA UPGRADE: Splitter spawns 2 mini splitters
                            if (enemy.type === 'splitter' && !enemy.isMini) {
                                for (let s = 0; s < 2; s++) {
                                    const mini = createEnemy('splitter_mini', enemy.x, enemy.y + (s === 0 ? -25 : 25));
                                    mini.isMini = true;
                                    enemies.push(mini);
                                }
                                floatingTexts.push({
                                    x: enemy.x, y: enemy.y - 10,
                                    text: 'SPLIT!', color: '#0f8', life: 30, size: 12
                                });
                            }

                            // ADVANCED: Spawner death kills all its bees
                            if (enemy.type === 'spawner') {
                                enemies.forEach(e => {
                                    if (e.parentId === enemy.id) {
                                        e.health = 0;
                                        createExplosion(e.x, e.y, false);
                                    }
                                });
                                floatingTexts.push({
                                    x: enemy.x, y: enemy.y - 10,
                                    text: 'HIVE DESTROYED!', color: '#fa0', life: 40, size: 12
                                });
                            }

                            floatingTexts.push({
                                x: enemy.x + enemy.width/2, y: enemy.y,
                                text: '+' + pts, color: comboMultiplier > 1 ? '#f0f' : '#ff0',
                                life: 45, size: 12 + Math.min(combo, 10)
                            });

                            if (Math.random() < 0.18 + perks.magnet * 0.05) {
                                spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }

                            // Level up moved outside loop to prevent multiple level ups

                            return false;
                        } else {
                            playSound('hit');
                            createExplosion(bullet.x, enemy.y + enemy.height/2, false);
                        }
                    }
                }

                return enemy.x > -120;
            });

            // Level up check (outside enemy loop to prevent multiple triggers)
            const levelThreshold = level * 4000;
            if (score >= levelThreshold && level % 5 !== 0) {
                level++;
                // Check for biome change
                const newBiome = getBiomeForLevel(level);
                if (newBiome !== currentBiome) {
                    switchBiome(newBiome);
                }

                // MEGA UPGRADE: Show shop every 5 levels
                if (level % 5 === 0) {
                    floatingTexts.push({
                        x: canvas.width/2, y: canvas.height/3,
                        text: 'üè™ SHOP TIME! üè™', color: '#fd0', life: 90, size: 24
                    });
                    setTimeout(() => showShop(), 1000);
                } else {
                    floatingTexts.push({
                        x: canvas.width/2, y: canvas.height/3,
                        text: 'LEVEL ' + level + '!', color: '#0ff', life: 90, size: 28
                    });
                }

                playSound('levelup');
                unlockAchievement('survivor');
                updateUI();
            }

            // Update powerups
            powerups = powerups.filter(p => {
                p.x -= 1.5 * speedMod;
                p.pulse = (p.pulse + 0.1) % (Math.PI * 2);

                // Magnet effect
                if (perks.magnet > 0) {
                    const dist = Math.hypot(player.x - p.x, player.y - p.y);
                    if (dist < 150 * perks.magnet) {
                        p.x += (player.x - p.x) * 0.05;
                        p.y += (player.y - p.y) * 0.05;
                    }
                }

                if (checkCollision(p, player)) {
                    collectPowerup(p);
                    return false;
                }
                return p.x > -40;
            });

            // Update shockwaves
            shockwaves = shockwaves.filter(s => {
                s.radius += s.speed * speedMod;
                return s.radius < s.maxRadius;
            });

            // Update debris
            debris = debris.filter(d => {
                d.x += d.vx * speedMod;
                d.y += d.vy * speedMod;
                d.vy += 0.3 * speedMod;
                d.rotation += d.rotSpeed * speedMod;
                d.life--;
                return d.life > 0 && d.y < canvas.height + 50;
            });

            // Update explosions
            explosions = explosions.filter(e => {
                e.frame += 0.5 * speedMod;
                return e.frame < e.maxFrames;
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx * speedMod;
                p.y += p.vy * speedMod;
                p.vy += 0.15 * speedMod;
                p.life -= speedMod;
                return p.life > 0;
            });

            // Update floating texts
            floatingTexts = floatingTexts.filter(t => {
                t.y -= 1.2 * speedMod;
                t.life -= speedMod;
                return t.life > 0;
            });

            // Background
            const bgSpeed = speedMod;
            stars.forEach(s => {
                s.x -= s.speed * bgSpeed;
                if (s.x < 0) { s.x = canvas.width; s.y = Math.random() * canvas.height * 0.6; }
            });
            clouds.forEach(c => {
                c.x -= c.speed * bgSpeed;
                if (c.x + c.width < 0) c.x = canvas.width + c.width;
            });
            mountains.forEach(m => {
                m.x -= 0.4 * bgSpeed;
                if (m.x + m.width < 0) m.x = canvas.width + 50;
            });
            trees.forEach(t => {
                t.x -= 2.5 * bgSpeed;
                if (t.x < -30) t.x = canvas.width + 30;
            });
            neonGrid.forEach(g => {
                g.offset = (g.offset + 2 * bgSpeed) % 50;
            });

            // Rain
            if (difficulty === 'hard' || difficulty === 'legendary' || boss) {
                weather.rain.forEach(r => {
                    r.x -= 2;
                    r.y += r.speed * speedMod;
                    if (r.y > canvas.height) {
                        r.y = -20;
                        r.x = Math.random() * canvas.width;
                    }
                    if (r.x < 0) r.x = canvas.width;
                });
            }

            // Multiplayer sync
            updateMultiplayer();
        }

        // ============ DRAW ============
        function draw() {
            ctx.save();

            // Screen shake
            if (screenShake > 0.5) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
            }

            // MEGA UPGRADE: Distortion effect
            if (distortion > 0.001) {
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(1 + distortion, 1 - distortion * 0.5);
                ctx.translate(-canvas.width/2, -canvas.height/2);
                distortion *= 0.92;
            }

            // Sky gradient - biome-based
            const biome = BIOMES[currentBiome];
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            if (slowMotion > 0) {
                skyGradient.addColorStop(0, '#100020');
                skyGradient.addColorStop(0.5, '#200040');
                skyGradient.addColorStop(1, '#100030');
            } else if (combo >= 20) {
                skyGradient.addColorStop(0, '#200000');
                skyGradient.addColorStop(0.5, '#300010');
                skyGradient.addColorStop(1, '#200005');
            } else {
                skyGradient.addColorStop(0, biome.skyTop);
                skyGradient.addColorStop(1, biome.skyBottom);
            }
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Biome transition flash
            if (biomeTransition > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${biomeTransition / 60 * 0.3})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                biomeTransition--;
            }

            // Lightning flash
            if (weather.lightning > 0) {
                ctx.fillStyle = `rgba(200, 200, 255, ${weather.lightning / 60 * 0.5})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Stars with colors
            stars.forEach(s => {
                const twinkle = Math.sin((frame + s.twinkle) * 0.1) > 0;
                ctx.fillStyle = twinkle ? s.color : '#444';
                ctx.shadowColor = s.color;
                ctx.shadowBlur = twinkle ? 5 : 0;
                ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size);
            });
            ctx.shadowBlur = 0;

            // Clouds
            ctx.fillStyle = 'rgba(80, 100, 130, 0.12)';
            clouds.forEach(c => {
                ctx.beginPath();
                ctx.ellipse(c.x, c.y, c.width/2, 30, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Biome-specific background elements
            if (currentBiome === 'city') {
                // City buildings
                biomeBuildings.forEach(b => {
                    const bx = ((b.x - frame * b.speed) % (canvas.width + 200)) - 100;
                    ctx.fillStyle = '#1a1a3a';
                    ctx.fillRect(bx, canvas.height - 80 - b.height, b.width, b.height);
                    // Windows
                    b.windows.forEach(w => {
                        ctx.fillStyle = w.lit ? (Math.random() > 0.98 ? '#fff' : '#ff8') : '#333';
                        ctx.fillRect(bx + w.x, canvas.height - 80 - b.height + w.y, 8, 12);
                    });
                });
            } else if (currentBiome === 'ocean') {
                // Ocean waves and islands
                ctx.fillStyle = '#0a5a7a';
                for (let i = 0; i < 3; i++) {
                    const islandX = ((i * 400 - frame * 0.3) % (canvas.width + 300)) - 100;
                    // Island
                    ctx.beginPath();
                    ctx.moveTo(islandX, canvas.height - 90);
                    ctx.quadraticCurveTo(islandX + 60, canvas.height - 140, islandX + 120, canvas.height - 90);
                    ctx.fill();
                    // Palm tree
                    ctx.fillStyle = '#4a3020';
                    ctx.fillRect(islandX + 55, canvas.height - 150, 8, 60);
                    ctx.fillStyle = '#2a8a2a';
                    for (let j = 0; j < 5; j++) {
                        ctx.beginPath();
                        ctx.ellipse(islandX + 59, canvas.height - 155, 25, 8, j * 1.2, 0, Math.PI);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#0a5a7a';
                }
            } else if (currentBiome === 'desert') {
                // Sand dunes
                ctx.fillStyle = '#d4a030';
                for (let i = 0; i < 5; i++) {
                    const duneX = ((i * 350 - frame * 0.25) % (canvas.width + 400)) - 150;
                    ctx.beginPath();
                    ctx.moveTo(duneX - 150, canvas.height - 60);
                    ctx.quadraticCurveTo(duneX, canvas.height - 100 - i * 15, duneX + 150, canvas.height - 60);
                    ctx.fill();
                }
                // Distant pyramids
                ctx.fillStyle = '#b08020';
                const pyrX = ((600 - frame * 0.15) % (canvas.width + 400));
                ctx.beginPath();
                ctx.moveTo(pyrX, canvas.height - 100);
                ctx.lineTo(pyrX + 80, canvas.height - 220);
                ctx.lineTo(pyrX + 160, canvas.height - 100);
                ctx.fill();
            } else if (currentBiome === 'space') {
                // Distant planet
                ctx.fillStyle = '#602040';
                ctx.shadowColor = '#f08';
                ctx.shadowBlur = 40;
                ctx.beginPath();
                ctx.arc(canvas.width - 150, 120, 70, 0, Math.PI * 2);
                ctx.fill();
                // Planet rings
                ctx.strokeStyle = 'rgba(255, 150, 200, 0.4)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(canvas.width - 150, 120, 110, 25, 0.3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                // Nebula glow
                const nebulaGrd = ctx.createRadialGradient(200, 200, 0, 200, 200, 200);
                nebulaGrd.addColorStop(0, 'rgba(100, 0, 150, 0.15)');
                nebulaGrd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = nebulaGrd;
                ctx.fillRect(0, 0, 400, 400);
            } else {
                // Default mountains
                mountains.forEach(m => {
                    ctx.fillStyle = '#080818';
                    ctx.beginPath();
                    ctx.moveTo(m.x, canvas.height - 80);
                    ctx.lineTo(m.x + m.width/2, canvas.height - 80 - m.height);
                    ctx.lineTo(m.x + m.width, canvas.height - 80);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(m.x + m.width/2 - 20, canvas.height - 60 - m.height);
                    ctx.lineTo(m.x + m.width/2, canvas.height - 80 - m.height);
                    ctx.lineTo(m.x + m.width/2 + 20, canvas.height - 60 - m.height);
                    ctx.stroke();
                });
            }

            // Ground - biome specific
            ctx.fillStyle = biome.groundColor;
            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);

            // Ocean waves animation
            if (currentBiome === 'ocean') {
                ctx.fillStyle = '#1a8aaa';
                for (let x = 0; x < canvas.width; x += 40) {
                    const waveY = canvas.height - 75 + Math.sin((x + frame * 3) * 0.04) * 8;
                    ctx.beginPath();
                    ctx.arc(x, waveY, 25, Math.PI, 0);
                    ctx.fill();
                }
            }

            // Neon grid on ground (except ocean/desert)
            if (currentBiome !== 'ocean' && currentBiome !== 'desert') {
                ctx.strokeStyle = `rgba(${currentBiome === 'space' ? '255, 0, 255' : '0, 255, 255'}, 0.2)`;
                ctx.lineWidth = 1;
                neonGrid.forEach((g, i) => {
                    if (i < 5) {
                        ctx.beginPath();
                        ctx.moveTo(0, g.y);
                        ctx.lineTo(canvas.width, g.y);
                        ctx.stroke();
                    }
                });
                for (let x = -neonGrid[0].offset; x < canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, canvas.height - 80);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
            }

            // Neon ground line - biome colored
            const groundGlow = biome.glowColor;
            ctx.strokeStyle = groundGlow;
            ctx.shadowColor = groundGlow;
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            ctx.lineTo(canvas.width, canvas.height - 80);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Trees with glow (only in city biome)
            ctx.fillStyle = '#0f2f0f';
            trees.forEach(t => {
                ctx.beginPath();
                ctx.moveTo(t.x, canvas.height - 80);
                ctx.lineTo(t.x + 12, canvas.height - 80 - t.height);
                ctx.lineTo(t.x + 24, canvas.height - 80);
                ctx.fill();
            });

            // Rain
            if (difficulty === 'hard' || difficulty === 'legendary' || boss) {
                ctx.strokeStyle = 'rgba(150, 180, 255, 0.4)';
                ctx.lineWidth = 1;
                weather.rain.forEach(r => {
                    ctx.beginPath();
                    ctx.moveTo(r.x, r.y);
                    ctx.lineTo(r.x - 3, r.y + r.length);
                    ctx.stroke();
                });
            }

            // Shockwaves
            shockwaves.forEach(s => {
                const alpha = 1 - s.radius / s.maxRadius;
                ctx.strokeStyle = s.color;
                ctx.globalAlpha = alpha * 0.8;
                ctx.lineWidth = 4;
                ctx.shadowColor = s.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Boss warning
            if (bossWarning > 0) {
                const flash = Math.sin(frame * 0.4) * 0.3 + 0.3;
                ctx.fillStyle = `rgba(255, 0, 50, ${flash})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#f00';
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 30;
                ctx.font = '28px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö† WARNING ‚ö†', canvas.width/2, canvas.height/2 - 20);
                ctx.font = '14px "Press Start 2P"';
                ctx.fillText('BOSS APPROACHING', canvas.width/2, canvas.height/2 + 20);
                ctx.shadowBlur = 0;
            }

            // Debris
            debris.forEach(d => {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.rotation * Math.PI / 180);
                ctx.fillStyle = d.color;
                ctx.globalAlpha = d.life / 120;
                ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Explosions
            explosions.forEach(exp => {
                const fi = Math.floor(exp.frame);
                ctx.drawImage(sprites.explosion, fi * 96, 0, 96, 96, exp.x - exp.size/2, exp.y - exp.size/2, exp.size, exp.size);
            });

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = Math.min(1, p.life / 30);
                ctx.shadowColor = p.color;
                ctx.shadowBlur = p.size;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Powerups with pulse effect
            powerups.forEach(p => {
                const pulse = Math.sin(p.pulse) * 3;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15 + pulse * 2;
                ctx.fillRect(p.x - pulse, p.y - pulse, p.width + pulse*2, p.height + pulse*2);
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                ctx.fillRect(p.x + 6, p.y + 6, p.width - 12, p.height - 12);
                ctx.fillStyle = p.color;
                ctx.font = 'bold 12px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(p.type[0].toUpperCase(), p.x + p.width/2, p.y + p.height/2 + 5);
            });

            // Player Drone
            if (playerDrone && activePowerups.drone > 0) {
                ctx.save();
                ctx.fillStyle = '#f80';
                ctx.shadowColor = '#f80';
                ctx.shadowBlur = 12;
                // Drone body
                ctx.beginPath();
                ctx.ellipse(playerDrone.x + 12, playerDrone.y + 12, 14, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                // Drone cockpit
                ctx.fillStyle = '#0ff';
                ctx.beginPath();
                ctx.arc(playerDrone.x + 8, playerDrone.y + 12, 5, 0, Math.PI * 2);
                ctx.fill();
                // Rotating blades
                ctx.fillStyle = '#fff';
                const bladeAngle = frame * 0.4;
                for (let i = 0; i < 2; i++) {
                    ctx.save();
                    ctx.translate(playerDrone.x + 12, playerDrone.y + 5);
                    ctx.rotate(bladeAngle + i * Math.PI);
                    ctx.fillRect(-12, -1, 24, 2);
                    ctx.restore();
                }
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // Player
            if (player.invincible === 0 || frame % 6 < 3) {
                ctx.save();
                ctx.translate(player.x + player.width/2, player.y + player.height/2);
                ctx.rotate(player.tilt * Math.PI / 180);

                // Ghost effect
                if (activePowerups.ghost > 0) {
                    ctx.globalAlpha = 0.4 + Math.sin(frame * 0.15) * 0.1;
                    // Ghost trail
                    ctx.fillStyle = 'rgba(150, 150, 150, 0.2)';
                    ctx.fillRect(-player.width/2 + 10, -player.height/2, player.width, player.height);
                    ctx.fillRect(-player.width/2 + 20, -player.height/2, player.width, player.height);
                }

                // Fire aura at high combo
                if (combo >= 15) {
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = ['#f00', '#f80', '#ff0'][i % 3];
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(
                            -20 + Math.random() * 10,
                            Math.random() * player.height - player.height/2,
                            10 + Math.random() * 10,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }

                // Shield effect
                if (activePowerups.shield > 0) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(frame * 0.2) * 0.3})`;
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, player.width/2 + 15, player.height/2 + 15, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Neon glow on helicopter
                if (combo >= 10) {
                    ctx.shadowColor = combo >= 20 ? '#f00' : '#f0f';
                    ctx.shadowBlur = 20;
                }

                // Skin color glow - strong and visible
                const skin = SKINS[currentSkin];
                if (skin && currentSkin !== 'default') {
                    let skinColor;
                    if (skin.special === 'rainbow') {
                        const hue = (frame * 3) % 360;
                        skinColor = `hsl(${hue}, 100%, 60%)`;
                    } else {
                        skinColor = skin.colors[0];
                    }
                    ctx.shadowColor = skinColor;
                    ctx.shadowBlur = 25 + Math.sin(frame * 0.1) * 10; // Pulsating glow
                }

                ctx.drawImage(sprites.helicopter, player.animFrame * 96, 0, 96, 48, -player.width/2, -player.height/2, player.width, player.height);

                // Skin is applied through shadow glow already set above

                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // Draw remote player (multiplayer)
            drawRemotePlayer();

            // Laser beam - PULSATING NEON
            if (laserActive) {
                const laserY = player.y + player.height / 2;
                // Strong pulsation - thin to thick
                const pulse = Math.sin(frame * 0.5) * 0.5 + 0.5; // 0 to 1
                const beamWidth = 8 + pulse * 30; // 8 to 38 pixels

                // Outer glow - pulses with beam
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 30 + pulse * 50;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.1 + pulse * 0.15})`;
                ctx.fillRect(player.x + player.width, laserY - beamWidth - 10, canvas.width, beamWidth * 2 + 20);

                // Electric sparks along edges
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + pulse * 0.5})`;
                ctx.lineWidth = 1 + pulse * 2;
                for (let x = player.x + player.width; x < canvas.width; x += 25) {
                    const jitter = (Math.random() - 0.5) * (8 + pulse * 10);
                    // Top edge
                    ctx.beginPath();
                    ctx.moveTo(x, laserY - beamWidth);
                    ctx.lineTo(x + 10, laserY - beamWidth + jitter);
                    ctx.lineTo(x + 20, laserY - beamWidth);
                    ctx.stroke();
                    // Bottom edge
                    ctx.beginPath();
                    ctx.moveTo(x, laserY + beamWidth);
                    ctx.lineTo(x + 10, laserY + beamWidth + jitter);
                    ctx.lineTo(x + 20, laserY + beamWidth);
                    ctx.stroke();
                }

                // Main beam gradient - intensity pulses
                const gradient = ctx.createLinearGradient(player.x + player.width, laserY - beamWidth, player.x + player.width, laserY + beamWidth);
                const alpha = 0.6 + pulse * 0.4;
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
                gradient.addColorStop(0.2, `rgba(0, 200, 255, ${alpha * 0.5})`);
                gradient.addColorStop(0.4, `rgba(100, 255, 255, ${alpha})`);
                gradient.addColorStop(0.5, '#fff');
                gradient.addColorStop(0.6, `rgba(100, 255, 255, ${alpha})`);
                gradient.addColorStop(0.8, `rgba(0, 200, 255, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(player.x + player.width, laserY - beamWidth, canvas.width, beamWidth * 2);

                // Core - also pulses
                const coreWidth = 2 + pulse * 6;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 15 + pulse * 20;
                ctx.fillStyle = '#fff';
                ctx.fillRect(player.x + player.width, laserY - coreWidth / 2, canvas.width, coreWidth);

                // Inner core (cyan)
                ctx.fillStyle = '#0ff';
                ctx.fillRect(player.x + player.width, laserY - 2, canvas.width, 4);

                // Particle sparks along beam
                if (frame % 2 === 0) {
                    for (let i = 0; i < 3; i++) {
                        particles.push({
                            x: player.x + player.width + Math.random() * (canvas.width - player.x),
                            y: laserY + (Math.random() - 0.5) * beamWidth * 2,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 6,
                            life: 20,
                            color: Math.random() > 0.5 ? '#0ff' : '#fff',
                            size: 2 + Math.random() * 3
                        });
                    }
                }

                ctx.shadowBlur = 0;
            }

            // Player bullets with neon
            player.bullets.forEach((b, idx) => {
                let bulletColor;
                if (activePowerups.spread > 0) {
                    // Rainbow colors for spread!
                    const hue = (frame * 5 + idx * 40 + b.x * 0.5) % 360;
                    bulletColor = `hsl(${hue}, 100%, 60%)`;
                    ctx.shadowBlur = 15;
                    // Extra glow trail
                    ctx.fillStyle = `hsla(${hue}, 100%, 70%, 0.3)`;
                    ctx.fillRect(b.x - 15, b.y - 2, 20, b.height + 4);
                } else if (combo >= 20) {
                    bulletColor = '#f80';
                    ctx.shadowBlur = 8;
                } else if (combo >= 10) {
                    bulletColor = '#f0f';
                    ctx.shadowBlur = 8;
                } else {
                    bulletColor = '#ff0';
                    ctx.shadowBlur = 8;
                }
                ctx.fillStyle = bulletColor;
                ctx.shadowColor = bulletColor;
                ctx.fillRect(b.x, b.y, b.width, b.height);
                // Bright core
                ctx.fillStyle = '#fff';
                ctx.fillRect(b.x + b.width - 8, b.y + 1, 8, b.height - 2);
                // Extra sparkle for spread
                if (activePowerups.spread > 0 && Math.random() > 0.7) {
                    particles.push({
                        x: b.x, y: b.y + b.height / 2,
                        vx: -2 - Math.random() * 2, vy: (Math.random() - 0.5) * 2,
                        life: 15, color: bulletColor, size: 2
                    });
                }
            });
            ctx.shadowBlur = 0;

            // Rockets with trails
            player.rockets.forEach(r => {
                // Trail
                r.trail.forEach((t, i) => {
                    ctx.fillStyle = `rgba(255, 150, 50, ${t.life / 20 * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 4 - i * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Rocket
                ctx.save();
                ctx.translate(r.x, r.y);
                ctx.rotate(r.angle);
                ctx.fillStyle = '#f80';
                ctx.fillRect(-10, -4, 20, 8);
                ctx.fillStyle = '#f00';
                ctx.fillRect(-10, -3, 5, 6);
                ctx.restore();
            });

            // Draw obstacles
            drawObstacles();

            // Enemies
            enemies.forEach(enemy => {
                drawPixelPlane(enemy.x, enemy.y, enemy.width, enemy.height, enemy.type, enemy.health < enemy.maxHealth, enemy.glowColor, enemy);

                // Health bar for multi-hit enemies
                if (enemy.maxHealth > 1) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
                }

                // Special visual effects for new enemy types
                if (enemy.type === 'kamikaze') {
                    // Flashing red warning glow
                    if (frame % 8 < 4) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width * 0.7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                } else if (enemy.type === 'blinker' && enemy.teleportWarning > 0) {
                    // Glitch/teleport warning effect
                    const glitchIntensity = enemy.teleportWarning / 30;
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15 * glitchIntensity;
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (Math.random() - 0.5) * 10 * glitchIntensity;
                        const offsetY = (Math.random() - 0.5) * 10 * glitchIntensity;
                        ctx.strokeRect(enemy.x + offsetX, enemy.y + offsetY, enemy.width, enemy.height);
                    }
                    ctx.shadowBlur = 0;
                } else if (enemy.type === 'shielder' && enemy.shieldHP > 0) {
                    // Energy shield in front
                    const shieldPulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(0, 150, 255, ${shieldPulse})`;
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#08f';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(enemy.x + 5, enemy.y + enemy.height/2, enemy.height * 0.6, -Math.PI/2, Math.PI/2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    // Shield HP indicator
                    ctx.fillStyle = '#08f';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText('‚õä' + enemy.shieldHP, enemy.x, enemy.y - 15);
                } else if (enemy.type === 'miner') {
                    // Green glow effect
                    ctx.shadowColor = '#0f0';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(enemy.x - 2, enemy.y - 2, enemy.width + 4, enemy.height + 4);
                    ctx.shadowBlur = 0;
                } else if (enemy.type === 'scout' && enemy.afterImages && enemy.afterImages.length > 0) {
                    // Draw afterimages
                    enemy.afterImages.forEach(img => {
                        ctx.globalAlpha = img.alpha || 0.3;
                        drawPixelPlane(img.x, img.y, enemy.width, enemy.height, 'scout', false, '#ff0');
                    });
                    ctx.globalAlpha = 1;
                }

                // === ADVANCED ENEMY EFFECTS ===

                // Laser Drone - charging indicator and laser beam
                if (enemy.type === 'laserDrone') {
                    if (enemy.laserCharging > 0) {
                        // Charging indicator - pulsing red line
                        ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(frame * 0.5) * 0.2})`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(enemy.x, enemy.laserTargetY);
                        ctx.lineTo(0, enemy.laserTargetY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    if (enemy.laserFiring > 0) {
                        // FIRE THE LASER!
                        const laserY = enemy.laserTargetY;
                        const laserWidth = 15 + Math.sin(frame * 0.8) * 5;

                        // White core
                        ctx.fillStyle = '#fff';
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 30;
                        ctx.fillRect(0, laserY - laserWidth/3, enemy.x, laserWidth/1.5);

                        // Red outer glow
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.fillRect(0, laserY - laserWidth, enemy.x, laserWidth * 2);
                        ctx.shadowBlur = 0;

                        // Damage player if hit
                        if (player.invincible === 0 && activePowerups.shield === 0) {
                            const playerMidY = player.y + player.height/2;
                            if (Math.abs(playerMidY - laserY) < laserWidth + 15) {
                                lives--;
                                player.invincible = 90;
                                screenShake = 20;
                                updateUI();
                                if (lives <= 0) gameOver();
                            }
                        }
                    }
                }

                // Gravity Well - distortion effect
                if (enemy.type === 'gravityWell') {
                    // Draw gravity field indicator
                    ctx.strokeStyle = 'rgba(0, 128, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 150, 0, Math.PI * 2);
                    ctx.stroke();
                    // Inner spinning ring
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 80, frame * 0.05, frame * 0.05 + Math.PI);
                    ctx.stroke();
                }

                // Tesla charged enemy effect
                if (enemy.charged) {
                    ctx.strokeStyle = '#0ff';
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 2;
                    // Electric arcs around enemy
                    for (let i = 0; i < 4; i++) {
                        const angle = frame * 0.2 + i * Math.PI / 2;
                        const ex = enemy.x + enemy.width/2 + Math.cos(angle) * (enemy.width * 0.6);
                        const ey = enemy.y + enemy.height/2 + Math.sin(angle) * (enemy.height * 0.6);
                        ctx.beginPath();
                        ctx.moveTo(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        ctx.lineTo(ex + (Math.random() - 0.5) * 10, ey + (Math.random() - 0.5) * 10);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                }

                // Enemy bullets
                enemy.bullets.forEach(b => {
                    if (b.isLightning) {
                        // Lightning bolt
                        ctx.strokeStyle = '#0ff';
                        ctx.shadowColor = '#0ff';
                        ctx.shadowBlur = 15;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(b.x, b.y);
                        for (let i = 0; i < 5; i++) {
                            ctx.lineTo(b.x - 10 - i * 8, b.y + (Math.random() - 0.5) * 20);
                        }
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = '#f44';
                        ctx.shadowColor = '#f44';
                        ctx.shadowBlur = 6;
                        ctx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
                    }
                });
            });
            ctx.shadowBlur = 0;

            // Boss
            drawBoss();
            if (boss) {
                boss.bullets.forEach(b => {
                    ctx.fillStyle = boss.enraged ? '#f00' : '#f0f';
                    ctx.shadowColor = boss.enraged ? '#f00' : '#f0f';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            // Mines
            mines.forEach(m => {
                const pulse = Math.sin(frame * 0.15 + m.x) * 0.3 + 0.7;
                ctx.save();

                // Mine body
                ctx.fillStyle = '#0a0';
                ctx.shadowColor = '#0f0';
                ctx.shadowBlur = 10 * pulse;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                ctx.fillStyle = `rgba(0, 255, 0, ${pulse * 0.5})`;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Spikes
                ctx.fillStyle = '#0f0';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + frame * 0.02;
                    const sx = m.x + Math.cos(angle) * (m.radius + 5);
                    const sy = m.y + Math.sin(angle) * (m.radius + 5);
                    ctx.beginPath();
                    ctx.arc(sx, sy, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Warning if player is close
                const distToPlayer = Math.hypot(player.x + player.width/2 - m.x, player.y + player.height/2 - m.y);
                if (distToPlayer < 100) {
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = (100 - distToPlayer) / 100;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            });

            // Mini-boss
            if (miniBoss) {
                const mb = miniBoss;
                ctx.save();

                // Cloaking effect
                if (mb.cloaked) {
                    ctx.globalAlpha = 0.15 + Math.sin(frame * 0.2) * 0.1;
                }

                // Main body
                ctx.fillStyle = mb.color;
                ctx.shadowColor = mb.color;
                ctx.shadowBlur = 15;
                ctx.fillRect(mb.x, mb.y, mb.width, mb.height);

                // Outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(mb.x, mb.y, mb.width, mb.height);

                // Cockpit
                ctx.fillStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 8;
                ctx.fillRect(mb.x + 5, mb.y + mb.height/2 - 10, 15, 20);

                // Engine flames
                const flameLen = 20 + Math.random() * 15;
                const gradient = ctx.createLinearGradient(mb.x + mb.width, mb.y + mb.height/2, mb.x + mb.width + flameLen, mb.y + mb.height/2);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, '#ff0');
                gradient.addColorStop(0.6, '#f80');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(mb.x + mb.width, mb.y + mb.height/2 - 8, flameLen, 16);

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;

                // Health bar
                ctx.fillStyle = '#300';
                ctx.fillRect(mb.x, mb.y - 15, mb.width, 8);
                const healthPct = mb.health / mb.maxHealth;
                ctx.fillStyle = healthPct > 0.5 ? '#0f0' : healthPct > 0.25 ? '#ff0' : '#f00';
                ctx.fillRect(mb.x, mb.y - 15, mb.width * healthPct, 8);

                // Name
                ctx.fillStyle = '#fff';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(mb.name, mb.x + mb.width/2, mb.y - 22);

                // Mini-boss bullets
                mb.bullets.forEach(b => {
                    if (b.isBomb) {
                        // Bomb visual
                        ctx.fillStyle = '#f00';
                        ctx.shadowColor = '#f00';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#f0f';
                        ctx.shadowColor = '#f0f';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.shadowBlur = 0;

                ctx.restore();
            }

            // Biome weather effects
            const biomeW = BIOMES[currentBiome];
            if (biomeW.weather === 'smog') {
                // City smog overlay
                ctx.fillStyle = 'rgba(80, 60, 40, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (biomeW.weather === 'storm') {
                // Ocean storm - occasional lightning
                if (Math.random() < 0.003) {
                    weather.lightning = 20;
                }
                // Rain drops
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 30; i++) {
                    const rx = (Math.random() * canvas.width + frame * 3) % canvas.width;
                    const ry = (Math.random() * canvas.height + frame * 8) % canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(rx, ry);
                    ctx.lineTo(rx - 5, ry + 15);
                    ctx.stroke();
                }
            } else if (biomeW.weather === 'sandstorm') {
                // Sandstorm - horizontal particles
                ctx.fillStyle = 'rgba(180, 140, 80, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(200, 150, 50, 0.4)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 40; i++) {
                    const sx = (Math.random() * canvas.width * 2 - frame * 5) % canvas.width;
                    const sy = Math.random() * canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + 25 + Math.random() * 20, sy + 3);
                    ctx.stroke();
                }
            } else if (biomeW.weather === 'meteors') {
                // Meteor shower - falling particles
                if (Math.random() < 0.03) {
                    particles.push({
                        x: canvas.width + 20,
                        y: Math.random() * canvas.height * 0.4,
                        vx: -12 - Math.random() * 5,
                        vy: 6 + Math.random() * 3,
                        life: 80,
                        color: '#f80',
                        size: 3 + Math.random() * 3
                    });
                }
            }

            // Floating texts
            ctx.textAlign = 'center';
            floatingTexts.forEach(t => {
                ctx.fillStyle = t.color;
                ctx.globalAlpha = Math.min(1, t.life / 35);
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 10;
                ctx.font = `${t.size || 12}px "Press Start 2P"`;
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Slow motion overlay
            if (slowMotion > 0) {
                ctx.fillStyle = `rgba(100, 0, 150, ${0.2 * (slowMotion / 90)})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Vignette effect
                const vignette = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, 100,
                    canvas.width/2, canvas.height/2, 500
                );
                vignette.addColorStop(0, 'transparent');
                vignette.addColorStop(1, `rgba(50, 0, 80, ${0.5 * (slowMotion / 90)})`);
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Time Slow powerup overlay
            if (activePowerups.timeslow > 0) {
                ctx.fillStyle = `rgba(120, 0, 200, ${0.15 + Math.sin(frame * 0.1) * 0.05})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Clock effect in corner
                ctx.fillStyle = '#a0f';
                ctx.shadowColor = '#a0f';
                ctx.shadowBlur = 10;
                ctx.font = '14px "Press Start 2P"';
                ctx.textAlign = 'right';
                ctx.fillText('‚è±Ô∏è TIME SLOW', canvas.width - 15, 90);
                ctx.shadowBlur = 0;
            }

            // Ghost powerup indicator
            if (activePowerups.ghost > 0) {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // MEGA UPGRADE: Rage Mode vignette
            if (isRageMode()) {
                const rageGrad = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, canvas.height * 0.3,
                    canvas.width/2, canvas.height/2, canvas.height * 0.8
                );
                rageGrad.addColorStop(0, 'transparent');
                rageGrad.addColorStop(1, 'rgba(255, 0, 0, 0.25)');
                ctx.fillStyle = rageGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // MEGA UPGRADE: Ultimate effect overlays
            if (ultActive === 'bulletTime') {
                ctx.fillStyle = 'rgba(0, 100, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (ultActive === 'godMode') {
                ctx.fillStyle = `rgba(255, 215, 0, ${0.05 + Math.sin(frame * 0.2) * 0.05})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // MEGA UPGRADE: Screen flash effect
            if (flashAlpha > 0.01) {
                ctx.fillStyle = flashColor || '#fff';
                ctx.globalAlpha = flashAlpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
                flashAlpha *= 0.9;
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!gameRunning || paused) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Show menu on load
        document.getElementById('startScreen').style.display = 'flex';

        // Music ON by default - start on first user interaction (browser requirement)
        let musicAutoStarted = false;
        function tryAutoStartMusic() {
            if (!musicAutoStarted && localStorage.getItem('menuMusicOn') !== 'false') {
                musicAutoStarted = true;
                playMenuMusic();
                updateMenuMusicButton();
            }
            document.removeEventListener('click', tryAutoStartMusic);
            document.removeEventListener('keydown', tryAutoStartMusic);
        }
        document.addEventListener('click', tryAutoStartMusic);
        document.addEventListener('keydown', tryAutoStartMusic);

        // Set button to show correct state
        if (localStorage.getItem('menuMusicOn') !== 'false') {
            document.getElementById('menuMusicBtn').textContent = 'üéµ ON';
        }
    </script>
</body>
</html>
